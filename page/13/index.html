<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="肖大强的个人博客">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="肖大强的个人博客">
<meta property="og:locale">
<meta property="article:author" content="xiaoq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>肖大强的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖大强的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab1/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1: Xv6 and Unix utilities"></a>Lab1: Xv6 and Unix utilities</h1><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><h2 id="启动xv6-难度：Easy"><a href="#启动xv6-难度：Easy" class="headerlink" title="启动xv6(难度：Easy)"></a>启动xv6(难度：Easy)</h2><p>获取实验室的xv6源代码并切换到util分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br><span class="line">Cloning into <span class="string">&#x27;xv6-labs-2020&#x27;</span>...</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line">$ git checkout util</span><br><span class="line">Branch <span class="string">&#x27;util&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;util&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;util&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Xv6-labs-2020存储库与本书的xv6-riscv稍有不同;它主要添加一些文件。如果你好奇的话，可以执行<code>git log</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>您将需要使用Git版本控制系统管理和提交文件以及后续的实验室作业。接下来，切换到一个分支(执行<code>git checkout util</code>)，其中包含针对该实验室定制的xv6版本。要了解关于Git的更多信息，请查看Git用户手册。Git允许您跟踪对代码所做的更改。例如，如果你完成了其中一个练习，并且想检查你的进度，你可以通过运行以下命令来提交你的变化:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&#x27;my solution for util lab exercise 1&#x27;</span></span><br><span class="line">Created commit 60d2135: my solution <span class="keyword">for</span> util lab exercise 1</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>git diff</code>命令跟踪您的更改。运行<code>git diff</code>将显示自上次提交以来对代码的更改，<code>git diff origin/util</code>将显示相对于初始xv6-labs-2020代码的更改。这里，<em><strong>origin&#x2F;xv6-labs-2020</strong></em>是git分支的名称，它是包含您下载的初始代码分支。</p>
<ul>
<li><strong>构建并运行xv6</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c</span><br><span class="line">...  </span><br><span class="line">riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o</span><br><span class="line">riscv64-unknown-elf-objdump -S user/_zombie &amp;gt; user/zombie.asm</span><br><span class="line">riscv64-unknown-elf-objdump -t user/_zombie | sed <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27;</span> &amp;gt; user/zombie.sym</span><br><span class="line">mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie </span><br><span class="line">nmeta 46 (boot, super, <span class="built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000</span><br><span class="line">balloc: first 591 blocks have been allocated</span><br><span class="line">balloc: write bitmap block at sector 45</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p>如果你在提示符下输入 <code>ls</code>，你会看到类似如下的输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2059</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line"><span class="built_in">cat</span>            2 4 24256</span><br><span class="line"><span class="built_in">echo</span>           2 5 23080</span><br><span class="line">forktest       2 6 13272</span><br><span class="line">grep           2 7 27560</span><br><span class="line">init           2 8 23816</span><br><span class="line"><span class="built_in">kill</span>           2 9 23024</span><br><span class="line"><span class="built_in">ln</span>             2 10 22880</span><br><span class="line"><span class="built_in">ls</span>             2 11 26448</span><br><span class="line"><span class="built_in">mkdir</span>          2 12 23176</span><br><span class="line"><span class="built_in">rm</span>             2 13 23160</span><br><span class="line">sh             2 14 41976</span><br><span class="line">stressfs       2 15 24016</span><br><span class="line">usertests      2 16 148456</span><br><span class="line">grind          2 17 38144</span><br><span class="line"><span class="built_in">wc</span>             2 18 25344</span><br><span class="line">zombie         2 19 22408</span><br><span class="line">console        3 20 0</span><br></pre></td></tr></table></figure>

<p>这些是<code>mkfs</code>在初始文件系统中包含的文件；大多数是可以运行的程序。你刚刚跑了其中一个：<code>ls</code>。</p>
<p>xv6没有<code>ps</code>命令，但是如果您键入Ctrl-p，内核将打印每个进程的信息。如果现在尝试，您将看到两行：一行用于init，另一行用于sh。</p>
<p>退出 qemu : <code>Ctrl-a x</code>。</p>
<h2 id="sleep-难度：Easy"><a href="#sleep-难度：Easy" class="headerlink" title="sleep(难度：Easy)"></a>sleep(难度：Easy)</h2><blockquote>
<p>[!TIP|label:YOUR JOB]<br><strong>实现xv6的UNIX程序</strong><code>sleep</code><strong>：您的</strong><code>sleep</code><strong>应该暂停到用户指定的计时数。一个滴答(tick)是由xv6内核定义的时间概念，即来自定时器芯片的两个中断之间的时间。您的解决方案应该在文件<em>user&#x2F;sleep.c</em>中</strong></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><p>在你开始编码之前，请阅读《book-riscv-rev1》的第一章</p>
</li>
<li><p>看看其他的一些程序（如***&#x2F;user&#x2F;echo.c, &#x2F;user&#x2F;grep.c, &#x2F;user&#x2F;rm.c***）查看如何获取传递给程序的命令行参数</p>
</li>
<li><p>如果用户忘记传递参数，<code>sleep</code>应该打印一条错误信息</p>
</li>
<li><p>命令行参数作为字符串传递; 您可以使用<code>atoi</code>将其转换为数字（详见***&#x2F;user&#x2F;ulib.c***）</p>
</li>
<li><p>使用系统调用<code>sleep</code></p>
</li>
<li><p>请参阅<em><strong>kernel&#x2F;sysproc.c</strong></em>以获取实现<code>sleep</code>系统调用的xv6内核代码（查找<code>sys_sleep</code>），<em><strong>user&#x2F;user.h</strong></em>提供了<code>sleep</code>的声明以便其他程序调用，用汇编程序编写的<em><strong>user&#x2F;usys.S</strong></em>可以帮助<code>sleep</code>从用户区跳转到内核区。</p>
</li>
<li><p>确保<code>main</code>函数调用<code>exit()</code>以退出程序。</p>
</li>
<li><p>将你的<code>sleep</code>程序添加到<em><strong>Makefile</strong></em>中的<code>UPROGS</code>中；完成之后，<code>make qemu</code>将编译您的程序，并且您可以从xv6的shell运行它。</p>
</li>
<li><p>看看Kernighan和Ritchie编著的《C程序设计语言》（第二版）来了解C语言。</p>
</li>
</ul>
<p>从xv6 shell运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">sleep</span> 10</span><br><span class="line">(nothing happens <span class="keyword">for</span> a little <span class="keyword">while</span>)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>如果程序在如上所示运行时暂停，则解决方案是正确的。运行<code>make grade</code>看看你是否真的通过了睡眠测试。</p>
<p>请注意，<code>make grade</code>运行所有测试，包括下面作业的测试。如果要对一项作业运行成绩测试，请键入（不要启动XV6，在外部终端下使用）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./grade-lab-util <span class="built_in">sleep</span></span><br></pre></td></tr></table></figure>

<p>这将运行与<code>sleep</code>匹配的成绩测试。或者，您可以键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make GRADEFLAGS=<span class="built_in">sleep</span> grade</span><br></pre></td></tr></table></figure>

<p>效果是一样的。</p>
<h2 id="pingpong（难度：Easy）"><a href="#pingpong（难度：Easy）" class="headerlink" title="pingpong（难度：Easy）"></a>pingpong（难度：Easy）</h2><blockquote>
<p>[!TIP|label:YOUR JOB]<br><strong>编写一个使用UNIX系统调用的程序来在两个进程之间“ping-pong”一个字节，请使用两个管道，每个方向一个。父进程应该向子进程发送一个字节;子进程应该打印“<code>&lt;pid&gt;: received ping</code>”，其中<code>&lt;pid&gt;</code>是进程ID，并在管道中写入字节发送给父进程，然后退出;父级应该从读取从子进程而来的字节，打印“<code>&lt;pid&gt;: received pong</code>”，然后退出。您的解决方案应该在文件<em>user&#x2F;pingpong.c</em>中。</strong></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><p>使用<code>pipe</code>来创造管道</p>
</li>
<li><p>使用<code>fork</code>创建子进程</p>
</li>
<li><p>使用<code>read</code>从管道中读取数据，并且使用<code>write</code>向管道中写入数据</p>
</li>
<li><p>使用<code>getpid</code>获取调用进程的pid</p>
</li>
<li><p>将程序加入到<em><strong>Makefile</strong></em>的<code>UPROGS</code></p>
</li>
<li><p>xv6上的用户程序有一组有限的可用库函数。您可以在<em><strong>user&#x2F;user.h</strong></em>中看到可调用的程序列表；源代码（系统调用除外）位于<em><strong>user&#x2F;ulib.c</strong></em>、<em><strong>user&#x2F;printf.c</strong></em>和<em><strong>user&#x2F;umalloc.c</strong></em>中。</p>
</li>
</ul>
<p>运行程序应得到下面的输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ pingpong</span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>如果您的程序在两个进程之间交换一个字节并产生如上所示的输出，那么您的解决方案是正确的。</p>
<h2 id="Primes-素数，难度：Moderate-x2F-Hard"><a href="#Primes-素数，难度：Moderate-x2F-Hard" class="headerlink" title="Primes(素数，难度：Moderate&#x2F;Hard)"></a>Primes(素数，难度：Moderate&#x2F;Hard)</h2><blockquote>
<p>[!TIP|label:YOUR JOB]<br><strong>使用管道编写</strong><code>prime sieve</code><strong>(筛选素数)的并发版本。这个想法是由Unix管道的发明者Doug McIlroy提出的。请查看<a target="_blank" rel="noopener" href="http://swtch.com/~rsc/thread/">这个网站</a>(翻译在下面)，该网页中间的图片和周围的文字解释了如何做到这一点。您的解决方案应该在<em>user&#x2F;primes.c</em>文件中。</strong></p>
</blockquote>
<p>您的目标是使用<code>pipe</code>和<code>fork</code>来设置管道。第一个进程将数字2到35输入管道。对于每个素数，您将安排创建一个进程，该进程通过一个管道从其左邻居读取数据，并通过另一个管道向其右邻居写入数据。由于xv6的文件描述符和进程数量有限，因此第一个进程可以在35处停止。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p>请仔细关闭进程不需要的文件描述符，否则您的程序将在第一个进程达到35之前就会导致xv6系统资源不足。</p>
</li>
<li><p>一旦第一个进程达到35，它应该使用<code>wait</code>等待整个管道终止，包括所有子孙进程等等。因此，主<code>primes</code>进程应该只在打印完所有输出之后，并且在所有其他<code>primes</code>进程退出之后退出。</p>
</li>
<li><p>提示：当管道的<code>write</code>端关闭时，<code>read</code>返回零。</p>
</li>
<li><p>最简单的方法是直接将32位（4字节）int写入管道，而不是使用格式化的ASCII I&#x2F;O。</p>
</li>
<li><p>您应该仅在需要时在管线中创建进程。</p>
</li>
<li><p>将程序添加到<em><strong>Makefile</strong></em>中的<code>UPROGS</code></p>
</li>
</ul>
<p>如果您的解决方案实现了基于管道的筛选并产生以下输出，则是正确的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ primes</span><br><span class="line">prime 2</span><br><span class="line">prime 3</span><br><span class="line">prime 5</span><br><span class="line">prime 7</span><br><span class="line">prime 11</span><br><span class="line">prime 13</span><br><span class="line">prime 17</span><br><span class="line">prime 19</span><br><span class="line">prime 23</span><br><span class="line">prime 29</span><br><span class="line">prime 31</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<p><strong>参考资料翻译：</strong></p>
<blockquote>
<p>考虑所有小于1000的素数的生成。Eratosthenes的筛选法可以通过执行以下伪代码的进程管线来模拟：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    <span class="keyword">if</span> (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br><span class="line">p = 从左邻居中获取一个数</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = 从左邻居中获取一个数</span><br><span class="line">    <span class="keyword">if</span> (n不能被p整除)</span><br><span class="line">        将n发送给右邻居</span><br></pre></td></tr></table></figure>

<p><img src="/images/p1.png" alt="img"></p>
<blockquote>
<p>生成进程可以将数字2、3、4、…、1000输入管道的左端：行中的第一个进程消除2的倍数，第二个进程消除3的倍数，第三个进程消除5的倍数，依此类推。</p>
</blockquote>
<h2 id="find（难度：Moderate）"><a href="#find（难度：Moderate）" class="headerlink" title="find（难度：Moderate）"></a>find（难度：Moderate）</h2><blockquote>
<p>[!TIP|label:YOUR JOB]<br><strong>写一个简化版本的UNIX的<code>find</code>程序：查找目录树中具有特定名称的所有文件，你的解决方案应该放在<em>user&#x2F;find.c</em></strong></p>
</blockquote>
<p>提示：</p>
<ul>
<li>查看<em><strong>user&#x2F;ls.c</strong></em>文件学习如何读取目录</li>
<li>使用递归允许<code>find</code>下降到子目录中</li>
<li>不要在“<code>.</code>”和“<code>..</code>”目录中递归</li>
<li>对文件系统的更改会在qemu的运行过程中一直保持；要获得一个干净的文件系统，请运行<code>make clean</code>，然后<code>make qemu</code></li>
<li>你将会使用到C语言的字符串，要学习它请看《C程序设计语言》（K&amp;R）,例如第5.5节</li>
<li>注意在C语言中不能像python一样使用“<code>==</code>”对字符串进行比较，而应当使用<code>strcmp()</code></li>
<li>将程序加入到Makefile的<code>UPROGS</code></li>
</ul>
<p>如果你的程序输出下面的内容，那么它是正确的（当文件系统中包含文件<em><strong>b</strong></em>和<em><strong>a&#x2F;b</strong></em>的时候）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">echo</span> &gt; b</span><br><span class="line">$ <span class="built_in">mkdir</span> a</span><br><span class="line">$ <span class="built_in">echo</span> &gt; a/b</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<h2 id="xargs（难度：Moderate）"><a href="#xargs（难度：Moderate）" class="headerlink" title="xargs（难度：Moderate）"></a>xargs（难度：Moderate）</h2><blockquote>
<p>[!TIP|label:YOUR JOB]<br>编写一个简化版UNIX的<code>xargs</code>程序：它从标准输入中按行读取，并且为每一行执行一个命令，将行作为参数提供给命令。你的解决方案应该在<em><strong>user&#x2F;xargs.c</strong></em></p>
</blockquote>
<p>下面的例子解释了<code>xargs</code>的行为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>注意，这里的命令是<code>echo bye</code>，额外的参数是<code>hello too</code>，这样就组成了命令<code>echo bye hello too</code>，此命令输出<code>bye hello too</code></p>
<p>请注意，UNIX上的<code>xargs</code>进行了优化，一次可以向该命令提供更多的参数。 我们不需要您进行此优化。 要使UNIX上的<code>xargs</code>表现出本实验所实现的方式，请将<code>-n</code>选项设置为1。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="built_in">echo</span> line</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>使用<code>fork</code>和<code>exec</code>对每行输入调用命令，在父进程中使用<code>wait</code>等待子进程完成命令。</li>
<li>要读取单个输入行，请一次读取一个字符，直到出现换行符（’\n’）。</li>
<li><em><strong>kernel&#x2F;param.h</strong></em>声明<code>MAXARG</code>，如果需要声明<code>argv</code>数组，这可能很有用。</li>
<li>将程序添加到<em><strong>Makefile</strong></em>中的<code>UPROGS</code>。</li>
<li>对文件系统的更改会在qemu的运行过程中保持不变；要获得一个干净的文件系统，请运行<code>make clean</code>，然后<code>make qemu</code></li>
</ul>
<p><code>xargs</code>、<code>find</code>和<code>grep</code>结合得很好</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . b | xargs grep hello</span><br></pre></td></tr></table></figure>

<p>将对“<code>.</code>”下面的目录中名为<em><strong>b</strong></em>的每个文件运行<code>grep hello</code>。</p>
<p>要测试您的<code>xargs</code>方案是否正确，请运行shell脚本<em><strong>xargstest.sh</strong></em>。如果您的解决方案产生以下输出，则是正确的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ sh &lt; xargstest.sh</span><br><span class="line">$ $ $ $ $ $ hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">$ $   </span><br></pre></td></tr></table></figure>

<p>你可能不得不回去修复你的<code>find</code>程序中的bug。输出有许多<code>$</code>，因为xv6 shell没有意识到它正在处理来自文件而不是控制台的命令，并为文件中的每个命令打印<code>$</code>。</p>
<h1 id="提交实验"><a href="#提交实验" class="headerlink" title="提交实验"></a>提交实验</h1><p><strong>这就完成了实验</strong>。确保你通过了所有的成绩测试。如果这个实验有问题，别忘了把你的答案写在<em><strong>answers-lab-name.txt</strong></em>中<em><strong>。</strong></em>提交你的更改（包括<em><strong>answers-lab-name.txt</strong></em>），然后在实验目录中键入<code>make handin</code>以提交实验。</p>
<p><strong>花费的时间</strong></p>
<p>创建一个命名为<em><strong>time.txt</strong></em>的新文件，并在其中输入一个整数，即您在实验室花费的小时数。不要忘记<code>git add</code>和<code>git commit</code>文件。</p>
<p><strong>提交</strong></p>
<p>你将使用**<a target="_blank" rel="noopener" href="https://6828.scripts.mit.edu/2020/handin.py/">提交网站</a>**提交作业。您需要从提交网站请求一次API密钥，然后才能提交任何作业或实验。</p>
<p>将最终更改提交到实验后，键入<code>make handin</code>以提交实验。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;ready to submit my lab&quot;</span></span><br><span class="line">[util c2e3c8b] ready to submit my lab</span><br><span class="line"> 2 files changed, 18 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line">$ make handin</span><br><span class="line">tar: Removing leading `/<span class="string">&#x27; from member names</span></span><br><span class="line"><span class="string">Get an API key for yourself by visiting https://6828.scripts.mit.edu/2020/handin.py/</span></span><br><span class="line"><span class="string">Please enter your API key: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line"><span class="string">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line"><span class="string">                                 Dload  Upload   Total   Spent    Left  Speed</span></span><br><span class="line"><span class="string">100 79258  100   239  100 79019    853   275k --:--:-- --:--:-- --:--:--  276k</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure>

<p><code>make handin</code>将把你的API密钥存储在<em><strong>myapi.key</strong></em>中。如果需要更改API密钥，只需删除此文件并让<code>make handin</code>再次生成它(<em><strong>myapi.key</strong></em>不得包含换行符）。</p>
<p>如果你运行了<code>make handin</code>，并且你有未提交的更改或未跟踪的文件，则会看到类似于以下内容的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> M hello.c</span><br><span class="line">?? bar.c</span><br><span class="line">?? foo.pyc</span><br><span class="line">Untracked files will not be handed in.  Continue? [y/N]</span><br></pre></td></tr></table></figure>

<p>检查上述行，确保跟踪了您的实验解决方案所需的所有文件，即以??开头的行中所显示的文件。您可以使用<code>git add filename</code>命令使git追踪创建的新文件。</p>
<p>如果<code>make handin</code>无法正常工作，请尝试使用curl或Git命令修复该问题。或者你可以运行<code>make tarball</code>。这将为您制作一个tar文件，然后您可以通过我们的web界面上传。</p>
<ul>
<li>请运行“<code>make grade</code>”以确保您的代码通过所有测试</li>
<li>在运行“<code>make handin</code>”之前提交任何修改过的源代码&#96;</li>
<li>您可以检查提交的状态，并在以下位置下载提交的代码：<a target="_blank" rel="noopener" href="https://6828.scripts.mit.edu/2020/handin.py/">https://6828.scripts.mit.edu/2020/handin.py/</a></li>
</ul>
<h1 id="可选的挑战练习"><a href="#可选的挑战练习" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h1><ul>
<li><p>编写一个<code>uptime</code>程序，使用<code>uptime</code>系统调用以滴答为单位打印计算机正常运行时间。（easy）</p>
</li>
<li><p>在<code>find</code>程序的名称匹配中支持正则表达式。<em><strong>grep.c</strong></em>对正则表达式有一些基本的支持。（easy）</p>
</li>
<li><p>xv6 shell（<em><strong>user&#x2F;sh.c</strong></em>）只是另一个用户程序，您可以对其进行改进。它是一个最小的shell，缺少建立在真实shell中的许多特性。例如，</p>
<ul>
<li>在处理<strong>文件中的</strong>shell命令时，将shell修改为不打印$（moderate）</li>
<li>将shell修改为支持<code>wait</code>（easy）</li>
<li>将shell修改为支持用“<code>;</code>”分隔的命令列表（moderate）</li>
<li>通过实现左括号“<code>(</code>” 以及右括号“<code>)</code>”来修改shell以支持子shell（moderate）</li>
<li>将shell修改为支持<code>tab</code>键补全（easy）</li>
<li>修改shell使其支持命令历史记录（moderate）</li>
<li>或者您希望shell执行的任何其他操作。</li>
</ul>
</li>
<li><p>如果您非常雄心勃勃，可能需要修改内核以支持所需的内核特性；xv6支持的并不多。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab10/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab10/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab10-mmap"><a href="#Lab10-mmap" class="headerlink" title="Lab10: mmap"></a>Lab10: mmap</h1><h1 id="mmap-hard"><a href="#mmap-hard" class="headerlink" title="mmap(hard)"></a>mmap(hard)</h1><p><code>mmap</code>和<code>munmap</code>系统调用允许UNIX程序对其地址空间进行详细控制。它们可用于在进程之间共享内存，将文件映射到进程地址空间，并作为用户级页面错误方案的一部分，如本课程中讨论的垃圾收集算法。在本实验室中，您将把<code>mmap</code>和<code>munmap</code>添加到xv6中，重点关注内存映射文件（memory-mapped files）。</p>
<p>获取实验室的xv6源代码并切换到<code>mmap</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout mmap</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<p>手册页面（运行<code>man 2 mmap</code>）显示了<code>mmap</code>的以下声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过多种方式调用<code>mmap</code>，但本实验只需要与内存映射文件相关的功能子集。您可以假设<code>addr</code>始终为零，这意味着内核应该决定映射文件的虚拟地址。<code>mmap</code>返回该地址，如果失败则返回<code>0xffffffffffffffff</code>。<code>length</code>是要映射的字节数；它可能与文件的长度不同。<code>prot</code>指示内存是否应映射为可读、可写，以及&#x2F;或者可执行的；您可以认为<code>prot</code>是<code>PROT_READ</code>或<code>PROT_WRITE</code>或两者兼有。<code>flags</code>要么是<code>MAP_SHARED</code>（映射内存的修改应写回文件），要么是<code>MAP_PRIVATE</code>（映射内存的修改不应写回文件）。您不必在<code>flags</code>中实现任何其他位。<code>fd</code>是要映射的文件的打开文件描述符。可以假定<code>offset</code>为零（它是要映射的文件的起点）。</p>
<p>允许进程映射同一个<code>MAP_SHARED</code>文件而不共享物理页面。</p>
<p><code>munmap(addr, length)</code>应删除指定地址范围内的<code>mmap</code>映射。如果进程修改了内存并将其映射为<code>MAP_SHARED</code>，则应首先将修改写入文件。<code>munmap</code>调用可能只覆盖<code>mmap</code>区域的一部分，但您可以认为它取消映射的位置要么在区域起始位置，要么在区域结束位置，要么就是整个区域(但不会在区域中间“打洞”)。</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>您应该实现足够的<code>mmap</code>和<code>munmap</code>功能，以使<code>mmaptest</code>测试程序正常工作。如果<code>mmaptest</code>不会用到某个<code>mmap</code>的特性，则不需要实现该特性。</p>
</blockquote>
<p>完成后，您应该会看到以下输出： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ mmaptest</span><br><span class="line">mmap_test starting</span><br><span class="line"><span class="built_in">test</span> mmap f</span><br><span class="line"><span class="built_in">test</span> mmap f: OK</span><br><span class="line"><span class="built_in">test</span> mmap private</span><br><span class="line"><span class="built_in">test</span> mmap private: OK</span><br><span class="line"><span class="built_in">test</span> mmap read-only</span><br><span class="line"><span class="built_in">test</span> mmap read-only: OK</span><br><span class="line"><span class="built_in">test</span> mmap <span class="built_in">read</span>/write</span><br><span class="line"><span class="built_in">test</span> mmap <span class="built_in">read</span>/write: OK</span><br><span class="line"><span class="built_in">test</span> mmap dirty</span><br><span class="line"><span class="built_in">test</span> mmap dirty: OK</span><br><span class="line"><span class="built_in">test</span> not-mapped unmap</span><br><span class="line"><span class="built_in">test</span> not-mapped unmap: OK</span><br><span class="line"><span class="built_in">test</span> mmap two files</span><br><span class="line"><span class="built_in">test</span> mmap two files: OK</span><br><span class="line">mmap_test: ALL OK</span><br><span class="line">fork_test starting</span><br><span class="line">fork_test OK</span><br><span class="line">mmaptest: all tests succeeded</span><br><span class="line">$ usertests</span><br><span class="line">usertests starting</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>首先，向<code>UPROGS</code>添加<code>_mmaptest</code>，以及<code>mmap</code>和<code>munmap</code>系统调用，以便让<em><strong>user&#x2F;mmaptest.c</strong></em>进行编译。现在，只需从<code>mmap</code>和<code>munmap</code>返回错误。我们在<em><strong>kernel&#x2F;fcntl.h</strong></em>中为您定义了<code>PROT_READ</code>等。运行<code>mmaptest</code>，它将在第一次<code>mmap</code>调用时失败。</li>
<li>惰性地填写页表，以响应页错误。也就是说，<code>mmap</code>不应该分配物理内存或读取文件。相反，在<code>usertrap</code>中（或由<code>usertrap</code>调用）的页面错误处理代码中执行此操作，就像在lazy page allocation实验中一样。惰性分配的原因是确保大文件的<code>mmap</code>是快速的，并且比物理内存大的文件的<code>mmap</code>是可能的。</li>
<li>跟踪<code>mmap</code>为每个进程映射的内容。定义与第15课中描述的VMA（虚拟内存区域）对应的结构体，记录<code>mmap</code>创建的虚拟内存范围的地址、长度、权限、文件等。由于xv6内核中没有内存分配器，因此可以声明一个固定大小的VMA数组，并根据需要从该数组进行分配。大小为16应该就足够了。</li>
<li>实现<code>mmap</code>：在进程的地址空间中找到一个未使用的区域来映射文件，并将VMA添加到进程的映射区域表中。VMA应该包含指向映射文件对应<code>struct file</code>的指针；<code>mmap</code>应该增加文件的引用计数，以便在文件关闭时结构体不会消失（提示：请参阅<code>filedup</code>）。运行<code>mmaptest</code>：第一次<code>mmap</code>应该成功，但是第一次访问被<code>mmap</code>的内存将导致页面错误并终止<code>mmaptest</code>。</li>
<li>添加代码以导致在<code>mmap</code>的区域中产生页面错误，从而分配一页物理内存，将4096字节的相关文件读入该页面，并将其映射到用户地址空间。使用<code>readi</code>读取文件，它接受一个偏移量参数，在该偏移处读取文件（但必须lock&#x2F;unlock传递给<code>readi</code>的索引结点）。不要忘记在页面上正确设置权限。运行<code>mmaptest</code>；它应该到达第一个<code>munmap</code>。</li>
<li>实现<code>munmap</code>：找到地址范围的VMA并取消映射指定页面（提示：使用<code>uvmunmap</code>）。如果<code>munmap</code>删除了先前<code>mmap</code>的所有页面，它应该减少相应<code>struct file</code>的引用计数。如果未映射的页面已被修改，并且文件已映射到<code>MAP_SHARED</code>，请将页面写回该文件。查看<code>filewrite</code>以获得灵感。</li>
<li>理想情况下，您的实现将只写回程序实际修改的<code>MAP_SHARED</code>页面。RISC-V PTE中的脏位（<code>D</code>）表示是否已写入页面。但是，<code>mmaptest</code>不检查非脏页是否没有回写；因此，您可以不用看<code>D</code>位就写回页面。</li>
<li>修改<code>exit</code>将进程的已映射区域取消映射，就像调用了<code>munmap</code>一样。运行<code>mmaptest</code>；<code>mmap_test</code>应该通过，但可能不会通过<code>fork_test</code>。</li>
<li>修改<code>fork</code>以确保子对象具有与父对象相同的映射区域。不要忘记增加VMA的<code>struct file</code>的引用计数。在子进程的页面错误处理程序中，可以分配新的物理页面，而不是与父级共享页面。后者会更酷，但需要更多的实施工作。运行<code>mmaptest</code>；它应该通过<code>mmap_test</code>和<code>fork_test</code>。</li>
</ul>
<p>运行<code>usertests</code>以确保一切正常。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab8/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab8-Locks"><a href="#Lab8-Locks" class="headerlink" title="Lab8: Locks"></a>Lab8: Locks</h1><h1 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h1><p>本实验完成的任务是为每个CPU都维护一个空闲列表，初始时将所有的空闲内存分配到某个CPU，此后各个CPU需要内存时，如果当前CPU的空闲列表上没有，则窃取其他CPU的。例如，所有的空闲内存初始分配到CPU0，当CPU1需要内存时就会窃取CPU0的，而使用完成后就挂在CPU1的空闲列表，此后CPU1再次需要内存时就可以从自己的空闲列表中取。</p>
<p>(1). 将<code>kmem</code>定义为一个数组，包含<code>NCPU</code>个元素，即每个CPU对应一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure>

<p>(2). 修改<code>kinit</code>，为所有锁初始化以“kmem”开头的名称，该函数只会被一个CPU调用，<code>freerange</code>调用<code>kfree</code>将所有空闲内存挂在该CPU的空闲列表上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> lockname[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(lockname, <span class="keyword">sizeof</span>(lockname), <span class="string">&quot;kmem_%d&quot;</span>, i);</span><br><span class="line">    initlock(&amp;kmem[i].lock, lockname);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3). 修改<code>kfree</code>，使用<code>cpuid()</code>和它返回的结果时必须关中断，请参考《XV6使用手册》第7.4节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  acquire(&amp;kmem[id].lock);</span><br><span class="line">  r-&gt;next = kmem[id].freelist;</span><br><span class="line">  kmem[id].freelist = r;</span><br><span class="line">  release(&amp;kmem[id].lock);</span><br><span class="line">  pop_off();  <span class="comment">//开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4). 修改<code>kalloc</code>，使得在当前CPU的空闲列表没有可分配内存时窃取其他内存的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  push_off();<span class="comment">// 关中断</span></span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  acquire(&amp;kmem[id].lock);</span><br><span class="line">  r = kmem[id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[id].freelist = r-&gt;next;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> antid;  <span class="comment">// another id</span></span><br><span class="line">    <span class="comment">// 遍历所有CPU的空闲列表</span></span><br><span class="line">    <span class="keyword">for</span>(antid = <span class="number">0</span>; antid &lt; NCPU; ++antid) &#123;</span><br><span class="line">      <span class="keyword">if</span>(antid == id)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      acquire(&amp;kmem[antid].lock);</span><br><span class="line">      r = kmem[antid].freelist;</span><br><span class="line">      <span class="keyword">if</span>(r) &#123;</span><br><span class="line">        kmem[antid].freelist = r-&gt;next;</span><br><span class="line">        release(&amp;kmem[antid].lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem[antid].lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem[id].lock);</span><br><span class="line">  pop_off();  <span class="comment">//开中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h1><p>这个实验的目的是将缓冲区的分配与回收并行化以提高效率，这个实验折腾了一天，有些内容还是比较绕的，</p>
<p>(1). 定义哈希桶结构，并在<code>bcache</code>中删除全局缓冲区链表，改为使用素数个散列桶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBUCKET 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH(id) (id % NBUCKET)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashbuf</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span>       <span class="comment">// 头节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>  <span class="comment">// 锁</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hashbuf</span> <span class="title">buckets</span>[<span class="title">NBUCKET</span>];</span>  <span class="comment">// 散列桶</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>(2). 在<code>binit</code>中，（1）初始化散列桶的锁，（2）将所有散列桶的<code>head-&gt;prev</code>、<code>head-&gt;next</code>都指向自身表示为空，（3）将所有的缓冲区挂载到<code>bucket[0]</code>桶上，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">b</span>;</span></span><br><span class="line">  <span class="type">char</span> lockname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; ++i) &#123;</span><br><span class="line">    <span class="comment">// 初始化散列桶的自旋锁</span></span><br><span class="line">    <span class="built_in">snprintf</span>(lockname, <span class="keyword">sizeof</span>(lockname), <span class="string">&quot;bcache_%d&quot;</span>, i);</span><br><span class="line">    initlock(&amp;bcache.buckets[i].lock, lockname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化散列桶的头节点</span></span><br><span class="line">    bcache.buckets[i].head.prev = &amp;bcache.buckets[i].head;</span><br><span class="line">    bcache.buckets[i].head.next = &amp;bcache.buckets[i].head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf + NBUF; b++) &#123;</span><br><span class="line">    <span class="comment">// 利用头插法初始化缓冲区列表,全部放到散列桶0上</span></span><br><span class="line">    b-&gt;next = bcache.buckets[<span class="number">0</span>].head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.buckets[<span class="number">0</span>].head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].head.next-&gt;prev = b;</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3). 在<em><strong>buf.h</strong></em>中增加新字段<code>timestamp</code>，这里来理解一下这个字段的用途：在原始方案中，每次<code>brelse</code>都将被释放的缓冲区挂载到链表头，禀明这个缓冲区最近刚刚被使用过，在<code>bget</code>中分配时从链表尾向前查找，这样符合条件的第一个就是最久未使用的。而在提示中建议使用时间戳作为LRU判定的法则，这样我们就无需在<code>brelse</code>中进行头插法更改结点位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  uint timestamp;  <span class="comment">// 时间戳</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(4). 更改<code>brelse</code>，不再获取全局锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf* b)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bid = HASH(b-&gt;blockno);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新时间戳</span></span><br><span class="line">  <span class="comment">// 由于LRU改为使用时间戳判定，不再需要头插法</span></span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  b-&gt;timestamp = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5). 更改<code>bget</code>，当没有找到指定的缓冲区时进行分配，分配方式是优先从当前列表遍历，找到一个没有引用且<code>timestamp</code>最小的缓冲区，如果没有就申请下一个桶的锁，并遍历该桶，找到后将该缓冲区从原来的桶移动到当前桶中，最多将所有桶都遍历完。在代码中要注意锁的释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bid = HASH(blockno);</span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buckets[bid].head.next; b != &amp;bcache.buckets[bid].head; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 记录使用时间戳</span></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      b-&gt;timestamp = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">      release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 从当前散列桶开始查找</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = bid, cycle = <span class="number">0</span>; cycle != NBUCKET; i = (i + <span class="number">1</span>) % NBUCKET) &#123;</span><br><span class="line">    ++cycle;</span><br><span class="line">    <span class="comment">// 如果遍历到当前散列桶，则不重新获取锁</span></span><br><span class="line">    <span class="keyword">if</span>(i != bid) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!holding(&amp;bcache.buckets[i].lock))</span><br><span class="line">        acquire(&amp;bcache.buckets[i].lock);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(tmp = bcache.buckets[i].head.next; tmp != &amp;bcache.buckets[i].head; tmp = tmp-&gt;next)</span><br><span class="line">      <span class="comment">// 使用时间戳进行LRU算法，而不是根据结点在链表中的位置</span></span><br><span class="line">      <span class="keyword">if</span>(tmp-&gt;refcnt == <span class="number">0</span> &amp;&amp; (b == <span class="number">0</span> || tmp-&gt;timestamp &lt; b-&gt;timestamp))</span><br><span class="line">        b = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(b) &#123;</span><br><span class="line">      <span class="comment">// 如果是从其他散列桶窃取的，则将其以头插法插入到当前桶</span></span><br><span class="line">      <span class="keyword">if</span>(i != bid) &#123;</span><br><span class="line">        b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">        b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">        release(&amp;bcache.buckets[i].lock);</span><br><span class="line"></span><br><span class="line">        b-&gt;next = bcache.buckets[bid].head.next;</span><br><span class="line">        b-&gt;prev = &amp;bcache.buckets[bid].head;</span><br><span class="line">        bcache.buckets[bid].head.next-&gt;prev = b;</span><br><span class="line">        bcache.buckets[bid].head.next = b;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      b-&gt;timestamp = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">      release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在当前散列桶中未找到，则直接释放锁</span></span><br><span class="line">      <span class="keyword">if</span>(i != bid)</span><br><span class="line">        release(&amp;bcache.buckets[i].lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(6). 最后将末尾的两个小函数也改一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf* b)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bid = HASH(b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf* b)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bid = HASH(b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>踩过的坑：</p>
<ol>
<li>bget中重新分配可能要持有两个锁，如果桶a持有自己的锁，再申请桶b的锁，与此同时如果桶b持有自己的锁，再申请桶a的锁就会造成死锁！因此代码中使用了<code>if(!holding(&amp;bcache.bucket[i].lock))</code>来进行检查。此外，代码优先从自己的桶中获取缓冲区，如果自身没有依次向后查找这样的方式也尽可能地避免了前面的情况。</li>
<li>在<code>bget</code>中搜索缓冲区并在找不到缓冲区时为该缓冲区分配条目必须是原子的！在提示中说<code>bget</code>如果未找到而进行分配的操作可以是串行化的，也就是说多个CPU中未找到，应当串行的执行分配，同时还应当避免死锁。于是在发现未命中（Not cached）后，我写了如下的代码（此时未删除<code>bcache.lock</code>）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前半部分查找缓冲区的代码</span></span><br><span class="line"><span class="comment">// Not cached</span></span><br><span class="line">release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">acquire(&amp;bcache.lock);</span><br><span class="line">acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line"><span class="comment">// 后半部分分配缓冲区的代码</span></span><br></pre></td></tr></table></figure>

<p>这段代码中先释放了散列桶的锁之后再重新获取，之所以这样做是为了让所有代码都保证申请锁的顺序：先获取整个缓冲区的大锁再获取散列桶的小锁，这样才能避免死锁。<strong>但是这样做却破坏了程序执行的原子性</strong>。</p>
<p>在<code>release</code>桶的锁并重新<code>acquire</code>的这段时间，另一个CPU可能也以相同的参数调用了<code>bget</code>，也发现没有该缓冲区并想要执行分配。最终的结果是一个磁盘块对应了两个缓冲区，破坏了最重要的不变量，即每个块最多缓存一个副本。这样会导致<code>usertests</code>中的<code>manywrites</code>测试报错：<em>panic: freeing free block</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab7/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab7-Multithreading"><a href="#Lab7-Multithreading" class="headerlink" title="Lab7: Multithreading"></a>Lab7: Multithreading</h1><h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><p>本实验是在给定的代码基础上实现用户级线程切换，相比于XV6中实现的内核级线程，这个要简单许多。因为是用户级线程，不需要设计用户栈和内核栈，用户页表和内核页表等等切换，所以本实验中只需要一个类似于<code>context</code>的结构，而不需要费尽心机的维护<code>trapframe</code></p>
<p>(1). 定义存储上下文的结构体<code>tcontext</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户线程的上下文结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcontext</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(2). 修改<code>thread</code>结构体，添加<code>context</code>字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>            <span class="built_in">stack</span>[STACK_SIZE];  <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>             state;              <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcontext</span> <span class="title">context</span>;</span>            <span class="comment">/* 用户进程上下文 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(3). 模仿<em><strong>kernel&#x2F;swtch.S，</strong></em>在<em><strong>kernel&#x2F;uthread_switch.S</strong></em>中写入如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* save the old thread&#x27;s registers,</span><br><span class="line">* restore the new thread&#x27;s registers.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">    /* YOUR CODE HERE */</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    sd s0, 16(a0)</span><br><span class="line">    sd s1, 24(a0)</span><br><span class="line">    sd s2, 32(a0)</span><br><span class="line">    sd s3, 40(a0)</span><br><span class="line">    sd s4, 48(a0)</span><br><span class="line">    sd s5, 56(a0)</span><br><span class="line">    sd s6, 64(a0)</span><br><span class="line">    sd s7, 72(a0)</span><br><span class="line">    sd s8, 80(a0)</span><br><span class="line">    sd s9, 88(a0)</span><br><span class="line">    sd s10, 96(a0)</span><br><span class="line">    sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ld s0, 16(a1)</span><br><span class="line">    ld s1, 24(a1)</span><br><span class="line">    ld s2, 32(a1)</span><br><span class="line">    ld s3, 40(a1)</span><br><span class="line">    ld s4, 48(a1)</span><br><span class="line">    ld s5, 56(a1)</span><br><span class="line">    ld s6, 64(a1)</span><br><span class="line">    ld s7, 72(a1)</span><br><span class="line">    ld s8, 80(a1)</span><br><span class="line">    ld s9, 88(a1)</span><br><span class="line">    ld s10, 96(a1)</span><br><span class="line">    ld s11, 104(a1)</span><br><span class="line">    ret    /* return to ra */</span><br></pre></td></tr></table></figure>

<p>(4). 修改<code>thread_scheduler</code>，添加线程切换语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">  thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;current_thread-&gt;context);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>(5). 在<code>thread_create</code>中对<code>thread</code>结构体做一些初始化设定，主要是<code>ra</code>返回地址和<code>sp</code>栈指针，其他的都不重要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YOUR CODE HERE</span></span><br><span class="line">t-&gt;context.ra = (uint64)func;                   <span class="comment">// 设定函数返回地址</span></span><br><span class="line">t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;  <span class="comment">// 设定栈指针</span></span><br></pre></td></tr></table></figure>

<h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><p>来看一下程序的运行过程：设定了五个散列桶，根据键除以5的余数决定插入到哪一个散列桶中，插入方法是头插法，下面是图示</p>
<p>不支持在 Docs 外粘贴 block</p>
<p>这个实验比较简单，首先是问为什么为造成数据丢失：</p>
<blockquote>
<p>假设现在有两个线程T1和T2，两个线程都走到put函数，且假设两个线程中key%NBUCKET相等，即要插入同一个散列桶中。两个线程同时调用insert(key, value, &amp;table[i], table[i])，insert是通过头插法实现的。如果先insert的线程还未返回另一个线程就开始insert，那么前面的数据会被覆盖</p>
</blockquote>
<p>因此只需要对插入操作上锁即可</p>
<p>(1). 为每个散列桶定义一个锁，将五个锁放在一个数组中，并进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET] = &#123; PTHREAD_MUTEX_INITIALIZER &#125;; <span class="comment">// 每个散列桶一把锁</span></span><br></pre></td></tr></table></figure>

<p>(2). 在<code>put</code>函数中对<code>insert</code>上锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;lock[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><p>额。。。这个也比较简单，只要保证下一个round的操作不会影响到上一个还未结束的round中的数据就可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 申请持有锁</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread == nthread) &#123;</span><br><span class="line">    <span class="comment">// 所有线程已到达</span></span><br><span class="line">    bstate.round++;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 等待其他线程</span></span><br><span class="line">    <span class="comment">// 调用pthread_cond_wait时，mutex必须已经持有</span></span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab9/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab9-file-system"><a href="#Lab9-file-system" class="headerlink" title="Lab9: file system"></a>Lab9: file system</h1><h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><p>(1). 在fs.h中添加宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDINDIRECT ((BSIZE / sizeof(uint)) * (BSIZE / sizeof(uint)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NDINDIRECT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NADDR_PER_BLOCK (BSIZE / sizeof(uint))  <span class="comment">// 一个块中的地址数量</span></span></span><br></pre></td></tr></table></figure>

<p>(2). 由于<code>NDIRECT</code>定义改变，其中一个直接块变为了二级间接块，需要修改inode结构体中<code>addrs</code>元素数量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  uint addrs[NDIRECT + <span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  uint addrs[NDIRECT + <span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(3). 修改<code>bmap</code>支持二级索引</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二级间接块的情况</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDINDIRECT) &#123;</span><br><span class="line">    <span class="type">int</span> level2_idx = bn / NADDR_PER_BLOCK;  <span class="comment">// 要查找的块号位于二级间接块中的位置</span></span><br><span class="line">    <span class="type">int</span> level1_idx = bn % NADDR_PER_BLOCK;  <span class="comment">// 要查找的块号位于一级间接块中的位置</span></span><br><span class="line">    <span class="comment">// 读出二级间接块</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((addr = a[level2_idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[level2_idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="comment">// 更改了当前块的内容，标记以供后续写回磁盘</span></span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[level1_idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[level1_idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4). 修改<code>itrunc</code>释放所有块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">bp1</span>;</span></span><br><span class="line">  uint* a1;</span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) &#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NADDR_PER_BLOCK; i++) &#123;</span><br><span class="line">      <span class="comment">// 每个一级间接块的操作都类似于上面的</span></span><br><span class="line">      <span class="comment">// if(ip-&gt;addrs[NDIRECT])中的内容</span></span><br><span class="line">      <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">        bp1 = bread(ip-&gt;dev, a[i]);</span><br><span class="line">        a1 = (uint*)bp1-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NADDR_PER_BLOCK; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a1[j])</span><br><span class="line">            bfree(ip-&gt;dev, a1[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp1);</span><br><span class="line">        bfree(ip-&gt;dev, a[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><p>(1). 配置系统调用的常规操作，如在<em><strong>user&#x2F;usys.pl</strong></em>、<em><strong>user&#x2F;user.h</strong></em>中添加一个条目，在<em><strong>kernel&#x2F;syscall.c</strong></em>、<em><strong>kernel&#x2F;syscall.h</strong></em>中添加相关内容</p>
<p>(2). 添加提示中的相关定义，<code>T_SYMLINK</code>以及<code>O_NOFOLLOW</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fcntl.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x004</span></span><br><span class="line"><span class="comment">// stat.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK 4</span></span><br></pre></td></tr></table></figure>

<p>(3). 在<em><strong>kernel&#x2F;sysfile.c</strong></em>中实现<code>sys_symlink</code>，这里需要注意的是<code>create</code>返回已加锁的inode，此外<code>iunlockput</code>既对inode解锁，还将其引用计数减1，计数为0时回收此inode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">ip_path</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 分配一个inode结点，create返回锁定的inode</span></span><br><span class="line">  ip_path = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(ip_path == <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向inode数据块中写入target路径</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip_path, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) &lt; MAXPATH) &#123;</span><br><span class="line">    iunlockput(ip_path);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip_path);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4). 修改<code>sys_open</code>支持打开符号链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理符号链接</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) &#123;</span><br><span class="line">    <span class="comment">// 若符号链接指向的仍然是符号链接，则递归的跟随它</span></span><br><span class="line">    <span class="comment">// 直到找到真正指向的文件</span></span><br><span class="line">    <span class="comment">// 但深度不能超过MAX_SYMLINK_DEPTH</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SYMLINK_DEPTH; ++i) &#123;</span><br><span class="line">      <span class="comment">// 读出符号链接指向的路径</span></span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) != MAXPATH) &#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      ip = namei(path);</span><br><span class="line">      <span class="keyword">if</span>(ip == <span class="number">0</span>) &#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ilock(ip);</span><br><span class="line">      <span class="keyword">if</span>(ip-&gt;type != T_SYMLINK)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过最大允许深度后仍然为符号链接，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/summary/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/summary/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/summary/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验解析"><a href="#实验解析" class="headerlink" title="实验解析"></a>实验解析</h1><p>这里存放了各个实验的逐步解析，水平有限，可能并非最优解。</p>
<p>前几个实验当时没有做记录，以后再补上</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab3/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="lab3-pgtbl"><a href="#lab3-pgtbl" class="headerlink" title="lab3: pgtbl"></a>lab3: pgtbl</h1><h1 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a>1. Print a page table</h1><p>本实验主要是实现一个打印页表内容的函数， 首先根据提示在<code>exec.c</code>中的<code>return argc</code>之前插入<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code></p>
<p>然后看一下<em>kernel&#x2F;vm.c</em>里面的<code>freewalk</code>方法，主要的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它首先会遍历整个页表。当遇到有效的页表项并且不在最后一层的时候，它会递归调用。<code>PTE_V</code>是用来判断页表项是否有效，而<code>(pte &amp; (PTE_R|PTE_W|PTE_X)) == 0</code>则是用来判断是否不在最后一层。因为最后一层页表中页表项中W位，R位，X位起码有一位会被设置为1。注释里面说所有最后一层的页表项已经被释放了，所以遇到不符合的情况就<code>panic(&quot;freewalk: leaf&quot;)</code>。</p>
<p>那么，根据<code>freewalk</code>，我们可以写下递归函数。对于每一个有效的页表项都打印其和其子项的内容。如果不是最后一层的页表就继续递归。通过<code>level</code>来控制前缀<code>..</code>的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param pagetable 所要打印的页表</span></span><br><span class="line"><span class="comment"> * @param level 页表的层级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="comment">// PTE_V is a flag for whether the page table is valid</span></span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; level; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        _vmprint((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief vmprint 打印页表</span></span><br><span class="line"><span class="comment"> * @param pagetable 所要打印的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后记得加到<em>kernel&#x2F;defs.h</em>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>             <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>重新跑一下<code>make qemu</code>，可以看到下面的输出：</p>
<p><img src="/./images/p4.png"></p>
<h1 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2. A kernel page table per process"></a>2. A kernel page table per process</h1><p>本实验主要是让每个进程都有自己的内核页表，这样在内核中执行时使用它自己的内核页表的副本。</p>
<p><strong>(1)</strong>. 首先给<em>kernel&#x2F;proc.h</em>里面的<code>struct proc</code>加上内核页表的字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line"><span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line"><span class="type">pagetable_t</span> kernelpt;      <span class="comment">// 进程的内核页表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong>. 在<code>vm.c</code>中添加新的方法<code>proc_kpt_init</code>，该方法用于在<code>allocproc</code> 中初始化进程的内核页表。这个函数还需要一个辅助函数<code>uvmmap</code>，该函数和<code>kvmmap</code>方法几乎一致，不同的是<code>kvmmap</code>是对Xv6的内核页表进行映射，而<code>uvmmap</code>将用于进程的内核页表进行映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Just follow the kvmmap on vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a kernel page table for the process</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kpt_init</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kernelpt = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (kernelpt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  uvmmap(kernelpt, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kernelpt, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kernelpt, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kernelpt, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kernelpt, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  uvmmap(kernelpt, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kernelpt, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kernelpt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<em>kernel&#x2F;proc.c</em>里面的<code>allocproc</code>调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// An empty user page table.</span></span><br><span class="line">p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init the kernal page table</span></span><br><span class="line">p-&gt;kernelpt = proc_kpt_init();</span><br><span class="line"><span class="keyword">if</span>(p-&gt;kernelpt == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>(3)</strong>. 根据提示，为了确保每一个进程的内核页表都关于该进程的内核栈有一个映射。我们需要将<code>procinit</code>方法中相关的代码迁移到<code>allocproc</code>方法中。很明显就是下面这段代码，将其剪切到上述内核页表初始化的代码后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a page for the process&#x27;s kernel stack.</span><br><span class="line">// Map it high in memory, followed by an invalid</span><br><span class="line">// guard page.</span><br><span class="line">char *pa = kalloc();</span><br><span class="line">if(pa == 0)</span><br><span class="line">  panic(&quot;kalloc&quot;);</span><br><span class="line">uint64 va = KSTACK((int) (p - proc));</span><br><span class="line">uvmmap(p-&gt;kernelpt, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure>

<p><strong>(4)</strong>. 我们需要修改<code>scheduler()</code>来加载进程的内核页表到SATP寄存器。提示里面请求阅读<code>kvminithart()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvminithart</code>是用于原先的内核页表，我们将进程的内核页表传进去就可以。在<em>vm.c</em>里面添加一个新方法<code>proc_inithart</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store kernel page table to SATP register</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_inithart</span><span class="params">(<span class="type">pagetable_t</span> kpt)</span>&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kpt));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>scheduler()</code>内调用即可，但在结束的时候，需要切换回原先的<code>kernel_pagetable</code>。直接调用调用上面的<code>kvminithart()</code>就能把Xv6的内核页表加载回去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the kernal page table into the SATP</span></span><br><span class="line">proc_inithart(p-&gt;kernelpt);</span><br><span class="line"></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Come back to the global kernel page table</span></span><br><span class="line">kvminithart();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>(5)</strong>. 在<code>freeproc</code>中释放一个进程的内核页表。首先释放页表内的内核栈，调用<code>uvmunmap</code>可以解除映射，最后的一个参数（<code>do_free</code>）为一的时候，会释放实际内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free the kernel stack in the RAM</span></span><br><span class="line">uvmunmap(p-&gt;kernelpt, p-&gt;kstack, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">p-&gt;kstack = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>然后释放进程的内核页表，先在<em>kernel&#x2F;proc.c</em>里面添加一个方法<code>proc_freekernelpt</code>。如下，历遍整个内核页表，然后将所有有效的页表项清空为零。如果这个页表项不在最后一层的页表上，需要继续进行递归。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freekernelpt</span><span class="params">(<span class="type">pagetable_t</span> kernelpt)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// similar to the freewalk method</span></span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = kernelpt[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      kernelpt[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        proc_freekernelpt((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)kernelpt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(6)</strong>. 将需要的函数定义添加到 <code>kernel/defs.h</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pagetable_t</span>     <span class="title function_">proc_kpt_init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 用于内核页表的初始化</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">kvminithart</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="type">void</span>            <span class="title function_">proc_inithart</span><span class="params">(<span class="type">pagetable_t</span>)</span>; <span class="comment">// 将进程的内核页表保存到SATP寄存器</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>(7)</strong>. 修改<code>vm.c</code>中的<code>kvmpa</code>，将原先的<code>kernel_pagetable</code>改成<code>myproc()-&gt;kernelpt</code>，使用进程的内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  </span><br><span class="line">  pte = walk(myproc()-&gt;kernelpt, va, <span class="number">0</span>); <span class="comment">// 修改这里</span></span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(8)</strong>. 测试一下我们的代码，先跑起<code>qemu</code>，然后跑一下<code>usertests</code>。这部分耗时会比较长。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">&gt; usertests</span><br></pre></td></tr></table></figure>

<p>得到以下输出：</p>
<p><img src="/./images/p5.png"></p>
<h1 id="3-Simplify-copyin-copyinstr"><a href="#3-Simplify-copyin-copyinstr" class="headerlink" title="3. Simplify copyin/copyinstr"></a>3. Simplify <code>copyin/copyinstr</code></h1><p>本实验是实现将用户空间的映射添加到每个进程的内核页表，将进程的页表复制一份到进程的内核页表就好。</p>
<p>首先添加复制函数。需要注意的是，在内核模式下，无法访问设置了<code>PTE_U</code>的页面，所以我们要将其移除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">u2kvmcopy</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> kernelpt, uint64 oldsz, uint64 newsz)</span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte_from, *pte_to;</span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span> (uint64 i = oldsz; i &lt; newsz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte_from = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;u2kvmcopy: src pte does not exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pte_to = walk(kernelpt, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;u2kvmcopy: pte walk failed&quot;</span>);</span><br><span class="line">    uint64 pa = PTE2PA(*pte_from);</span><br><span class="line">    uint flags = (PTE_FLAGS(*pte_from)) &amp; (~PTE_U);</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在内核更改进程的用户映射的每一处 （<code>fork()</code>, <code>exec()</code>, 和<code>sbrk()</code>），都复制一份到进程的内核页表。</p>
<ul>
<li><code>exec()</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加复制逻辑</span></span><br><span class="line">  u2kvmcopy(pagetable, p-&gt;kernelpt, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fork()</code>:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 复制到新进程的内核页表</span></span><br><span class="line">  u2kvmcopy(np-&gt;pagetable, np-&gt;kernelpt, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sbrk()</code>， 在<em>kernel&#x2F;sysproc.c</em>里面找到<code>sys_sbrk(void)</code>，可以知道只有<code>growproc</code>是负责将用户内存增加或缩小 n 个字节。以防止用户进程增长到超过<code>PLIC</code>的地址，我们需要给它加个限制。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 加上PLIC限制</span></span><br><span class="line">    <span class="keyword">if</span> (PGROUNDUP(sz + n) &gt;= PLIC)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制一份到内核页表</span></span><br><span class="line">    u2kvmcopy(p-&gt;pagetable, p-&gt;kernelpt, sz - n, sz);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后替换掉原有的<code>copyin()</code>和<code>copyinstr()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且添加到 <code>kernel/defs.h</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vmcopyin.c</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">copyin_new</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">copyinstr_new</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br></pre></td></tr></table></figure>

<p>最后跑一下最终测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make grade</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：这里笔者加了<em>time.txt</em>和<em>answers-pgtbl.txt</em>来通过全部测试，不影响上述的代码实现。</p>
<p><img src="/./images/p6.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab5/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab5-xv6-lazy-page-allocation"><a href="#Lab5-xv6-lazy-page-allocation" class="headerlink" title="Lab5: xv6 lazy page allocation"></a>Lab5: xv6 lazy page allocation</h1><h1 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h1><p>这个实验很简单，就仅仅改动<code>sys_sbrk()</code>函数即可，将实际分配内存的函数删除，而仅仅改变进程的<code>sz</code>属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="comment">// lazy allocation</span></span><br><span class="line">  myproc()-&gt;sz += n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h1><p>根据提示来做就好，另外6.S081对应的视频课程中对这部分代码做出了很大一部分的解答。</p>
<p><strong>(1)</strong>. 修改<code>usertrap()</code>(<em><strong>kernel&#x2F;trap.c</strong></em>)函数，使用<code>r_scause()</code>判断是否为页面错误，在页面错误处理的过程中，先判断发生错误的虚拟地址（<code>r_stval()</code>读取）是否位于栈空间之上，进程大小（虚拟地址从0开始，进程大小表征了进程的最高虚拟地址）之下，然后分配物理内存并添加映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uint64 cause = r_scause();</span><br><span class="line"><span class="keyword">if</span>(cause == <span class="number">8</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(cause == <span class="number">13</span> || cause == <span class="number">15</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理页面错误</span></span><br><span class="line">  uint64 fault_va = r_stval();  <span class="comment">// 产生页面错误的虚拟地址</span></span><br><span class="line">  <span class="type">char</span>* pa;                     <span class="comment">// 分配的物理地址</span></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="number">1</span> &lt; fault_va &amp;&amp; fault_va &lt; p-&gt;sz &amp;&amp;</span><br><span class="line">    (pa = kalloc()) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(pa, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(fault_va), PGSIZE, (uint64)pa, PTE_R | PTE_W | PTE_X | PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(pa);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;usertrap(): out of memory!\n&quot;);</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong>. 修改<code>uvmunmap()</code>(<em><strong>kernel&#x2F;vm.c</strong></em>)，之所以修改这部分代码是因为lazy allocation中首先并未实际分配内存，所以当解除映射关系的时候对于这部分内存要略过，而不是使系统崩溃，这部分在课程视频中已经解答。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h1><p><strong>(1)</strong>. 处理<code>sbrk()</code>参数为负数的情况，参考之前<code>sbrk()</code>调用的<code>growproc()</code>程序，如果为负数，就调用<code>uvmdealloc()</code>函数，但需要限制缩减后的内存空间不能小于0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  uint64 sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// lazy allocation</span></span><br><span class="line">    p-&gt;sz += n;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sz + n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    p-&gt;sz = sz;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong>. 正确处理<code>fork</code>的内存拷贝：<code>fork</code>调用了<code>uvmcopy</code>进行内存拷贝，所以修改<code>uvmcopy</code>如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)</strong>. 还需要继续修改<code>uvmunmap</code>，否则会运行出错，关于为什么要使用两个<code>continue</code>，请看本文最下面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4)</strong>. 处理通过sbrk申请内存后还未实际分配就传给系统调用使用的情况，系统调用的处理会陷入内核，scause寄存器存储的值是8，如果此时传入的地址还未实际分配，就不能走到上文usertrap中判断scause是13或15后进行内存分配的代码，syscall执行就会失败</p>
<ul>
<li><p>系统调用流程：</p>
<ul>
<li>陷入内核**&#x3D;&#x3D;&gt;<strong><code>usertrap</code>中<code>r_scause()==8</code>的分支</strong>&#x3D;&#x3D;&gt;<strong><code>syscall()</code></strong>&#x3D;&#x3D;&gt;**回到用户空间</li>
</ul>
</li>
<li><p>页面错误流程：</p>
<ul>
<li>陷入内核**&#x3D;&#x3D;&gt;<strong><code>usertrap</code>中<code>r_scause()==13||r_scause()==15</code>的分支</strong>&#x3D;&#x3D;&gt;<strong>分配内存</strong>&#x3D;&#x3D;&gt;**回到用户空间</li>
</ul>
</li>
</ul>
<p>因此就需要找到在何时系统调用会使用这些地址，将地址传入系统调用后，会通过<code>argaddr</code>函数(<em><strong>kernel&#x2F;syscall.c</strong></em>)从寄存器中读取，因此在这里添加物理内存分配的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理向系统调用传入lazy allocation地址的情况</span></span><br><span class="line">  <span class="keyword">if</span>(walkaddr(p-&gt;pagetable, *ip) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="number">1</span> &lt; *ip &amp;&amp; *ip &lt; p-&gt;sz) &#123;</span><br><span class="line">      <span class="type">char</span>* pa = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pa, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(*ip), PGSIZE, (uint64)pa, PTE_R | PTE_W | PTE_X | PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(pa);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么使用两个continue"><a href="#为什么使用两个continue" class="headerlink" title="为什么使用两个continue"></a>为什么使用两个continue</h2><p>这里需要解释一下为什么在两个判断中使用了<code>continue</code>语句，在课程视频中仅仅添加了第二个<code>continue</code>，利用<code>vmprint</code>打印出来初始时刻用户进程的页表如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f55000</span><br><span class="line">..0: pte 0x0000000021fd3c01 pa 0x0000000087f4f000</span><br><span class="line">.. ..0: pte 0x0000000021fd4001 pa 0x0000000087f50000</span><br><span class="line">.. .. ..0: pte 0x0000000021fd445f pa 0x0000000087f51000</span><br><span class="line">.. .. ..1: pte 0x0000000021fd4cdf pa 0x0000000087f53000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd900f pa 0x0000000087f64000</span><br><span class="line">.. .. ..3: pte 0x0000000021fd5cdf pa 0x0000000087f57000</span><br><span class="line">..255: pte 0x0000000021fd5001 pa 0x0000000087f54000</span><br><span class="line">.. ..511: pte 0x0000000021fd4801 pa 0x0000000087f52000</span><br><span class="line">.. .. ..510: pte 0x0000000021fd58c7 pa 0x0000000087f56000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c4b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>

<p>除去高地址的trapframe和trampoline页面，进程共计映射了4个有效页面，即添加了映射关系的虚拟地址范围是<code>0x0000~0x3fff</code>，假如使用<code>sbrk</code>又申请了一个页面，由于lazy allocation，页表暂时不会改变，而不经过读写操作后直接释放进程，进程将会调用<code>uvmunmap</code>函数，此时将会发生什么呢？</p>
<p><code>uvmunmap</code>首先使用<code>walk</code>找到虚拟地址对应的PTE地址，虚拟地址的最后12位表征了偏移量，前面每9位索引一级页表，将<code>0x4000</code>的虚拟地址写为二进制（省略前面的无效位）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;000 0000 00&#125;[00 0000 000](0 0000 0100) 0000 0000 0000</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#123;&#125;</code>：页目录表索引(level&#x3D;&#x3D;2)，为0</li>
<li><code>[]</code>：二级页表索引(level&#x3D;&#x3D;1)，为0</li>
<li><code>()</code>：三级页表索引(level&#x3D;&#x3D;0)，为4</li>
</ul>
<p>我们来看一下<code>walk</code>函数，<code>walk</code>返回指定虚拟地址的PTE，但我认为这个程序存在一定的不足。walk函数的代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中<code>for</code>循环执行<code>level==2</code>和<code>level==1</code>的情况，而对照刚才打印的页表，<code>level==2</code>时索引为0的项是存在的，<code>level==1</code>时索引为0的项也是存在的，最后执行<code>return</code>语句，然而level&#x3D;&#x3D;0时索引为4的项却是不存在的，此时<code>walk</code>不再检查<code>PTE_V</code>标志等信息，而是直接返回，因此即使虚拟地址对应的PTE实际不存在，<code>walk</code>函数的返回值也可能不为0！</p>
<p>那么返回的这个地址是什么呢？level为0时</p>
<p>有效索引为0~3，因此索引为4时返回的是最后一个有效PTE后面的一个地址。</p>
<p>因此我们不能仅靠PTE为0来判断虚拟地址无效，还需要再次检查返回的PTE中是否设置了<code>PTE_V</code>标志位。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab2/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="lab2-syscall"><a href="#lab2-syscall" class="headerlink" title="lab2: syscall"></a>lab2: syscall</h1><h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>本实验主要是实现一个追踪系统调用的函数，那么首先根据提示定义<code>trace</code>系统调用，并修复编译错误。</p>
<p>首先看一下<em>user&#x2F;trace.c</em>的内容，主要的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (trace(atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;</span><br><span class="line">    nargv[i<span class="number">-2</span>] = argv[i];</span><br><span class="line">&#125;</span><br><span class="line">exec(nargv[<span class="number">0</span>], nargv);</span><br></pre></td></tr></table></figure>

<p>它首先调用<code>trace(int)</code>，然后将命令行中的参数<code>argv</code>复制到<code>nargv</code>中，同时删去前两个参数，例如</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argv  = trace 32 grep hello README</span><br><span class="line">nargv = grep hello README</span><br></pre></td></tr></table></figure>

<p>那么，根据提示，我们首先再<code>proc</code>结构体中添加一个数据字段，用于保存<code>trace</code>的参数。并在<code>sys_trace()</code>的实现中实现参数的保存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> trace_mask;    <span class="comment">// trace系统调用参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取系统调用的参数</span></span><br><span class="line">  argint(<span class="number">0</span>, &amp;(myproc()-&gt;trace_mask));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>struct proc</code>中增加了一个新的变量,当<code>fork</code>的时候我们也需要将这个变量传递到子进程中(提示中已说明)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将trace_mask拷贝到子进程</span></span><br><span class="line">  np-&gt;trace_mask = p-&gt;trace_mask;</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来应当考虑如何进行系统调用追踪了，根据提示，这将在<code>syscall()</code>函数中实现。下面是实现代码，需要注意的是条件判断中使用了<code>&amp;</code>而不是<code>==</code>，这是因为在实验说明书的例子中，<code>trace 2147483647 grep hello README</code>将所有31个低位置为1，使得其可以追踪所有的系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  <span class="comment">// 系统调用编号，参见书中4.3节</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// 执行系统调用，然后将返回值存入a0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统调用是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;trace_mask)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们还有一些引用的变量尚未定义，在<em>syscall.c</em>中定义他们</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *syscalls_name[] = &#123;</span><br><span class="line">[SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">[SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">[SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">[SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">[SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">[SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">[SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">[SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">[SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">[SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">[SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">[SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">[SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">[SYS_uptime]  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">[SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">[SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">[SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">[SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">[SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">[SYS_trace]   <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h2><ul>
<li>在<em>kernel&#x2F;kalloc.c</em>中添加一个函数用于获取空闲内存量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>内存是使用链表进行管理的，因此遍历<code>kmem</code>中的空闲链表就能够获取所有的空闲内存，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freebytes</span><span class="params">(uint64 *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">  *dst = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">p</span> =</span> kmem.freelist; <span class="comment">// 用于遍历</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    *dst += PGSIZE;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<em>kernel&#x2F;proc.c</em>中添加一个函数获取进程数</li>
</ul>
<p>遍历<code>proc</code>数组，统计处于活动状态的进程即可，循环的写法参考<code>scheduler</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procnum</span><span class="params">(uint64 *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">  *dst = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">      (*dst)++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现<code>sys_sysinfo</code>，将数据写入结构体并传递到用户空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  freebytes(&amp;info.freemem);</span><br><span class="line">  procnum(&amp;info.nproc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取虚拟地址</span></span><br><span class="line">  uint64 dstaddr;</span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;dstaddr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从内核空间拷贝数据到用户空间</span></span><br><span class="line">  <span class="keyword">if</span> (copyout(myproc()-&gt;pagetable, dstaddr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span> info) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab6/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab6-Copy-on-Write-Fork-for-xv6"><a href="#Lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab6: Copy-on-Write Fork for xv6"></a>Lab6: Copy-on-Write Fork for xv6</h1><p>跟着提示一步一步来</p>
<p><strong>(1).</strong> 在<em><strong>kernel&#x2F;riscv.h</strong></em>中选取PTE中的保留位定义标记一个页面是否为COW Fork页面的标志位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录应用了COW策略后fork的页面</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_F (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure>

<p><strong>(2).</strong> 在<em><strong>kalloc.c</strong></em>中进行如下修改</p>
<ul>
<li><p>定义引用计数的全局变量<code>ref</code>，其中包含了一个自旋锁和一个引用计数数组，由于<code>ref</code>是全局变量，会被自动初始化为全0。</p>
<p>这里使用自旋锁是考虑到这种情况：进程P1和P2共用内存M，M引用计数为2，此时CPU1要执行<code>fork</code>产生P1的子进程，CPU2要终止P2，那么假设两个CPU同时读取引用计数为2，执行完成后CPU1中保存的引用计数为3，CPU2保存的计数为1，那么后赋值的语句会覆盖掉先赋值的语句，从而产生错误</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ref_stru</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> cnt[PHYSTOP / PGSIZE];  <span class="comment">// 引用计数</span></span><br><span class="line">&#125; ref;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>kinit</code>中初始化<code>ref</code>的自旋锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;ref.lock, <span class="string">&quot;ref&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>kalloc</code>和<code>kfree</code>函数，在<code>kalloc</code>中初始化内存引用计数为1，在<code>kfree</code>函数中对内存引用计数减1，如果引用计数为0时才真正删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有当引用计数为0了才回收空间</span></span><br><span class="line">  <span class="comment">// 否则只是将引用计数减1</span></span><br><span class="line">  acquire(&amp;ref.lock);</span><br><span class="line">  <span class="keyword">if</span>(--ref.cnt[(uint64)pa / PGSIZE] == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;ref.lock);</span><br><span class="line"></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    release(&amp;ref.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">    acquire(&amp;ref.lock);</span><br><span class="line">    ref.cnt[(uint64)r / PGSIZE] = <span class="number">1</span>;  <span class="comment">// 将引用计数初始化为1</span></span><br><span class="line">    release(&amp;ref.lock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加如下四个函数，详细说明已在注释中，这些函数中用到了<code>walk</code>，记得在<em><strong>defs.h</strong></em>中添加声明，最后也需要将这些函数的声明添加到<em><strong>defs.h</strong></em>，在cowalloc中，读取内存引用计数，如果为1，说明只有当前进程引用了该物理内存（其他进程此前已经被分配到了其他物理页面），就只需要改变PTE使能<code>PTE_W</code>；否则就分配物理页面，并将原来的内存引用计数减1。该函数需要返回物理地址，这将在<code>copyout</code>中使用到。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief cowpage 判断一个页面是否为COW页面</span></span><br><span class="line"><span class="comment"> * @param pagetable 指定查询的页表</span></span><br><span class="line"><span class="comment"> * @param va 虚拟地址</span></span><br><span class="line"><span class="comment"> * @return 0 是 -1 不是</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cowpage</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">pte_t</span>* pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (*pte &amp; PTE_F ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief cowalloc copy-on-write分配器</span></span><br><span class="line"><span class="comment"> * @param pagetable 指定页表</span></span><br><span class="line"><span class="comment"> * @param va 指定的虚拟地址,必须页面对齐</span></span><br><span class="line"><span class="comment"> * @return 分配后va对应的物理地址，如果返回0则分配失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">cowalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(va % PGSIZE != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  uint64 pa = walkaddr(pagetable, va);  <span class="comment">// 获取对应的物理地址</span></span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">pte_t</span>* pte = walk(pagetable, va, <span class="number">0</span>);  <span class="comment">// 获取对应的PTE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(krefcnt((<span class="type">char</span>*)pa) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 只剩一个进程对此物理地址存在引用</span></span><br><span class="line">    <span class="comment">// 则直接修改对应的PTE即可</span></span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line">    *pte &amp;= ~PTE_F;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)pa;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 多个进程对物理内存存在引用</span></span><br><span class="line">    <span class="comment">// 需要分配新的页面，并拷贝旧页面的内容</span></span><br><span class="line">    <span class="type">char</span>* mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制旧页面内容到新页</span></span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除PTE_V，否则在mappagges中会判定为remap</span></span><br><span class="line">    *pte &amp;= ~PTE_V;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新页面添加映射</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, va, PGSIZE, (uint64)mem, (PTE_FLAGS(*pte) | PTE_W) &amp; ~PTE_F) != <span class="number">0</span>) &#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      *pte |= PTE_V;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原来的物理内存引用计数减1</span></span><br><span class="line">    kfree((<span class="type">char</span>*)PGROUNDDOWN(pa));</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief krefcnt 获取内存的引用计数</span></span><br><span class="line"><span class="comment"> * @param pa 指定的内存地址</span></span><br><span class="line"><span class="comment"> * @return 引用计数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">krefcnt</span><span class="params">(<span class="type">void</span>* pa)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ref.cnt[(uint64)pa / PGSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief kaddrefcnt 增加内存的引用计数</span></span><br><span class="line"><span class="comment"> * @param pa 指定的内存地址</span></span><br><span class="line"><span class="comment"> * @return 0:成功 -1:失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kaddrefcnt</span><span class="params">(<span class="type">void</span>* pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;ref.lock);</span><br><span class="line">  ++ref.cnt[(uint64)pa / PGSIZE];</span><br><span class="line">  release(&amp;ref.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>freerange</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">    <span class="comment">// 在kfree中将会对cnt[]减1，这里要先设为1，否则就会减成负数</span></span><br><span class="line">    ref.cnt[(uint64)p / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3).</strong> 修改<code>uvmcopy</code>，不为子进程分配内存，而是使父子进程共享内存，但禁用<code>PTE_W</code>，同时标记<code>PTE_F</code>，记得调用<code>kaddrefcnt</code>增加引用计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅对可写页面设置COW标记</span></span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_W) &#123;</span><br><span class="line">      <span class="comment">// 禁用写并设置COW Fork标记</span></span><br><span class="line">      flags = (flags | PTE_F) &amp; ~PTE_W;</span><br><span class="line">      *pte = PA2PTE(pa) | flags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">      uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加内存的引用计数</span></span><br><span class="line">    kaddrefcnt((<span class="type">char</span>*)pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4).</strong> 修改<code>usertrap</code>，处理页面错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64 cause = r_scause();</span><br><span class="line"><span class="keyword">if</span>(cause == <span class="number">8</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(cause == <span class="number">13</span> || cause == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 fault_va = r_stval();  <span class="comment">// 获取出错的虚拟地址</span></span><br><span class="line">  <span class="keyword">if</span>(fault_va &gt;= p-&gt;sz</span><br><span class="line">    || cowpage(p-&gt;pagetable, fault_va) != <span class="number">0</span></span><br><span class="line">    || cowalloc(p-&gt;pagetable, PGROUNDDOWN(fault_va)) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(5).</strong> 在<code>copyout</code>中处理相同的情况，如果是COW页面，需要更换<code>pa0</code>指向的物理地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  va0 = PGROUNDDOWN(dstva);</span><br><span class="line">  pa0 = walkaddr(pagetable, va0);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理COW页面的情况</span></span><br><span class="line">  <span class="keyword">if</span>(cowpage(pagetable, va0) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 更换目标物理地址</span></span><br><span class="line">    pa0 = (uint64)cowalloc(pagetable, va0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaoq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nPTQNF98hlhFVhx3uT28h3EW-gzGzoHsz',
      appKey     : 'Hj5CW3nJJnJ3rBlGeKK8XQLa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
