<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="肖大强的个人博客">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="肖大强的个人博客">
<meta property="og:locale">
<meta property="article:author" content="xiaoq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>肖大强的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖大强的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/use_git/git1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/use_git/git1/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/use_git/git1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/use_git/git1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="将实验代码提交到github"><a href="#将实验代码提交到github" class="headerlink" title="将实验代码提交到github"></a>将实验代码提交到github</h1><blockquote>
<p>[!DANGER]<br>MIT 6.S081 这门课程每个lab对应一个git分支，所以请不要擅自将***.git***目录删除或更改origin指向的仓库地址</p>
</blockquote>
<p>(1).  <strong>首先将mit的实验代码克隆到本地</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br></pre></td></tr></table></figure>



<p>(2). <strong>在github创建一个新的空仓库</strong></p>
<p>创建完成后会有提示代码，请<strong>不要</strong>根据提示代码操作，并且记下右图中红色标注的仓库地址</p>
<p><img src="/images/p1.png" alt="img"><img src="/images/p2.png" alt="img"></p>
<p>(3). <strong>添加git仓库地址</strong></p>
<p>查看本地仓库的git配置文件，可以看到<em><strong>origin</strong></em>主机名下已经有了对应的上游仓库地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xv6-labs-2020/</span><br><span class="line"><span class="built_in">cat</span> .git/config</span><br></pre></td></tr></table></figure>

<p><img src="/images/p3.png" alt="img"></p>
<p>因此我们不要使用<em><strong>origin</strong></em>，可以使用其他主机名对应到github仓库，例如，我使用<em><strong>github</strong></em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add github 你的仓库地址</span><br><span class="line"><span class="built_in">cat</span> .git/config</span><br></pre></td></tr></table></figure>

<p><img src="/images/p4.png" alt="img"></p>
<p>(4). <strong><code>git push</code>命令</strong></p>
<ul>
<li><strong>功能</strong>：<code>git push</code>命令用于从将本地的分支版本上传到远程并合并。</li>
<li><strong>命令格式</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>

<p>如果本地分支名与远程分支名相同，则可以省略冒号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>更多用法请自行搜索</p>
<p>(5). <strong>将实验代码推送github仓库</strong></p>
<p>例如：将实验1用到的<em><strong>util</strong></em>分支推送到github</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout util</span><br><span class="line">git push github util:util</span><br></pre></td></tr></table></figure>

<p>需要你输入账户密码，提交就成功了</p>
<p>其他实验仓库的提交同理</p>
<p>(6). <strong>xv6实验git分支建议</strong></p>
<p>建议是每个实验创建一个测试分支，例如对于<em><strong>util</strong></em>来说</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout util         <span class="comment"># 切换到util分支</span></span><br><span class="line">git checkout -b util_test <span class="comment"># 建立并切换到util的测试分支</span></span><br></pre></td></tr></table></figure>

<p>当你在<em><strong>util_test</strong></em>分支中每测试通过一个作业，请提交（<code>git commit</code>）你的代码，并将所做的修改合并（<code>git merge</code>）到<em><strong>util</strong></em>中，然后提交（<code>git push</code>）到github</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;完成了第一个作业&quot;</span></span><br><span class="line">git checkout util</span><br><span class="line">git merge util_test</span><br><span class="line">git push github util:util</span><br></pre></td></tr></table></figure>



<p>(7). <strong>其他</strong></p>
<p>你还可以添加gitee，防止github有时无法访问的问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/summary/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/summary/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/summary/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h1><h2 id="实验难度"><a href="#实验难度" class="headerlink" title="实验难度"></a>实验难度</h2><p>每个实验都具有相应的难度</p>
<ul>
<li><p>Easy：不到一个小时。这些锻炼通常是为后续锻炼做的热身运动。</p>
</li>
<li><p>Moderate：1-2小时。</p>
</li>
<li><p>Hard：超过2个小时。这些练习通常不需要很多代码，但是代码很难正确。</p>
</li>
</ul>
<p>实验往往不需要很多行代码(几十到几百行) ，但是代码在概念上很复杂，而且细节往往很重要。所以，在你写任何代码之前，一定要完成实验室指定的阅读，通读相关文件，查阅文档(RISC-V手册等存放在了<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/reference.html">参考页面</a>上)。只有当你确定掌握了任务和解决方案，再开始编码。当你开始编写代码的时候，一小步一小步地实现你的解决方案(作业通常会建议如何将问题分解为更小的步骤)，并且在继续下一个步骤之前测试每个步骤是否正常工作。</p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>确保你理解了c和指针。Kernighan和Ritchie的《c程序设计语言》一书对C语言进行了简要的描述。这里有一些有用的指针练习。除非你已经完全掌握了C语言，不要跳过或略读上面的指针练习。如果你不能真正理解C语言中的指针，你将在实验室中遭受难以言喻的痛苦，然后最终以一种艰难的方式来理解它们。相信我们，你不会想知道什么是“艰难的路”的。</p>
<p>一些常见的习惯用法特别值得记住:</p>
<ul>
<li><p>如果<code>int *p = (int*)100</code>，那么<code>(int)p + 1</code>及<code>(int)(p + 1)</code>是不同的数字，第一个是101，但第二个是104。当向指针添加一个整数时，如第二种情况，整数被隐式地乘以指针指向的对象的大小。</p>
</li>
<li><p><code>p[i]</code>被定义为与<code>*(p+i)</code>相同，指向内存中p指向的第i个对象，当对象大于1字节时，上面所说的加法规则有利于此定义工作</p>
</li>
</ul>
<p>虽然大多数C程序不需要在指针和整数之间进行强制转换，但操作系统经常需要这样做。每当您看到一个包含内存地址的加法时，问问自己它是整数加法还是指针加法，并确保所添加的值是否适当地相乘。</p>
<ul>
<li><p>如果你有一个部分工作的练习，请通过提交代码来检查你的进度。如果您稍后破坏了某些东西，那么您可以回滚到您的检查点，然后以较小的步骤继续前进。要了解关于Git的更多信息，请查看<a target="_blank" rel="noopener" href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git用户手册</a>，或者您可能会发现这个<a target="_blank" rel="noopener" href="http://eagain.net/articles/git-for-computer-scientists/">面向计算机科学家的Git概述</a>非常有用。</p>
</li>
<li><p>如果您没有通过测试，确保您了解为什么您的代码没有通过测试。插入打印(printf)语句，直到您理解正在发生的事情。</p>
</li>
<li><p>您可能会发现您的print语句可能会产生许多您想要搜索的输出；其中一种方法是在<code>script</code>内部运行<code>make qemu</code>（在您的机器上运行<code>man script</code>），它将所有控制台输出记录到一个文件中，然后您可以搜索该文件。别忘了退出<code>script</code>。</p>
</li>
<li><p>在许多情况下，print语句就足够了，但有时能够单步遍历一些汇编代码或检查堆栈上的变量是有帮助的。要在xv6中使用gdb，请在一个窗口中运行<code>make qemu-gdb</code>，在另一个窗口中运行<code>gdb</code>（或<code>riscv64-linux-gnu-gdb</code>），设置断点，后跟“<code>c</code>”（continue），xv6将一直运行，直到到达断点。（有关有用的GDB提示，请参阅<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf">使用GNU调试器</a>。）</p>
</li>
<li><p>如果要查看编译器为内核生成的程序集是什么，或者要找出特定内核地址的指令是什么，请参阅文件<code>kernel.asm</code>，该文件在编译内核时由Makefile生成。（Makefile同时也为所有用户程序生成.asm文件。）</p>
</li>
<li><p>如果内核崩溃，它将打印一条错误消息，列出崩溃时程序计数器的值；您可以进行搜索<code>kernel.asm</code>找出程序计数器崩溃时在哪个函数中，或者可以运行<code>addr2line -e kernel/kernel pc-value</code>（有关详细信息，请运行<code>man addr2line</code>）。如果要获取回溯，请使用gdb重新启动：在一个窗口中运行’<code>make qemu-gdb</code>‘，在另一个窗口中运行gdb（或<code>riscv64-linux-gnu-gdb</code>），在<code>panic</code>中设置断点（“<code>b panic</code>”），后跟“<code>c</code>”（continue）。当内核到达断点时，键入“bt”以获取回溯跟踪。</p>
</li>
<li><p>如果您的内核挂起(例如，由于死锁)或无法进一步执行(例如，由于在执行内核指令时出现页面错误)，您可以使用gdb查找挂起的位置。在一个窗口中运行“ <code>make qemu-gdb</code>”，在另一个窗口中运行 <code>gdb</code> (<code>riscv64-linux-gnu-gdb</code>) ，后跟“<code>c</code>”(continue)。当内核出现挂起时，在 <code>qemu-gdb</code> 窗口中按 <code>Ctrl-C</code> 并键入“<code>bt</code>”以获得回溯跟踪。</p>
</li>
<li><p>qemu有一个“监视器”，允许您查询模拟机器的状态。您可以通过键入<code>&lt;Ctrl&gt;+a c</code>（c表示控制台）来获得它。一个特别有用的monitor命令<code>是info mem</code>，用于打印页表。您可能需要使用<code>cpu</code>命令来选择<code>info mem</code>查看哪一个核心，或者可以使用<code>make CPUS=1 qemu</code>启动qemu，以使其只有一个核心。</p>
</li>
</ul>
<p>花时间学习上述工具是非常值得的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab6/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab6-Copy-on-Write-Fork-for-xv6"><a href="#Lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab6: Copy-on-Write Fork for xv6"></a>Lab6: Copy-on-Write Fork for xv6</h1><p>虚拟内存提供了一定程度的间接寻址：内核可以通过将PTE标记为无效或只读来拦截内存引用，从而导致页面错误，还可以通过修改PTE来更改地址的含义。在计算机系统中有一种说法，任何系统问题都可以用某种程度的抽象方法来解决。Lazy allocation实验中提供了一个例子。这个实验探索了另一个例子：写时复制分支（copy-on write fork）。</p>
<p>在开始本实验前，将仓库切换到cow分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout cow</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>xv6中的<code>fork()</code>系统调用将父进程的所有用户空间内存复制到子进程中。如果父进程较大，则复制可能需要很长时间。更糟糕的是，这项工作经常造成大量浪费；例如，子进程中的<code>fork()</code>后跟<code>exec()</code>将导致子进程丢弃复制的内存，而其中的大部分可能都从未使用过。另一方面，如果父子进程都使用一个页面，并且其中一个或两个对该页面有写操作，则确实需要复制。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>copy-on-write (COW) fork()的目标是推迟到子进程实际需要物理内存拷贝时再进行分配和复制物理内存页面。</p>
<p>COW fork()只为子进程创建一个页表，用户内存的PTE指向父进程的物理页。COW fork()将父进程和子进程中的所有用户PTE标记为不可写。当任一进程试图写入其中一个COW页时，CPU将强制产生页面错误。内核页面错误处理程序检测到这种情况将为出错进程分配一页物理内存，将原始页复制到新页中，并修改出错进程中的相关PTE指向新的页面，将PTE标记为可写。当页面错误处理程序返回时，用户进程将能够写入其页面副本。</p>
<p>COW fork()将使得释放用户内存的物理页面变得更加棘手。给定的物理页可能会被多个进程的页表引用，并且只有在最后一个引用消失时才应该被释放。</p>
<h1 id="Implement-copy-on-write-hard"><a href="#Implement-copy-on-write-hard" class="headerlink" title="Implement copy-on write (hard)"></a>Implement copy-on write (hard)</h1><blockquote>
<p>[!TIP|label:YOUR JOB]<br>您的任务是在xv6内核中实现copy-on-write fork。如果修改后的内核同时成功执行<code>cowtest</code>和<code>usertests</code>程序就完成了。</p>
</blockquote>
<p>为了帮助测试你的实现方案，我们提供了一个名为<code>cowtest</code>的xv6程序（源代码位于<em><strong>user&#x2F;cowtest.c</strong></em>）。<code>cowtest</code>运行各种测试，但在未修改的xv6上，即使是第一个测试也会失败。因此，最初您将看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: fork() failed</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p>“simple”测试分配超过一半的可用物理内存，然后执行一系列的<code>fork()</code>。<code>fork</code>失败的原因是没有足够的可用物理内存来为子进程提供父进程内存的完整副本。</p>
<p>完成本实验后，内核应该通过<code>cowtest</code>和<code>usertests</code>中的所有测试。即：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: ok</span><br><span class="line">simple: ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">file: ok</span><br><span class="line">ALL COW TESTS PASSED</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p><strong>这是一个合理的攻克计划：</strong></p>
<ol>
<li>修改<code>uvmcopy()</code>将父进程的物理页映射到子进程，而不是分配新页。在子进程和父进程的PTE中清除<code>PTE_W</code>标志。</li>
<li>修改<code>usertrap()</code>以识别页面错误。当COW页面出现页面错误时，使用<code>kalloc()</code>分配一个新页面，并将旧页面复制到新页面，然后将新页面添加到PTE中并设置<code>PTE_W</code>。</li>
<li>确保每个物理页在最后一个PTE对它的引用撤销时被释放——而不是在此之前。这样做的一个好方法是为每个物理页保留引用该页面的用户页表数的“引用计数”。当<code>kalloc()</code>分配页时，将页的引用计数设置为1。当<code>fork</code>导致子进程共享页面时，增加页的引用计数；每当任何进程从其页表中删除页面时，减少页的引用计数。<code>kfree()</code>只应在引用计数为零时将页面放回空闲列表。可以将这些计数保存在一个固定大小的整型数组中。你必须制定一个如何索引数组以及如何选择数组大小的方案。例如，您可以用页的物理地址除以4096对数组进行索引，并为数组提供等同于<em><strong>kalloc.c</strong></em>中<code>kinit()</code>在空闲列表中放置的所有页面的最高物理地址的元素数。</li>
<li>修改<code>copyout()</code>在遇到COW页面时使用与页面错误相同的方案。</li>
</ol>
<p><strong>提示：</strong></p>
<ul>
<li>lazy page allocation实验可能已经让您熟悉了许多与copy-on-write相关的xv6内核代码。但是，您不应该将这个实验室建立在您的lazy allocation解决方案的基础上；相反，请按照上面的说明从一个新的xv6开始。</li>
<li>有一种可能很有用的方法来记录每个PTE是否是COW映射。您可以使用RISC-V PTE中的RSW（reserved for software，即为软件保留的）位来实现此目的。</li>
<li><code>usertests</code>检查<code>cowtest</code>不测试的场景，所以别忘两个测试都需要完全通过。</li>
<li><em><strong>kernel&#x2F;riscv.h</strong></em>的末尾有一些有用的宏和页表标志位的定义。</li>
<li>如果出现COW页面错误并且没有可用内存，则应终止进程。</li>
</ul>
<h1 id="可选的挑战练习"><a href="#可选的挑战练习" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h1><ul>
<li>修改xv6以同时支持lazy allocation和COW。</li>
<li>测量您的COW实现减少了多少xv6拷贝的字节数以及分配的物理页数。寻找并利用机会进一步减少这些数字。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab7/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab7-Multithreading"><a href="#Lab7-Multithreading" class="headerlink" title="Lab7: Multithreading"></a>Lab7: Multithreading</h1><p>本实验将使您熟悉多线程。您将在用户级线程包中实现线程之间的切换，使用多个线程来加速程序，并实现一个屏障。</p>
<blockquote>
<p>[!WARNING|label:Attention]<br>在编写代码之前，您应该确保已经阅读了xv6手册中的“第7章: 调度”，并研究了相应的代码。</p>
</blockquote>
<p>要启动实验，请切换到thread分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout thread</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<h1 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h1><p>在本练习中，您将为用户级线程系统设计上下文切换机制，然后实现它。为了让您开始，您的xv6有两个文件：<em><strong>user&#x2F;uthread.c</strong></em>和<em><strong>user&#x2F;uthread_switch.S</strong></em>，以及一个规则：运行在<em><strong>Makefile</strong></em>中以构建<code>uthread</code>程序。<em><strong>uthread.c</strong></em>包含大多数用户级线程包，以及三个简单测试线程的代码。线程包缺少一些用于创建线程和在线程之间切换的代码。</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>您的工作是提出一个创建线程和保存&#x2F;恢复寄存器以在线程之间切换的计划，并实现该计划。完成后，<code>make grade</code>应该表明您的解决方案通过了<code>uthread</code>测试。</p>
</blockquote>
<p>完成后，在xv6上运行<code>uthread</code>时应该会看到以下输出（三个线程可能以不同的顺序启动）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">$ uthread</span><br><span class="line">thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c 0</span><br><span class="line">thread_a 0</span><br><span class="line">thread_b 0</span><br><span class="line">thread_c 1</span><br><span class="line">thread_a 1</span><br><span class="line">thread_b 1</span><br><span class="line">...</span><br><span class="line">thread_c 99</span><br><span class="line">thread_a 99</span><br><span class="line">thread_b 99</span><br><span class="line">thread_c: <span class="built_in">exit</span> after 100</span><br><span class="line">thread_a: <span class="built_in">exit</span> after 100</span><br><span class="line">thread_b: <span class="built_in">exit</span> after 100</span><br><span class="line">thread_schedule: no runnable threads</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>该输出来自三个测试线程，每个线程都有一个循环，该循环打印一行，然后将CPU让出给其他线程。</p>
<p>然而在此时还没有上下文切换的代码，您将看不到任何输出。</p>
<p>您需要将代码添加到<em><strong>user&#x2F;uthread.c</strong></em>中的<code>thread_create()</code>和<code>thread_schedule()</code>，以及<em><strong>user&#x2F;uthread_switch.S</strong></em>中的<code>thread_switch</code>。一个目标是确保当<code>thread_schedule()</code>第一次运行给定线程时，该线程在自己的栈上执行传递给<code>thread_create()</code>的函数。另一个目标是确保<code>thread_switch</code>保存被切换线程的寄存器，恢复切换到线程的寄存器，并返回到后一个线程指令中最后停止的点。您必须决定保存&#x2F;恢复寄存器的位置；修改<code>struct thread</code>以保存寄存器是一个很好的计划。您需要在<code>thread_schedule</code>中添加对<code>thread_switch</code>的调用；您可以将需要的任何参数传递给<code>thread_switch</code>，但目的是将线程从<code>t</code>切换到<code>next_thread</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>thread_switch</code>只需要保存&#x2F;还原被调用方保存的寄存器（callee-save register，参见LEC5使用的文档《Calling Convention》）。为什么？</li>
<li>您可以在<em><strong>user&#x2F;uthread.asm</strong></em>中看到<code>uthread</code>的汇编代码，这对于调试可能很方便。</li>
<li>这可能对于测试你的代码很有用，使用<code>riscv64-linux-gnu-gdb</code>的单步调试通过你的<code>thread_switch</code>，你可以按这种方法开始：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file user/_uthread</span><br><span class="line">Reading symbols from user/_uthread...</span><br><span class="line">(gdb) b uthread.c:60</span><br></pre></td></tr></table></figure>

<p>这将在<em><strong>uthread.c</strong></em>的第60行设置断点。断点可能会（也可能不会）在运行<code>uthread</code>之前触发。为什么会出现这种情况？</p>
<p>一旦您的xv6 shell运行，键入“<code>uthread</code>”，gdb将在第60行停止。现在您可以键入如下命令来检查<code>uthread</code>的状态：</p>
<p><code>(gdb) p/x *next_thread</code></p>
<p>使用“<code>x</code>”，您可以检查内存位置的内容：</p>
<p><code>(gdb) x/x next_thread-&gt;stack</code></p>
<p>您可以跳到<code>thread_switch</code> 的开头，如下：</p>
<p><code>(gdb) b thread_switch</code></p>
<p><code>(gdb) c</code></p>
<p>您可以使用以下方法单步执行汇编指令：</p>
<p><code>(gdb) si</code></p>
<p>gdb的在线文档在<a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb/">这里</a>。</p>
<h1 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h1><p>在本作业中，您将探索使用哈希表的线程和锁的并行编程。您应该在具有多个内核的真实Linux或MacOS计算机（不是xv6，不是qemu）上执行此任务。最新的笔记本电脑都有多核处理器。</p>
<p>这个作业使用UNIX的pthread线程库。您可以使用<code>man pthreads</code>在手册页面上找到关于它的信息，您可以在web上查看，例如<a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_mutex_lock.html">这里</a>、<a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_mutex_init.html">这里</a>和<a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_create.html">这里</a>。</p>
<p>文件<em><strong>notxv6&#x2F;ph.c</strong></em>包含一个简单的哈希表，如果单个线程使用，该哈希表是正确的，但是多个线程使用时，该哈希表是不正确的。在您的xv6主目录（可能是<code>~/xv6-labs-2020</code>）中，键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make ph</span><br><span class="line">$ ./ph 1</span><br></pre></td></tr></table></figure>

<p>请注意，要构建<code>ph</code>，<em><strong>Makefile</strong></em>使用操作系统的gcc，而不是6.S081的工具。<code>ph</code>的参数指定在哈希表上执行<code>put</code>和<code>get</code>操作的线程数。运行一段时间后，<code>ph 1</code>将产生与以下类似的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100000 puts, 3.991 seconds, 25056 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 3.981 seconds, 25118 gets/second</span><br></pre></td></tr></table></figure>

<p>您看到的数字可能与此示例输出的数字相差两倍或更多，这取决于您计算机的速度、是否有多个核心以及是否正在忙于做其他事情。</p>
<p><code>ph</code>运行两个基准程序。首先，它通过调用<code>put()</code>将许多键添加到哈希表中，并以每秒为单位打印puts的接收速率。之后它使用<code>get()</code>从哈希表中获取键。它打印由于puts而应该在哈希表中但丢失的键的数量（在本例中为0），并以每秒为单位打印gets的接收数量。</p>
<p>通过给<code>ph</code>一个大于1的参数，可以告诉它同时从多个线程使用其哈希表。试试<code>ph 2</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./ph 2</span><br><span class="line">100000 puts, 1.885 seconds, 53044 puts/second</span><br><span class="line">1: 16579 keys missing</span><br><span class="line">0: 16579 keys missing</span><br><span class="line">200000 gets, 4.322 seconds, 46274 gets/second</span><br></pre></td></tr></table></figure>

<p>这个<code>ph 2</code>输出的第一行表明，当两个线程同时向哈希表添加条目时，它们达到每秒53044次插入的总速率。这大约是运行<code>ph 1</code>的单线程速度的两倍。这是一个优秀的“并行加速”，大约达到了人们希望的2倍（即两倍数量的核心每单位时间产出两倍的工作）。</p>
<p>然而，声明<code>16579 keys missing</code>的两行表示散列表中本应存在的大量键不存在。也就是说，puts应该将这些键添加到哈希表中，但出现了一些问题。请看一下<em><strong>notxv6&#x2F;ph.c</strong></em>，特别是<code>put()</code>和<code>insert()</code>。</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>为什么两个线程都丢失了键，而不是一个线程？确定可能导致键丢失的具有2个线程的事件序列。在<em><strong>answers-thread.txt</strong></em>中提交您的序列和简短解释。</p>
</blockquote>
<blockquote>
<p>[!TIP]<br>为了避免这种事件序列，请在<em><strong>notxv6&#x2F;ph.c</strong></em>中的<code>put</code>和<code>get</code>中插入<code>lock</code>和<code>unlock</code>语句，以便在两个线程中丢失的键数始终为0。相关的pthread调用包括：</p>
<ul>
<li><code>pthread_mutex_t lock;            // declare a lock</code></li>
<li><code>pthread_mutex_init(&amp;lock, NULL); // initialize the lock</code></li>
<li><code>pthread_mutex_lock(&amp;lock);       // acquire lock</code></li>
<li><code>pthread_mutex_unlock(&amp;lock);     // release lock</code></li>
</ul>
<p>当<code>make grade</code>说您的代码通过<code>ph_safe</code>测试时，您就完成了，该测试需要两个线程的键缺失数为0。在此时，<code>ph_fast</code>测试失败是正常的。</p>
</blockquote>
<p>不要忘记调用<code>pthread_mutex_init()</code>。首先用1个线程测试代码，然后用2个线程测试代码。您主要需要测试：程序运行是否正确呢（即，您是否消除了丢失的键？）？与单线程版本相比，双线程版本是否实现了并行加速（即单位时间内的工作量更多）？</p>
<p>在某些情况下，并发<code>put()</code>在哈希表中读取或写入的内存中没有重叠，因此不需要锁来相互保护。您能否更改<em><strong>ph.c</strong></em>以利用这种情况为某些<code>put()</code>获得并行加速？提示：每个散列桶加一个锁怎么样？</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>修改代码，使某些<code>put</code>操作在保持正确性的同时并行运行。当<code>make grade</code>说你的代码通过了<code>ph_safe</code>和<code>ph_fast</code>测试时，你就完成了。<code>ph_fast</code>测试要求两个线程每秒产生的<code>put</code>数至少是一个线程的1.25倍。</p>
</blockquote>
<h1 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier(moderate)"></a>Barrier(moderate)</h1><p>在本作业中，您将实现一个<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">屏障</a>（Barrier）：应用程序中的一个点，所有参与的线程在此点上必须等待，直到所有其他参与线程也达到该点。您将使用pthread条件变量，这是一种序列协调技术，类似于xv6的<code>sleep</code>和<code>wakeup</code>。</p>
<p>您应该在真正的计算机（不是xv6，不是qemu）上完成此任务。</p>
<p>文件<em><strong>notxv6&#x2F;barrier.c</strong></em>包含一个残缺的屏障实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make barrier</span><br><span class="line">$ ./barrier 2</span><br><span class="line">barrier: notxv6/barrier.c:42: thread: Assertion `i == t<span class="string">&#x27; failed.</span></span><br></pre></td></tr></table></figure>

<p>2指定在屏障上同步的线程数（<em><strong>barrier.c</strong></em>中的<code>nthread</code>）。每个线程执行一个循环。在每次循环迭代中，线程都会调用<code>barrier()</code>，然后以随机微秒数休眠。如果一个线程在另一个线程到达屏障之前离开屏障将触发断言（assert）。期望的行为是每个线程在<code>barrier()</code>中阻塞，直到<code>nthreads</code>的所有线程都调用了<code>barrier()</code>。</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>您的目标是实现期望的屏障行为。除了在<code>ph</code>作业中看到的lock原语外，还需要以下新的pthread原语；详情请看<a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html">这里</a>和<a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_broadcast.html">这里</a>。</p>
<ul>
<li><code>// 在cond上进入睡眠，释放锁mutex，在醒来时重新获取</code></li>
<li><code>pthread_cond_wait(&amp;cond, &amp;mutex);</code></li>
<li><code>// 唤醒睡在cond的所有线程</code></li>
<li><code>pthread_cond_broadcast(&amp;cond);</code></li>
</ul>
</blockquote>
<p>确保您的方案通过<code>make grade</code>的<code>barrier</code>测试。</p>
<p><code>pthread_cond_wait</code>在调用时释放<code>mutex</code>，并在返回前重新获取<code>mutex</code>。</p>
<p>我们已经为您提供了<code>barrier_init()</code>。您的工作是实现<code>barrier()</code>，这样panic就不会发生。我们为您定义了<code>struct barrier</code>；它的字段供您使用。</p>
<p><strong>有两个问题使您的任务变得复杂：</strong></p>
<ul>
<li>你必须处理一系列的<code>barrier</code>调用，我们称每一连串的调用为一轮（round）。<code>bstate.round</code>记录当前轮数。每次当所有线程都到达屏障时，都应增加<code>bstate.round</code>。</li>
<li>您必须处理这样的情况：一个线程在其他线程退出<code>barrier</code>之前进入了下一轮循环。特别是，您在前后两轮中重复使用<code>bstate.nthread</code>变量。确保在前一轮仍在使用<code>bstate.nthread</code>时，离开<code>barrier</code>并循环运行的线程不会增加<code>bstate.nthread</code>。</li>
</ul>
<p>使用一个、两个和两个以上的线程测试代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab9/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab9-file-system"><a href="#Lab9-file-system" class="headerlink" title="Lab9: file system"></a>Lab9: file system</h1><p>在本实验室中，您将向xv6文件系统添加大型文件和符号链接。</p>
<blockquote>
<p>[!WARNING|label:Attention]<br>在编写代码之前，您应该阅读《xv6手册》中的《第八章：文件系统》，并学习相应的代码。</p>
</blockquote>
<p>获取实验室的xv6源代码并切换到fs分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout fs</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<h1 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files(moderate)"></a>Large files(moderate)</h1><p>在本作业中，您将增加xv6文件的最大大小。目前，xv6文件限制为268个块或<code>268*BSIZE</code>字节（在xv6中<code>BSIZE</code>为1024）。此限制来自以下事实：一个xv6 inode包含12个“直接”块号和一个“间接”块号，“一级间接”块指一个最多可容纳256个块号的块，总共12+256&#x3D;268个块。</p>
<p><code>bigfile</code>命令可以创建最长的文件，并报告其大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bigfile</span><br><span class="line">..</span><br><span class="line">wrote 268 blocks</span><br><span class="line">bigfile: file is too small</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>测试失败，因为<code>bigfile</code>希望能够创建一个包含65803个块的文件，但未修改的xv6将文件限制为268个块。</p>
<p>您将更改xv6文件系统代码，以支持每个inode中可包含256个一级间接块地址的“二级间接”块，每个一级间接块最多可以包含256个数据块地址。结果将是一个文件将能够包含多达65803个块，或256*256+256+11个块（11而不是12，因为我们将为二级间接块牺牲一个直接块号）。</p>
<h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p><code>mkfs</code>程序创建xv6文件系统磁盘映像，并确定文件系统的总块数；此大小由<em><strong>kernel&#x2F;param.h</strong></em>中的<code>FSSIZE</code>控制。您将看到，该实验室存储库中的<code>FSSIZE</code>设置为200000个块。您应该在<code>make</code>输出中看到来自<code>mkfs/mkfs</code>的以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmeta 70 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000</span><br></pre></td></tr></table></figure>

<p>这一行描述了<code>mkfs/mkfs</code>构建的文件系统：它有70个元数据块（用于描述文件系统的块）和199930个数据块，总计200000个块。</p>
<p>如果在实验期间的任何时候，您发现自己必须从头开始重建文件系统，您可以运行<code>make clean</code>，强制<code>make</code>重建<em><strong>fs.img</strong></em>。</p>
<h2 id="看什么"><a href="#看什么" class="headerlink" title="看什么"></a>看什么</h2><p>磁盘索引节点的格式由<em><strong>fs.h</strong></em>中的<code>struct dinode</code>定义。您应当尤其对<code>NDIRECT</code>、<code>NINDIRECT</code>、<code>MAXFILE</code>和<code>struct dinode</code>的<code>addrs[]</code>元素感兴趣。查看《XV6手册》中的图8.3，了解标准xv6索引结点的示意图。</p>
<p>在磁盘上查找文件数据的代码位于<em><strong>fs.c</strong></em>的<code>bmap()</code>中。看看它，确保你明白它在做什么。在读取和写入文件时都会调用<code>bmap()</code>。写入时，<code>bmap()</code>会根据需要分配新块以保存文件内容，如果需要，还会分配间接块以保存块地址。</p>
<p><code>bmap()</code>处理两种类型的块编号。<code>bn</code>参数是一个“逻辑块号”——文件中相对于文件开头的块号。<code>ip-&gt;addrs[]</code>中的块号和<code>bread()</code>的参数都是磁盘块号。您可以将<code>bmap()</code>视为将文件的逻辑块号映射到磁盘块号。</p>
<h2 id="你的工作"><a href="#你的工作" class="headerlink" title="你的工作"></a>你的工作</h2><p>修改<code>bmap()</code>，以便除了直接块和一级间接块之外，它还实现二级间接块。你只需要有11个直接块，而不是12个，为你的新的二级间接块腾出空间；不允许更改磁盘inode的大小。<code>ip-&gt;addrs[]</code>的前11个元素应该是直接块；第12个应该是一个一级间接块（与当前的一样）；13号应该是你的新二级间接块。当<code>bigfile</code>写入65803个块并成功运行<code>usertests</code>时，此练习完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bigfile</span><br><span class="line">..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</span><br><span class="line">wrote 65803 blocks</span><br><span class="line">done; ok</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p>运行<code>bigfile</code>至少需要一分钟半的时间。</p>
<p><strong>提示：</strong></p>
<ul>
<li>确保您理解<code>bmap()</code>。写出<code>ip-&gt;addrs[]</code>、间接块、二级间接块和它所指向的一级间接块以及数据块之间的关系图。确保您理解为什么添加二级间接块会将最大文件大小增加256*256个块（实际上要-1，因为您必须将直接块的数量减少一个）。</li>
<li>考虑如何使用逻辑块号索引二级间接块及其指向的间接块。</li>
<li>如果更改<code>NDIRECT</code>的定义，则可能必须更改<em><strong>file.h</strong></em>文件中<code>struct inode</code>中<code>addrs[]</code>的声明。确保<code>struct inode</code>和<code>struct dinode</code>在其<code>addrs[]</code>数组中具有相同数量的元素。</li>
<li>如果更改<code>NDIRECT</code>的定义，请确保创建一个新的<em><strong>fs.img</strong></em>，因为<code>mkfs</code>使用<code>NDIRECT</code>构建文件系统。</li>
<li>如果您的文件系统进入坏状态，可能是由于崩溃，请删除<em><strong>fs.img</strong></em>（从Unix而不是xv6执行此操作）。<code>make</code>将为您构建一个新的干净文件系统映像。</li>
<li>别忘了把你<code>bread()</code>的每一个块都<code>brelse()</code>。</li>
<li>您应该仅根据需要分配间接块和二级间接块，就像原始的<code>bmap()</code>。</li>
<li>确保<code>itrunc</code>释放文件的所有块，包括二级间接块。</li>
</ul>
<h1 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links(moderate)"></a>Symbolic links(moderate)</h1><p>在本练习中，您将向xv6添加符号链接。符号链接（或软链接）是指按路径名链接的文件；当一个符号链接打开时，内核跟随该链接指向引用的文件。符号链接类似于硬链接，但硬链接仅限于指向同一磁盘上的文件，而符号链接可以跨磁盘设备。尽管xv6不支持多个设备，但实现此系统调用是了解路径名查找工作原理的一个很好的练习。</p>
<h2 id="你的工作-1"><a href="#你的工作-1" class="headerlink" title="你的工作"></a>你的工作</h2><blockquote>
<p>[!TIP|label:YOUR JOB]<br>您将实现<code>symlink(char *target, char *path)</code>系统调用，该调用在引用由<code>target</code>命名的文件的路径处创建一个新的符号链接。有关更多信息，请参阅<code>symlink</code>手册页（注：执行<code>man symlink</code>）。要进行测试，请将<code>symlinktest</code>添加到<em><strong>Makefile</strong></em>并运行它。当测试产生以下输出（包括<code>usertests</code>运行成功）时，您就完成本作业了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ symlinktest</span><br><span class="line">Start: <span class="built_in">test</span> symlinks</span><br><span class="line"><span class="built_in">test</span> symlinks: ok</span><br><span class="line">Start: <span class="built_in">test</span> concurrent symlinks</span><br><span class="line"><span class="built_in">test</span> concurrent symlinks: ok</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>首先，为<code>symlink</code>创建一个新的系统调用号，在<em><strong>user&#x2F;usys.pl</strong></em>、<em><strong>user&#x2F;user.h</strong></em>中添加一个条目，并在<em><strong>kernel&#x2F;sysfile.c</strong></em>中实现一个空的<code>sys_symlink</code>。</li>
<li>向<em><strong>kernel&#x2F;stat.h</strong></em>添加新的文件类型（<code>T_SYMLINK</code>）以表示符号链接。</li>
<li>在k<em><strong>ernel&#x2F;fcntl.h</strong></em>中添加一个新标志（<code>O_NOFOLLOW</code>），该标志可用于<code>open</code>系统调用。请注意，传递给<code>open</code>的标志使用按位或运算符组合，因此新标志不应与任何现有标志重叠。一旦将<em><strong>user&#x2F;symlinktest.c</strong></em>添加到<em><strong>Makefile</strong></em>中，您就可以编译它。</li>
<li>实现<code>symlink(target, path)</code>系统调用，以在<code>path</code>处创建一个新的指向<code>target</code>的符号链接。请注意，系统调用的成功不需要<code>target</code>已经存在。您需要选择存储符号链接目标路径的位置，例如在inode的数据块中。<code>symlink</code>应返回一个表示成功（0）或失败（-1）的整数，类似于<code>link</code>和<code>unlink</code>。</li>
<li>修改<code>open</code>系统调用以处理路径指向符号链接的情况。如果文件不存在，则打开必须失败。当进程向<code>open</code>传递<code>O_NOFOLLOW</code>标志时，<code>open</code>应打开符号链接（而不是跟随符号链接）。</li>
<li>如果链接文件也是符号链接，则必须递归地跟随它，直到到达非链接文件为止。如果链接形成循环，则必须返回错误代码。你可以通过以下方式估算存在循环：通过在链接深度达到某个阈值（例如10）时返回错误代码。</li>
<li>其他系统调用（如<code>link</code>和<code>unlink</code>）不得跟随符号链接；这些系统调用对符号链接本身进行操作。</li>
<li>您不必处理指向此实验的目录的符号链接。</li>
</ul>
<h1 id="可选的挑战练习"><a href="#可选的挑战练习" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h1><p>实现三级间接块</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab11/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab11/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab11-Network"><a href="#Lab11-Network" class="headerlink" title="Lab11: Network"></a>Lab11: Network</h1><p>在本实验室中，您将为网络接口卡（NIC）编写一个xv6设备驱动程序。</p>
<p>获取xv6实验的源代码并切换到<code>net</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout net</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>[!TIP]<br>在编写代码之前，您可能会发现阅读xv6手册中的《第5章：中断和设备驱动》很有帮助。</p>
</blockquote>
<p>您将使用名为E1000的网络设备来处理网络通信。对于xv6（以及您编写的驱动程序），E1000看起来像是连接到真正以太网局域网（LAN）的真正硬件。事实上，用于与您的驱动程序对话的E1000是qemu提供的模拟，连接到的LAN也由qemu模拟。在这个模拟LAN上，xv6（“来宾”）的IP地址为10.0.2.15。Qemu还安排运行Qemu的计算机出现在IP地址为10.0.2.2的LAN上。当xv6使用E1000将数据包发送到10.0.2.2时，qemu会将数据包发送到运行qemu的（真实）计算机上的相应应用程序（“主机”）。</p>
<p>您将使用QEMU的“用户模式网络栈（user-mode network stack）”。<a target="_blank" rel="noopener" href="https://www.qemu.org/docs/master/system/net.html#using-the-user-mode-network-stack">QEMU的文档</a>中有更多关于用户模式栈的内容。我们已经更新了<em><strong>Makefile</strong></em>以启用QEMU的用户模式网络栈和E1000网卡。</p>
<p><em><strong>Makefile</strong></em>将QEMU配置为将所有传入和传出数据包记录到实验目录中的<em><strong>packets.pcap</strong></em>文件中。查看这些记录可能有助于确认xv6正在发送和接收您期望的数据包。要显示记录的数据包，请执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr packets.pcap</span><br></pre></td></tr></table></figure>

<p>我们已将一些文件添加到本实验的xv6存储库中。<em><strong>kernel&#x2F;e1000.c</strong></em>文件包含E1000的初始化代码以及用于发送和接收数据包的空函数，您将填写这些函数。<em><strong>kernel&#x2F;e1000_dev.h</strong></em>包含E1000定义的寄存器和标志位的定义，并在<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">《英特尔E1000软件开发人员手册》</a>中进行了描述。<em><strong>kernel&#x2F;net.c</strong></em>和<em><strong>kernel&#x2F;net.h</strong></em>包含一个实现IP、UDP和ARP协议的简单网络栈。这些文件还包含用于保存数据包的灵活数据结构（称为<code>mbuf</code>）的代码。最后，<em><strong>kernel&#x2F;pci.c</strong></em>包含在xv6引导时在PCI总线上搜索E1000卡的代码。</p>
<h1 id="你的工作-hard"><a href="#你的工作-hard" class="headerlink" title="你的工作(hard)"></a>你的工作(hard)</h1><blockquote>
<p>[!TIP|label:YOUR JOB]<br>您的工作是在<em><strong>kernel&#x2F;e1000.c</strong></em>中完成<code>e1000_transmit()</code>和<code>e1000_recv()</code>，以便驱动程序可以发送和接收数据包。当<code>make grade</code>表示您的解决方案通过了所有测试时，您就完成了。</p>
</blockquote>
<blockquote>
<p>[!TIP]<br>在编写代码时，您会发现自己参考了<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">《E1000软件开发人员手册》</a>。以下部分可能特别有用：</p>
<ul>
<li>Section 2是必不可少的，它概述了整个设备。</li>
<li>Section 3.2概述了数据包接收。</li>
<li>Section 3.3与Section 3.4一起概述了数据包传输。</li>
<li>Section 13概述了E1000使用的寄存器。</li>
<li>Section 14可能会帮助您理解我们提供的init代码。</li>
</ul>
</blockquote>
<p>浏览<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">《E1000软件开发人员手册》</a>。本手册涵盖了几个密切相关的以太网控制器。QEMU模拟82540EM。现在浏览第2章，了解该设备。要编写驱动程序，您需要熟悉第3章和第14章以及第4.1节（虽然不包括4.1的子节）。你还需要参考第13章。其他章节主要介绍你的驱动程序不必与之交互的E1000组件。一开始不要担心细节；只需了解文档的结构，就可以在以后找到内容。E1000具有许多高级功能，其中大部分您可以忽略。完成这个实验只需要一小部分基本功能。</p>
<p>我们在<em><strong>e1000.c</strong></em>中提供的<code>e1000_init()</code>函数将E1000配置为读取要从RAM传输的数据包，并将接收到的数据包写入RAM。这种技术称为DMA，用于直接内存访问，指的是E1000硬件直接向RAM写入和读取数据包。</p>
<p>由于数据包突发到达的速度可能快于驱动程序处理数据包的速度，因此<code>e1000_init()</code>为E1000提供了多个缓冲区，E1000可以将数据包写入其中。E1000要求这些缓冲区由RAM中的“描述符”数组描述；每个描述符在RAM中都包含一个地址，E1000可以在其中写入接收到的数据包。<code>struct rx_desc</code>描述描述符格式。描述符数组称为接收环或接收队列。它是一个圆环，在这个意义上，当网卡或驱动程序到达队列的末尾时，它会绕回到数组的开头。<code>e1000_init()</code>使用<code>mbufalloc()</code>为要进行DMA的E1000分配<code>mbuf</code>数据包缓冲区。此外还有一个传输环，驱动程序将需要E1000发送的数据包放入其中。<code>e1000_init()</code>将两个环的大小配置为<code>RX_RING_SIZE</code>和<code>TX_RING_SIZE</code>。</p>
<p>当<em><strong>net.c</strong></em>中的网络栈需要发送数据包时，它会调用<code>e1000_transmit()</code>，并使用一个保存要发送的数据包的<code>mbuf</code>作为参数。传输代码必须在TX（传输）环的描述符中放置指向数据包数据的指针。<code>struct tx_desc</code>描述了描述符的格式。您需要确保每个<code>mbuf</code>最终被释放，但只能在E1000完成数据包传输之后（E1000在描述符中设置<code>E1000_TXD_STAT_DD</code>位以指示此情况）。</p>
<p>当当E1000从以太网接收到每个包时，它首先将包DMA到下一个RX(接收)环描述符指向的<code>mbuf</code>，然后产生一个中断。<code>e1000_recv()</code>代码必须扫描RX环，并通过调用<code>net_rx()</code>将每个新数据包的<code>mbuf</code>发送到网络栈（在<em><strong>net.c</strong></em>中）。然后，您需要分配一个新的<code>mbuf</code>并将其放入描述符中，以便当E1000再次到达RX环中的该点时，它会找到一个新的缓冲区，以便DMA新数据包。</p>
<p>除了在RAM中读取和写入描述符环外，您的驱动程序还需要通过其内存映射控制寄存器与E1000交互，以检测接收到数据包何时可用，并通知E1000驱动程序已经用要发送的数据包填充了一些TX描述符。全局变量<code>regs</code>包含指向E1000第一个控制寄存器的指针；您的驱动程序可以通过将<code>regs</code>索引为数组来获取其他寄存器。您需要特别使用索引<code>E1000_RDT</code>和<code>E1000_TDT</code>。</p>
<p>要测试驱动程序，请在一个窗口中运行<code>make server</code>，在另一个窗口中运行<code>make qemu</code>，然后在xv6中运行<code>nettests</code>。<code>nettests</code>中的第一个测试尝试将UDP数据包发送到主机操作系统，地址是<code>make server</code>运行的程序。如果您还没有完成实验，E1000驱动程序实际上不会发送数据包，也不会发生什么事情。</p>
<p>完成实验后，E1000驱动程序将发送数据包，qemu将其发送到主机，<code>make server</code>将看到它并发送响应数据包，然后E1000驱动程序和<code>nettests</code>将看到响应数据包。但是，在主机发送应答之前，它会向xv6发送一个“ARP”请求包，以找出其48位以太网地址，并期望xv6以ARP应答进行响应。一旦您完成了对E1000驱动程序的工作，<em><strong>kernel&#x2F;net.c</strong></em>就会处理这个问题。如果一切顺利，<code>nettests</code>将打印<code>testing ping: OK</code>，<code>make server</code>将打印<code>a message from xv6!</code>。</p>
<p><code>tcpdump -XXnr packets.pcap</code>应该生成这样的输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reading from file packets.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">15:27:40.861988 IP 10.0.2.15.2000 &gt; 10.0.2.2.25603: UDP, length 19</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.</span><br><span class="line">        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.&gt;.......</span><br><span class="line">        0x0020:  0202 07d0 6403 001b 0000 6120 6d65 7373  ....d.....a.mess</span><br><span class="line">        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!</span><br><span class="line">15:27:40.862370 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........</span><br><span class="line">        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........</span><br><span class="line">        0x0020:  0000 0000 0000 0a00 020f                 ..........</span><br><span class="line">15:27:40.862844 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....</span><br><span class="line">        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....</span><br><span class="line">        0x0020:  5255 0a00 0202 0a00 0202                 RU........</span><br><span class="line">15:27:40.863036 IP 10.0.2.2.25603 &gt; 10.0.2.15.2000: UDP, length 17</span><br><span class="line">        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.</span><br><span class="line">        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......</span><br><span class="line">        0x0020:  020f 6403 07d0 0019 3406 7468 6973 2069  ..d.....4.this.i</span><br><span class="line">        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!</span><br></pre></td></tr></table></figure>

<p>您的输出看起来会有些不同，但它应该包含字符串“ARP, Request”，“ARP, Reply”，“UDP”，“a.message.from.xv6”和“this.is.the.host”。</p>
<p><code>nettests</code>执行一些其他测试，最终通过（真实的）互联网将DNS请求发送到谷歌的一个名称服务器。您应该确保您的代码通过所有这些测试，然后您应该看到以下输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nettests</span><br><span class="line">nettests running on port 25603</span><br><span class="line">testing ping: OK</span><br><span class="line">testing single-process pings: OK</span><br><span class="line">testing multi-process pings: OK</span><br><span class="line">testing DNS</span><br><span class="line">DNS arecord <span class="keyword">for</span> pdos.csail.mit.edu. is 128.52.129.126</span><br><span class="line">DNS OK</span><br><span class="line">all tests passed.</span><br></pre></td></tr></table></figure>

<p>您应该确保<code>make grade</code>同意您的解决方案通过。</p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>首先，将打印语句添加到<code>e1000_transmit()</code>和<code>e1000_recv()</code>，然后运行<code>make server</code>和（在xv6中）<code>nettests</code>。您应该从打印语句中看到，<code>nettests</code>生成对<code>e1000_transmit</code>的调用。</p>
<p><strong>实现<code>e1000_transmit</code>的一些提示：</strong></p>
<ul>
<li>首先，通过读取<code>E1000_TDT</code>控制寄存器，向E1000询问等待下一个数据包的TX环索引。</li>
<li>然后检查环是否溢出。如果<code>E1000_TXD_STAT_DD</code>未在<code>E1000_TDT</code>索引的描述符中设置，则E1000尚未完成先前相应的传输请求，因此返回错误。</li>
<li>否则，使用<code>mbuffree()</code>释放从该描述符传输的最后一个<code>mbuf</code>（如果有）。</li>
<li>然后填写描述符。<code>m-&gt;head</code>指向内存中数据包的内容，<code>m-&gt;len</code>是数据包的长度。设置必要的cmd标志（请参阅E1000手册的第3.3节），并保存指向<code>mbuf</code>的指针，以便稍后释放。</li>
<li>最后，通过将一加到<code>E1000_TDT再对TX_RING_SIZE</code>取模来更新环位置。</li>
<li>如果<code>e1000_transmit()</code>成功地将<code>mbuf</code>添加到环中，则返回0。如果失败（例如，没有可用的描述符来传输<code>mbuf</code>），则返回-1，以便调用方知道应该释放<code>mbuf</code>。</li>
</ul>
<p><strong>实现<code>e1000_recv</code>的一些提示：</strong></p>
<ul>
<li>首先通过提取<code>E1000_RDT</code>控制寄存器并加一对<code>RX_RING_SIZE</code>取模，向E1000询问下一个等待接收数据包（如果有）所在的环索引。</li>
<li>然后通过检查描述符<code>status</code>部分中的<code>E1000_RXD_STAT_DD</code>位来检查新数据包是否可用。如果不可用，请停止。</li>
<li>否则，将<code>mbuf</code>的<code>m-&gt;len</code>更新为描述符中报告的长度。使用<code>net_rx()</code>将<code>mbuf</code>传送到网络栈。</li>
<li>然后使用<code>mbufalloc()</code>分配一个新的<code>mbuf</code>，以替换刚刚给<code>net_rx()</code>的<code>mbuf</code>。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清除为零。</li>
<li>最后，将<code>E1000_RDT</code>寄存器更新为最后处理的环描述符的索引。</li>
<li><code>e1000_init()</code>使用mbufs初始化RX环，您需要通过浏览代码来了解它是如何做到这一点的。</li>
<li>在某刻，曾经到达的数据包总数将超过环大小（16）；确保你的代码可以处理这个问题。</li>
</ul>
<p>您将需要锁来应对xv6可能从多个进程使用E1000，或者在中断到达时在内核线程中使用E1000的可能性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab3/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab3-page-tables"><a href="#Lab3-page-tables" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h1><p>在本实验室中，您将探索页表并对其进行修改，以简化将数据从用户空间复制到内核空间的函数。</p>
<blockquote>
<p>[!WARNING|label:Attention]<br>开始编码之前，请阅读xv6手册的第3章和相关文件：</p>
<ul>
<li><em><strong>kernel&#x2F;memlayout.h</strong></em>，它捕获了内存的布局。</li>
<li><em><strong>kernel&#x2F;vm.c</strong></em>，其中包含大多数虚拟内存（VM）代码。</li>
<li><em><strong>kernel&#x2F;kalloc.c</strong></em>，它包含分配和释放物理内存的代码。</li>
</ul>
</blockquote>
<p>要启动实验，请切换到pgtbl分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout pgtbl</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<h1 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h1><p>为了帮助您了解RISC-V页表，也许为了帮助将来的调试，您的第一个任务是编写一个打印页表内容的函数。</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>定义一个名为<code>vmprint()</code>的函数。它应当接收一个<code>pagetable_t</code>作为参数，并以下面描述的格式打印该页表。在<code>exec.c</code>中的<code>return argc</code>之前插入<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，以打印第一个进程的页表。如果你通过了<code>pte printout</code>测试的<code>make grade</code>，你将获得此作业的满分。</p>
</blockquote>
<p>现在，当您启动xv6时，它应该像这样打印输出来描述第一个进程刚刚完成<code>exec()</code>ing<code>init</code>时的页表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>

<p>第一行显示<code>vmprint</code>的参数。之后的每行对应一个PTE，包含树中指向页表页的PTE。每个PTE行都有一些“<code>..</code>”的缩进表明它在树中的深度。每个PTE行显示其在页表页中的PTE索引、PTE比特位以及从PTE提取的物理地址。不要打印无效的PTE。在上面的示例中，顶级页表页具有条目0和255的映射。条目0的下一级只映射了索引0，该索引0的下一级映射了条目0、1和2。</p>
<p>您的代码可能会发出与上面显示的不同的物理地址。条目数和虚拟地址应相同。</p>
<p><strong>一些提示：</strong></p>
<ul>
<li>你可以将<code>vmprint()</code>放在<em><strong>kernel&#x2F;vm.c</strong></em>中</li>
<li>使用定义在<em><strong>kernel&#x2F;riscv.h</strong></em>末尾处的宏</li>
<li>函数<code>freewalk</code>可能会对你有所启发</li>
<li>将<code>vmprint</code>的原型定义在<em><strong>kernel&#x2F;defs.h</strong></em>中，这样你就可以在<code>exec.c</code>中调用它了</li>
<li>在你的<code>printf</code>调用中使用<code>%p</code>来打印像上面示例中的完成的64比特的十六进制PTE和地址</li>
</ul>
<blockquote>
<p>[!NOTE|label:QUESTION]<br>根据文本中的图3-4解释<code>vmprint</code>的输出。page 0包含什么？page 2中是什么？在用户模式下运行时，进程是否可以读取&#x2F;写入page 1映射的内存？</p>
</blockquote>
<h1 id="A-kernel-page-table-per-process-hard"><a href="#A-kernel-page-table-per-process-hard" class="headerlink" title="A kernel page table per process (hard)"></a>A kernel page table per process (hard)</h1><p>Xv6有一个单独的用于在内核中执行程序时的内核页表。内核页表直接映射（恒等映射）到物理地址，也就是说内核虚拟地址<code>x</code>映射到物理地址仍然是<code>x</code>。Xv6还为每个进程的用户地址空间提供了一个单独的页表，只包含该进程用户内存的映射，从虚拟地址0开始。因为内核页表不包含这些映射，所以用户地址在内核中无效。因此，当内核需要使用在系统调用中传递的用户指针（例如，传递给<code>write()</code>的缓冲区指针）时，内核必须首先将指针转换为物理地址。本节和下一节的目标是允许内核直接解引用用户指针。</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>你的第一项工作是修改内核来让每一个进程在内核中执行时使用它自己的内核页表的副本。修改<code>struct proc</code>来为每一个进程维护一个内核页表，修改调度程序使得切换进程时也切换内核页表。对于这个步骤，每个进程的内核页表都应当与现有的的全局内核页表完全一致。如果你的<code>usertests</code>程序正确运行了，那么你就通过了这个实验。</p>
</blockquote>
<p>阅读本作业开头提到的章节和代码；了解虚拟内存代码的工作原理后，正确修改虚拟内存代码将更容易。页表设置中的错误可能会由于缺少映射而导致陷阱，可能会导致加载和存储影响到意料之外的物理页存页面，并且可能会导致执行来自错误内存页的指令。</p>
<p><strong>提示：</strong></p>
<ul>
<li>在<code>struct proc</code>中为进程的内核页表增加一个字段</li>
<li>为一个新进程生成一个内核页表的合理方案是实现一个修改版的<code>kvminit</code>，这个版本中应当创造一个新的页表而不是修改<code>kernel_pagetable</code>。你将会考虑在<code>allocproc</code>中调用这个函数</li>
<li>确保每一个进程的内核页表都关于该进程的内核栈有一个映射。在未修改的XV6中，所有的内核栈都在<code>procinit</code>中设置。你将要把这个功能部分或全部的迁移到<code>allocproc</code>中</li>
<li>修改<code>scheduler()</code>来加载进程的内核页表到核心的<code>satp</code>寄存器(参阅<code>kvminithart</code>来获取启发)。不要忘记在调用完<code>w_satp()</code>后调用<code>sfence_vma()</code></li>
<li>没有进程运行时<code>scheduler()</code>应当使用<code>kernel_pagetable</code></li>
<li>在<code>freeproc</code>中释放一个进程的内核页表</li>
<li>你需要一种方法来释放页表，而不必释放叶子物理内存页面。</li>
<li>调式页表时，也许<code>vmprint</code>能派上用场</li>
<li>修改XV6本来的函数或新增函数都是允许的；你或许至少需要在<em><strong>kernel&#x2F;vm.c</strong></em>和<em><strong>kernel&#x2F;proc.c</strong></em>中这样做（但不要修改<em><strong>kernel&#x2F;vmcopyin.c</strong></em>, <em><strong>kernel&#x2F;stats.c</strong></em>, <em><strong>user&#x2F;usertests.c</strong></em>, 和<em><strong>user&#x2F;stats.c</strong></em>）</li>
<li>页表映射丢失很可能导致内核遭遇页面错误。这将导致打印一段包含<code>sepc=0x00000000XXXXXXXX</code>的错误提示。你可以在<em><strong>kernel&#x2F;kernel.asm</strong></em>通过查询<code>XXXXXXXX</code>来定位错误。</li>
</ul>
<h1 id="Simplify-copyin-x2F-copyinstr（hard）"><a href="#Simplify-copyin-x2F-copyinstr（hard）" class="headerlink" title="Simplify copyin&#x2F;copyinstr（hard）"></a>Simplify <code>copyin</code>&#x2F;<code>copyinstr</code>（hard）</h1><p>内核的<code>copyin</code>函数读取用户指针指向的内存。它通过将用户指针转换为内核可以直接解引用的物理地址来实现这一点。这个转换是通过在软件中遍历进程页表来执行的。在本部分的实验中，您的工作是将用户空间的映射添加到每个进程的内核页表（上一节中创建），以允许<code>copyin</code>（和相关的字符串函数<code>copyinstr</code>）直接解引用用户指针。</p>
<blockquote>
<p>[!TIP|label:YOUR JOB]<br>将定义在<em><strong>kernel&#x2F;vm.c</strong></em>中的<code>copyin</code>的主题内容替换为对<code>copyin_new</code>的调用（在<em><strong>kernel&#x2F;vmcopyin.c</strong></em>中定义）；对<code>copyinstr</code>和<code>copyinstr_new</code>执行相同的操作。为每个进程的内核页表添加用户地址映射，以便<code>copyin_new</code>和<code>copyinstr_new</code>工作。如果<code>usertests</code>正确运行并且所有<code>make grade</code>测试都通过，那么你就完成了此项作业。</p>
</blockquote>
<p>此方案依赖于用户的虚拟地址范围不与内核用于自身指令和数据的虚拟地址范围重叠。Xv6使用从零开始的虚拟地址作为用户地址空间，幸运的是内核的内存从更高的地址开始。然而，这个方案将用户进程的最大大小限制为小于内核的最低虚拟地址。内核启动后，在XV6中该地址是<code>0xC000000</code>，即PLIC寄存器的地址；请参见<em><strong>kernel&#x2F;vm.c</strong></em>中的<code>kvminit()</code>、<em><strong>kernel&#x2F;memlayout.h</strong></em>和文中的图3-4。您需要修改xv6，以防止用户进程增长到超过PLIC的地址。</p>
<p><strong>一些提示：</strong></p>
<ul>
<li>先用对<code>copyin_new</code>的调用替换<code>copyin()</code>，确保正常工作后再去修改<code>copyinstr</code></li>
<li>在内核更改进程的用户映射的每一处，都以相同的方式更改进程的内核页表。包括<code>fork()</code>, <code>exec()</code>, 和<code>sbrk()</code>.</li>
<li>不要忘记在<code>userinit</code>的内核页表中包含第一个进程的用户页表</li>
<li>用户地址的PTE在进程的内核页表中需要什么权限？(在内核模式下，无法访问设置了<code>PTE_U</code>的页面）</li>
<li>别忘了上面提到的PLIC限制</li>
</ul>
<p>Linux使用的技术与您已经实现的技术类似。直到几年前，许多内核在用户和内核空间中都为当前进程使用相同的自身进程页表，并为用户和内核地址进行映射以避免在用户和内核空间之间切换时必须切换页表。然而，这种设置允许边信道攻击，如Meltdown和Spectre。</p>
<blockquote>
<p>[!NOTE|label:QUESTION]<br>解释为什么在<code>copyin_new()</code>中需要第三个测试<code>srcva + len &lt; srcva</code>：给出<code>srcva</code>和<code>len</code>值的例子，这样的值将使前两个测试为假（即它们不会导致返回-1），但是第三个测试为真 （导致返回-1）。</p>
</blockquote>
<h1 id="可选的挑战练习"><a href="#可选的挑战练习" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h1><ul>
<li>使用超级页来减少页表中PTE的数量</li>
<li>扩展您的解决方案以支持尽可能大的用户程序；也就是说，消除用户程序小于PLIC的限制</li>
<li>取消映射用户进程的第一页，以便使对空指针的解引用将导致错误。用户文本段必须从非0处开始，例如4096</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab2/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h1><p>在上一个实验室中，您使用系统调用编写了一些实用程序。在本实验室中，您将向xv6添加一些新的系统调用，这将帮助您了解它们是如何工作的，并使您了解xv6内核的一些内部结构。您将在以后的实验室中添加更多系统调用。</p>
<blockquote>
<p>[!WARNING|label:Attention]<br>在你开始写代码之前，请阅读xv6手册《book-riscv-rev1》的第2章、第4章的第4.3节和第4.4节以及相关源代码文件：</p>
<ul>
<li>系统调用的用户空间代码在<em><strong>user&#x2F;user.h</strong></em>和<em><strong>user&#x2F;usys.pl</strong></em>中。</li>
<li>内核空间代码是<em><strong>kernel&#x2F;syscall.h</strong></em>、<em><strong>kernel&#x2F;syscall.c</strong></em>。</li>
<li>与进程相关的代码是<em><strong>kernel&#x2F;proc.h</strong></em>和<em><strong>kernel&#x2F;proc.c</strong></em>。</li>
</ul>
</blockquote>
<p>要开始本章实验，请将代码切换到<strong>syscall</strong>分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout syscall</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<p>如果运行<code>make grade</code>，您将看到测试分数的脚本无法执行<code>trace</code>和<code>sysinfotest</code>。您的工作是添加必要的系统调用和存根（stubs）以使它们工作。</p>
<h1 id="System-call-tracing（moderate）"><a href="#System-call-tracing（moderate）" class="headerlink" title="System call tracing（moderate）"></a>System call tracing（moderate）</h1><blockquote>
<p>[!TIP|label:YOUR JOB]<br>在本作业中，您将添加一个系统调用跟踪功能，该功能可能会在以后调试实验时对您有所帮助。您将创建一个新的<code>trace</code>系统调用来控制跟踪。它应该有一个参数，这个参数是一个整数“掩码”（mask），它的比特位指定要跟踪的系统调用。例如，要跟踪<code>fork</code>系统调用，程序调用<code>trace(1 &lt;&lt; SYS_fork)</code>，其中<code>SYS_fork</code>是<em><strong>kernel&#x2F;syscall.h</strong></em>中的系统调用编号。如果在掩码中设置了系统调用的编号，则必须修改xv6内核，以便在每个系统调用即将返回时打印出一行。该行应该包含进程id、系统调用的名称和返回值；您不需要打印系统调用参数。<code>trace</code>系统调用应启用对调用它的进程及其随后派生的任何子进程的跟踪，但不应影响其他进程。</p>
</blockquote>
<p>我们提供了一个用户级程序版本的<code>trace</code>，它运行另一个启用了跟踪的程序（参见<em><strong>user&#x2F;trace.c</strong></em>）。完成后，您应该看到如下输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ trace 2147483647 grep hello README</span><br><span class="line">4: syscall trace -&gt; 0</span><br><span class="line">4: syscall <span class="built_in">exec</span> -&gt; 3</span><br><span class="line">4: syscall open -&gt; 3</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">4: syscall close -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ grep hello README</span><br><span class="line">$</span><br><span class="line">$ trace 2 usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line"><span class="built_in">test</span> forkforkfork: 407: syscall fork -&gt; 408</span><br><span class="line">408: syscall fork -&gt; 409</span><br><span class="line">409: syscall fork -&gt; 410</span><br><span class="line">410: syscall fork -&gt; 411</span><br><span class="line">409: syscall fork -&gt; 412</span><br><span class="line">410: syscall fork -&gt; 413</span><br><span class="line">409: syscall fork -&gt; 414</span><br><span class="line">411: syscall fork -&gt; 415</span><br><span class="line">...</span><br><span class="line">$   </span><br></pre></td></tr></table></figure>

<p>在上面的第一个例子中，<code>trace</code>调用<code>grep</code>，仅跟踪了<code>read</code>系统调用。<code>32</code>是<code>1&lt;&lt;SYS_read</code>。在第二个示例中，<code>trace</code>在运行<code>grep</code>时跟踪所有系统调用；<code>2147483647</code>将所有31个低位置为1。在第三个示例中，程序没有被跟踪，因此没有打印跟踪输出。在第四个示例中，在<code>usertests</code>中测试的<code>forkforkfork</code>中所有子孙进程的<code>fork</code>系统调用都被追踪。如果程序的行为如上所示，则解决方案是正确的（尽管进程ID可能不同）</p>
<p><strong>提示：</strong></p>
<ul>
<li>在<em><strong>Makefile</strong></em>的<strong>UPROGS</strong>中添加<code>$U/_trace</code></li>
<li>运行<code>make qemu</code>，您将看到编译器无法编译<em><strong>user&#x2F;trace.c</strong></em>，因为系统调用的用户空间存根还不存在：将系统调用的原型添加到<em><strong>user&#x2F;user.h</strong></em>，存根添加到<em><strong>user&#x2F;usys.pl</strong></em>，以及将系统调用编号添加到<em><strong>kernel&#x2F;syscall.h</strong></em>，<em><strong>Makefile</strong></em>调用perl脚本<em><strong>user&#x2F;usys.pl</strong></em>，它生成实际的系统调用存根<em><strong>user&#x2F;usys.S</strong></em>，这个文件中的汇编代码使用RISC-V的<code>ecall</code>指令转换到内核。一旦修复了编译问题（*注：如果编译还未通过，尝试先<code>make clean</code>，再执行<code>make qemu</code>*），就运行<code>trace 32 grep hello README</code>；但由于您还没有在内核中实现系统调用，执行将失败。</li>
<li>在<em><strong>kernel&#x2F;sysproc.c</strong></em>中添加一个<code>sys_trace()</code>函数，它通过将参数保存到<code>proc</code>结构体（请参见<em><strong>kernel&#x2F;proc.h</strong></em>）里的一个新变量中来实现新的系统调用。从用户空间检索系统调用参数的函数在<em><strong>kernel&#x2F;syscall.c</strong></em>中，您可以在<em><strong>kernel&#x2F;sysproc.c</strong></em>中看到它们的使用示例。</li>
<li>修改<code>fork()</code>（请参阅<em><strong>kernel&#x2F;proc.c</strong></em>）将跟踪掩码从父进程复制到子进程。</li>
<li>修改<em><strong>kernel&#x2F;syscall.c</strong></em>中的<code>syscall()</code>函数以打印跟踪输出。您将需要添加一个系统调用名称数组以建立索引。</li>
</ul>
<h1 id="Sysinfo（moderate）"><a href="#Sysinfo（moderate）" class="headerlink" title="Sysinfo（moderate）"></a>Sysinfo（moderate）</h1><blockquote>
<p>[!TIP|label:YOUR JOB]<br>在这个作业中，您将添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针（参见<em><strong>kernel&#x2F;sysinfo.h</strong></em>）。内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。我们提供了一个测试程序<code>sysinfotest</code>；如果输出“<strong>sysinfotest: OK</strong>”则通过。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>在<em><strong>Makefile</strong></em>的<strong>UPROGS</strong>中添加<code>$U/_sysinfotest</code></li>
<li>当运行<code>make qemu</code>时，<em><strong>user&#x2F;sysinfotest.c</strong></em>将会编译失败，遵循和上一个作业一样的步骤添加<code>sysinfo</code>系统调用。要在<em><strong>user&#x2F;user.h</strong></em>中声明<code>sysinfo()</code>的原型，需要预先声明<code>struct sysinfo</code>的存在：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span>;</span><br></pre></td></tr></table></figure>

<p>一旦修复了编译问题，就运行<code>sysinfotest</code>；但由于您还没有在内核中实现系统调用，执行将失败。</p>
<ul>
<li><code>sysinfo</code>需要将一个<code>struct sysinfo</code>复制回用户空间；请参阅<code>sys_fstat()</code>(<em><strong>kernel&#x2F;sysfile.c</strong></em>)和<code>filestat()</code>(<em><strong>kernel&#x2F;file.c</strong></em>)以获取如何使用<code>copyout()</code>执行此操作的示例。</li>
<li>要获取空闲内存量，请在<em><strong>kernel&#x2F;kalloc.c</strong></em>中添加一个函数</li>
<li>要获取进程数，请在<em><strong>kernel&#x2F;proc.c</strong></em>中添加一个函数</li>
</ul>
<h1 id="可选的挑战"><a href="#可选的挑战" class="headerlink" title="可选的挑战"></a>可选的挑战</h1><ul>
<li>打印所跟踪的系统调用的参数（easy）。</li>
<li>计算平均负载并通过<code>sysinfo</code>导出（moderate）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab5/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab5-xv6-lazy-page-allocation"><a href="#Lab5-xv6-lazy-page-allocation" class="headerlink" title="Lab5: xv6 lazy page allocation"></a>Lab5: xv6 lazy page allocation</h1><p>操作系统可以使用页表硬件的技巧之一是延迟分配用户空间堆内存（lazy allocation of user-space heap memory）。Xv6应用程序使用<code>sbrk()</code>系统调用向内核请求堆内存。在我们给出的内核中，<code>sbrk()</code>分配物理内存并将其映射到进程的虚拟地址空间。内核为一个大请求分配和映射内存可能需要很长时间。例如，考虑由262144个4096字节的页组成的千兆字节；即使单独一个页面的分配开销很低，但合起来如此大的分配数量将不可忽视。此外，有些程序申请分配的内存比实际使用的要多（例如，实现稀疏数组），或者为了以后的不时之需而分配内存。为了让<code>sbrk()</code>在这些情况下更快地完成，复杂的内核会延迟分配用户内存。也就是说，<code>sbrk()</code>不分配物理内存，只是记住分配了哪些用户地址，并在用户页表中将这些地址标记为无效。当进程第一次尝试使用延迟分配中给定的页面时，CPU生成一个页面错误（page fault），内核通过分配物理内存、置零并添加映射来处理该错误。您将在这个实验室中向xv6添加这个延迟分配特性。</p>
<blockquote>
<p>[!WARNING|label:Attention]<br>在开始编码之前，请阅读xv6手册的第4章（特别是4.6），以及可能要修改的相关文件：</p>
<ul>
<li><em><strong>kernel&#x2F;trap.c</strong></em></li>
<li><em><strong>kernel&#x2F;vm.c</strong></em></li>
<li><em><strong>kernel&#x2F;sysproc.c</strong></em></li>
</ul>
</blockquote>
<p>要启动实验，请切换到<code>lazy</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout lazy</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>



<h1 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (easy)</h1><blockquote>
<p>[!TIP|label:YOUR JOB]<br>你的首项任务是删除<code>sbrk(n)</code>系统调用中的页面分配代码（位于<em><strong>sysproc.c</strong></em>中的函数<code>sys_sbrk()</code>）。<code>sbrk(n)</code>系统调用将进程的内存大小增加n个字节，然后返回新分配区域的开始部分（即旧的大小）。新的<code>sbrk(n)</code>应该只将进程的大小（<code>myproc()-&gt;sz</code>）增加n，然后返回旧的大小。它不应该分配内存——因此您应该删除对<code>growproc()</code>的调用（但是您仍然需要增加进程的大小！）。</p>
</blockquote>
<p>试着猜猜这个修改的结果是什么：将会破坏什么？</p>
<p>进行此修改，启动xv6，并在shell中键入<code>echo hi</code>。你应该看到这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x0000000000001258 stval=0x0000000000004008</span><br><span class="line">va=0x0000000000004000 pte=0x0000000000000000</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure>

<p>“<code>usertrap(): …</code>”这条消息来自<em><strong>trap.c</strong></em>中的用户陷阱处理程序；它捕获了一个不知道如何处理的异常。请确保您了解发生此页面错误的原因。“<code>stval=0x0..04008</code>”表示导致页面错误的虚拟地址是<code>0x4008</code>。</p>
<h1 id="Lazy-allocation-moderate"><a href="#Lazy-allocation-moderate" class="headerlink" title="Lazy allocation (moderate)"></a>Lazy allocation (moderate)</h1><blockquote>
<p>[!TIP|label:YOUR JOB]<br>修改<em><strong>trap.c</strong></em>中的代码以响应来自用户空间的页面错误，方法是新分配一个物理页面并映射到发生错误的地址，然后返回到用户空间，让进程继续执行。您应该在生成“<code>usertrap(): …</code>”消息的<code>printf</code>调用之前添加代码。你可以修改任何其他xv6内核代码，以使<code>echo hi</code>正常工作。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>你可以在<code>usertrap()</code>中查看<code>r_scause()</code>的返回值是否为13或15来判断该错误是否为页面错误</li>
<li><code>stval</code>寄存器中保存了造成页面错误的虚拟地址，你可以通过<code>r_stval()</code>读取</li>
<li>参考<em><strong>vm.c</strong></em>中的<code>uvmalloc()</code>中的代码，那是一个<code>sbrk()</code>通过<code>growproc()</code>调用的函数。你将需要对<code>kalloc()</code>和<code>mappages()</code>进行调用</li>
<li>使用<code>PGROUNDDOWN(va)</code>将出错的虚拟地址向下舍入到页面边界</li>
<li>当前<code>uvmunmap()</code>会导致系统<code>panic</code>崩溃；请修改程序保证正常运行</li>
<li>如果内核崩溃，请在<em><strong>kernel&#x2F;kernel.asm</strong></em>中查看<code>sepc</code></li>
<li>使用pgtbl lab的<code>vmprint</code>函数打印页表的内容</li>
<li>如果您看到错误“incomplete type proc”，请include“spinlock.h”然后是“proc.h”。</li>
</ul>
<p>如果一切正常，你的lazy allocation应该使<code>echo hi</code>正常运行。您应该至少有一个页面错误（因为延迟分配），也许有两个。</p>
<h1 id="Lazytests-and-Usertests-moderate"><a href="#Lazytests-and-Usertests-moderate" class="headerlink" title="Lazytests and Usertests (moderate)"></a>Lazytests and Usertests (moderate)</h1><p>我们为您提供了<code>lazytests</code>，这是一个xv6用户程序，它测试一些可能会给您的惰性内存分配器带来压力的特定情况。修改内核代码，使所有<code>lazytests</code>和<code>usertests</code>都通过。</p>
<ul>
<li>处理<code>sbrk()</code>参数为负的情况。</li>
<li>如果某个进程在高于<code>sbrk()</code>分配的任何虚拟内存地址上出现页错误，则终止该进程。</li>
<li>在<code>fork()</code>中正确处理父到子内存拷贝。</li>
<li>处理这种情形：进程从<code>sbrk()</code>向系统调用（如<code>read</code>或<code>write</code>）传递有效地址，但尚未分配该地址的内存。</li>
<li>正确处理内存不足：如果在页面错误处理程序中执行<code>kalloc()</code>失败，则终止当前进程。</li>
<li>处理用户栈下面的无效页面上发生的错误。</li>
</ul>
<p>如果内核通过<code>lazytests</code>和<code>usertests</code>，那么您的解决方案是可以接受的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ lazytests</span><br><span class="line">lazytests starting</span><br><span class="line">running <span class="built_in">test</span> lazy alloc</span><br><span class="line"><span class="built_in">test</span> lazy alloc: OK</span><br><span class="line">running <span class="built_in">test</span> lazy unmap...</span><br><span class="line">usertrap(): ...</span><br><span class="line"><span class="built_in">test</span> lazy unmap: OK</span><br><span class="line">running <span class="built_in">test</span> out of memory</span><br><span class="line">usertrap(): ...</span><br><span class="line"><span class="built_in">test</span> out of memory: OK</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<h1 id="可选的挑战练习"><a href="#可选的挑战练习" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h1><ul>
<li>让延时分配协同上一个实验中简化版的<code>copyin</code>一起工作。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/requirements/lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/requirements/lab4/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/requirements/lab4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/requirements/lab4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab4-traps"><a href="#Lab4-traps" class="headerlink" title="Lab4: traps"></a>Lab4: traps</h1><p>本实验探索如何使用陷阱实现系统调用。您将首先使用栈做一个热身练习，然后实现一个用户级陷阱处理的示例。</p>
<blockquote>
<p>[!WARNING|label:Attention]<br>开始编码之前，请阅读xv6手册的第4章和相关源文件：</p>
<ul>
<li><em><strong>kernel&#x2F;trampoline.S</strong></em>：涉及从用户空间到内核空间再到内核空间的转换的程序集</li>
<li><em><strong>kernel&#x2F;trap.c</strong></em>：处理所有中断的代码</li>
</ul>
</blockquote>
<p>要启动实验，请切换到<code>traps</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout traps</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<h1 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h1><p>理解一点RISC-V汇编是很重要的，你应该在6.004中接触过。xv6仓库中有一个文件<em><strong>user&#x2F;call.c</strong></em>。执行<code>make fs.img</code>编译它，并在<em><strong>user&#x2F;call.asm</strong></em>中生成可读的汇编版本。</p>
<p>阅读<em><strong>call.asm</strong></em>中函数<code>g</code>、<code>f</code>和<code>main</code>的代码。RISC-V的使用手册在<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/reference.html">参考页</a>上。以下是您应该回答的一些问题（将答案存储在<em><strong>answers-traps.txt</strong></em>文件中）：</p>
<ol>
<li>哪些寄存器保存函数的参数？例如，在<code>main</code>对<code>printf</code>的调用中，哪个寄存器保存13？</li>
<li><code>main</code>的汇编代码中对函数<code>f</code>的调用在哪里？对<code>g</code>的调用在哪里(提示：编译器可能会将函数内联）</li>
<li><code>printf</code>函数位于哪个地址？</li>
<li>在<code>main</code>中<code>printf</code>的<code>jalr</code>之后的寄存器<code>ra</code>中有什么值？</li>
<li>运行以下代码。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>程序的输出是什么？这是将字节映射到字符的<a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">ASCII码表</a>。</p>
<p>输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把<code>i</code>设置成什么？是否需要将<code>57616</code>更改为其他值？</p>
<p><a target="_blank" rel="noopener" href="http://www.webopedia.com/TERM/b/big_endian.html">这里有一个小端和大端存储的描述</a>和一个<a target="_blank" rel="noopener" href="http://www.networksorcery.com/enp/ien/ien137.txt">更异想天开的描述</a>。</p>
<ol start="6">
<li>在下面的代码中，“<code>y=</code>”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace(moderate)"></a>Backtrace(moderate)</h1><p>回溯(Backtrace)通常对于调试很有用：它是一个存放于栈上用于指示错误发生位置的函数调用列表。</p>
<p>在<em><strong>kernel&#x2F;printf.c</strong></em>中实现名为<code>backtrace()</code>的函数。在<code>sys_sleep</code>中插入一个对此函数的调用，然后运行<code>bttest</code>，它将会调用<code>sys_sleep</code>。你的输出应该如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">backtrace:</span><br><span class="line">0x0000000080002cda</span><br><span class="line">0x0000000080002bb6</span><br><span class="line">0x0000000080002898</span><br></pre></td></tr></table></figure>

<p>​        在<code>bttest</code>退出qemu后。在你的终端：地址或许会稍有不同，但如果你运行<code>addr2line -e kernel/kernel</code>（或<code>riscv64-unknown-elf-addr2line -e kernel/kernel</code>），并将上面的地址剪切粘贴如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ addr2line -e kernel/kernel</span><br><span class="line">0x0000000080002de2</span><br><span class="line">0x0000000080002f4a</span><br><span class="line">0x0000000080002bfc</span><br><span class="line">Ctrl-D</span><br></pre></td></tr></table></figure>

<p>​        你应该看到类似下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel/sysproc.c:74</span><br><span class="line">kernel/syscall.c:224</span><br><span class="line">kernel/trap.c:85</span><br></pre></td></tr></table></figure>

<p>​        编译器向每一个栈帧中放置一个帧指针（frame pointer）保存调用者帧指针的地址。你的<code>backtrace</code>应当使用这些帧指针来遍历栈，并在每个栈帧中打印保存的返回地址。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p>在<em><strong>kernel&#x2F;defs.h</strong></em>中添加<code>backtrace</code>的原型，那样你就能在<code>sys_sleep</code>中引用<code>backtrace</code></p>
</li>
<li><p>GCC编译器将当前正在执行的函数的帧指针保存在<code>s0</code>寄存器，将下面的函数添加到<em><strong>kernel&#x2F;riscv.h</strong></em></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        并在<code>backtrace</code>中调用此函数来读取当前的帧指针。这个函数使用<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">内联汇编</a>来读取<code>s0</code></p>
<ul>
<li>这个<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">课堂笔记</a>中有张栈帧布局图。注意返回地址位于栈帧帧指针的固定偏移(-8)位置，并且保存的帧指针位于帧指针的固定偏移(-16)位置</li>
</ul>
<p><img src="/images/p2.png" alt="img"></p>
<ul>
<li>XV6在内核中以页面对齐的地址为每个栈分配一个页面。你可以通过<code>PGROUNDDOWN(fp)</code>和<code>PGROUNDUP(fp)</code>（参见<em><strong>kernel&#x2F;riscv.h</strong></em>）来计算栈页面的顶部和底部地址。这些数字对于<code>backtrace</code>终止循环是有帮助的。</li>
</ul>
<p>一旦你的<code>backtrace</code>能够运行，就在<em><strong>kernel&#x2F;printf.c</strong></em>的<code>panic</code>中调用它，那样你就可以在<code>panic</code>发生时看到内核的<code>backtrace</code>。</p>
<h1 id="Alarm-Hard"><a href="#Alarm-Hard" class="headerlink" title="Alarm(Hard)"></a>Alarm(Hard)</h1><blockquote>
<p>[!TIP|label:YOUR JOB]<br>在这个练习中你将向XV6添加一个特性，在进程使用CPU的时间内，XV6定期向进程发出警报。这对于那些希望限制CPU时间消耗的受计算限制的进程，或者对于那些计算的同时执行某些周期性操作的进程可能很有用。更普遍的来说，你将实现用户级中断&#x2F;故障处理程序的一种初级形式。例如，你可以在应用程序中使用类似的一些东西处理页面故障。如果你的解决方案通过了<code>alarmtest</code>和<code>usertests</code>就是正确的。</p>
</blockquote>
<p>你应当添加一个新的<code>sigalarm(interval, handler)</code>系统调用，如果一个程序调用了<code>sigalarm(n, fn)</code>，那么每当程序消耗了CPU时间达到n个“滴答”，内核应当使应用程序函数<code>fn</code>被调用。当<code>fn</code>返回时，应用应当在它离开的地方恢复执行。在XV6中，一个滴答是一段相当任意的时间单元，取决于硬件计时器生成中断的频率。如果一个程序调用了<code>sigalarm(0, 0)</code>，系统应当停止生成周期性的报警调用。</p>
<p>你将在XV6的存储库中找到名为<em><strong>user&#x2F;alarmtest.c</strong></em>的文件。将其添加到<em><strong>Makefile</strong></em>。注意：你必须添加了<code>sigalarm</code>和<code>sigreturn</code>系统调用后才能正确编译（往下看）。</p>
<p><code>alarmtest</code>在<code>test0</code>中调用了<code>sigalarm(2, periodic)</code>来要求内核每隔两个滴答强制调用<code>periodic()</code>，然后旋转一段时间。你可以在<em><strong>user&#x2F;alarmtest.asm</strong></em>中看到<code>alarmtest</code>的汇编代码，这或许会便于调试。当<code>alarmtest</code>产生如下输出并且<code>usertests</code>也能正常运行时，你的方案就是正确的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ alarmtest</span><br><span class="line">test0 start</span><br><span class="line">........alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">................alarm!</span><br><span class="line">test2 passed</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>​        当你完成后，你的方案也许仅有几行代码，但如何正确运行是一个棘手的问题。我们将使用原始存储库中的<em><strong>alarmtest.c</strong></em>版本测试您的代码。你可以修改<em><strong>alarmtest.c</strong></em>来帮助调试，但是要确保原来的<code>alarmtest</code>显示所有的测试都通过了。</p>
<h2 id="test0-invoke-handler-调用处理程序"><a href="#test0-invoke-handler-调用处理程序" class="headerlink" title="test0: invoke handler(调用处理程序)"></a>test0: invoke handler(调用处理程序)</h2><p>首先修改内核以跳转到用户空间中的报警处理程序，这将导致<code>test0</code>打印“alarm!”。不用担心输出“alarm!”之后会发生什么；如果您的程序在打印“alarm！”后崩溃，对于目前来说也是正常的。以下是一些<strong>提示</strong>：</p>
<ul>
<li><p>您需要修改<em><strong>Makefile</strong></em>以使<em><strong>alarmtest.c</strong></em>被编译为xv6用户程序。</p>
</li>
<li><p>放入<em><strong>user&#x2F;user.h</strong></em>的正确声明是：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>更新<em><strong>user&#x2F;usys.pl</strong></em>（此文件生成<em><strong>user&#x2F;usys.S</strong></em>）、<em><strong>kernel&#x2F;syscall.h</strong></em>和<em><strong>kernel&#x2F;syscall.c</strong></em>以允许<code>alarmtest</code>调用<code>sigalarm</code>和<code>sigreturn</code>系统调用。</p>
</li>
<li><p>目前来说，你的<code>sys_sigreturn</code>系统调用返回应该是零。</p>
</li>
<li><p>你的<code>sys_sigalarm()</code>应该将报警间隔和指向处理程序函数的指针存储在<code>struct proc</code>的新字段中（位于<em><strong>kernel&#x2F;proc.h</strong></em>）。</p>
</li>
<li><p>你也需要在<code>struct proc</code>新增一个新字段。用于跟踪自上一次调用（或直到下一次调用）到进程的报警处理程序间经历了多少滴答；您可以在<em><strong>proc.c</strong></em>的<code>allocproc()</code>中初始化<code>proc</code>字段。</p>
</li>
<li><p>每一个滴答声，硬件时钟就会强制一个中断，这个中断在<em><strong>kernel&#x2F;trap.c</strong></em>中的<code>usertrap()</code>中处理。</p>
</li>
<li><p>如果产生了计时器中断，您只想操纵进程的报警滴答；你需要写类似下面的代码</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>仅当进程有未完成的计时器时才调用报警函数。请注意，用户报警函数的地址可能是0（例如，在<em><strong>user&#x2F;alarmtest.asm</strong></em>中，<code>periodic</code>位于地址0）。</p>
</li>
<li><p>您需要修改<code>usertrap()</code>，以便当进程的报警间隔期满时，用户进程执行处理程序函数。当RISC-V上的陷阱返回到用户空间时，什么决定了用户空间代码恢复执行的指令地址？</p>
</li>
<li><p>如果您告诉qemu只使用一个CPU，那么使用gdb查看陷阱会更容易，这可以通过运行</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>alarmtest</code>打印“alarm!”，则您已成功。</li>
</ul>
<h2 id="test1-x2F-test2-resume-interrupted-code-恢复被中断的代码"><a href="#test1-x2F-test2-resume-interrupted-code-恢复被中断的代码" class="headerlink" title="test1&#x2F;test2(): resume interrupted code(恢复被中断的代码)"></a>test1&#x2F;test2(): resume interrupted code(恢复被中断的代码)</h2><p><code>alarmtest</code>打印“alarm!”后，很可能会在<code>test0</code>或<code>test1</code>中崩溃，或者<code>alarmtest</code>（最后）打印“test1 failed”，或者<code>alarmtest</code>未打印“test1 passed”就退出。要解决此问题，必须确保完成报警处理程序后返回到用户程序最初被计时器中断的指令执行。必须确保寄存器内容恢复到中断时的值，以便用户程序在报警后可以不受干扰地继续运行。最后，您应该在每次报警计数器关闭后“重新配置”它，以便周期性地调用处理程序。</p>
<p>作为一个起始点，我们为您做了一个设计决策：用户报警处理程序需要在完成后调用<code>sigreturn</code>系统调用。请查看<em><strong>alarmtest.c</strong></em>中的<code>periodic</code>作为示例。这意味着您可以将代码添加到<code>usertrap</code>和<code>sys_sigreturn</code>中，这两个代码协同工作，以使用户进程在处理完警报后正确恢复。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p>您的解决方案将要求您保存和恢复寄存器——您需要保存和恢复哪些寄存器才能正确恢复中断的代码？(提示：会有很多）</p>
</li>
<li><p>当计时器关闭时，让<code>usertrap</code>在<code>struct proc</code>中保存足够的状态，以使<code>sigreturn</code>可以正确返回中断的用户代码。</p>
</li>
<li><p>防止对处理程序的重复调用——如果处理程序还没有返回，内核就不应该再次调用它。<code>test2</code>测试这个。</p>
</li>
<li><p>一旦通过<code>test0</code>、<code>test1</code>和<code>test2</code>，就运行<code>usertests</code>以确保没有破坏内核的任何其他部分。</p>
</li>
</ul>
<h1 id="可选的挑战练习"><a href="#可选的挑战练习" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h1><ul>
<li>在<code>backtrace()</code>中打印函数的名称和行号，而不仅仅是数字化的地址。(hard)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaoq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nPTQNF98hlhFVhx3uT28h3EW-gzGzoHsz',
      appKey     : 'Hj5CW3nJJnJ3rBlGeKK8XQLa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
