<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="肖大强的个人博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="肖大强的个人博客">
<meta property="og:locale">
<meta property="article:author" content="xiaoq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>肖大强的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖大强的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s3/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-3-代码：Buffer-cache"><a href="#8-3-代码：Buffer-cache" class="headerlink" title="8.3 代码：Buffer cache"></a>8.3 代码：Buffer cache</h1><p>Buffer cache是以双链表表示的缓冲区。<code>main</code>（<em><strong>kernel&#x2F;main.c</strong></em>:27）调用的函数<code>binit</code>使用静态数组<code>buf</code>（<em><strong>kernel&#x2F;bio.c</strong></em>:43-52）中的<code>NBUF</code>个缓冲区初始化列表。对Buffer cache的所有其他访问都通过<code>bcache.head</code>引用链表，而不是<code>buf</code>数组。</p>
<p>缓冲区有两个与之关联的状态字段。字段<code>valid</code>表示缓冲区是否包含块的副本。字段<code>disk</code>表示缓冲区内容是否已交给磁盘，这可能会更改缓冲区（例如，将数据从磁盘写入<code>data</code>）。</p>
<p><code>Bread</code>（<em><strong>kernel&#x2F;bio.c</strong></em>:93）调用<code>bget</code>为给定扇区（<em><strong>kernel&#x2F;bio.c</strong></em>:97）获取缓冲区。如果缓冲区需要从磁盘进行读取，<code>bread</code>会在返回缓冲区之前调用<code>virtio_disk_rw</code>来执行此操作。</p>
<p><code>Bget</code>（<em><strong>kernel&#x2F;bio.c</strong></em>:59）扫描缓冲区列表，查找具有给定设备和扇区号（<em><strong>kernel&#x2F;bio.c</strong></em>:65-73）的缓冲区。如果存在这样的缓冲区，<code>bget</code>将获取缓冲区的睡眠锁。然后<code>Bget</code>返回锁定的缓冲区。</p>
<p>如果对于给定的扇区没有缓冲区，<code>bget</code>必须创建一个，这可能会重用包含其他扇区的缓冲区。它再次扫描缓冲区列表，查找未在使用中的缓冲区（<code>b-&gt;refcnt = 0</code>）：任何这样的缓冲区都可以使用。<code>Bget</code>编辑缓冲区元数据以记录新设备和扇区号，并获取其睡眠锁。注意，<code>b-&gt;valid = 0</code>的布置确保了<code>bread</code>将从磁盘读取块数据，而不是错误地使用缓冲区以前的内容。</p>
<p>每个磁盘扇区最多有一个缓存缓冲区是非常重要的，并且因为文件系统使用缓冲区上的锁进行同步，可以确保读者看到写操作。<code>Bget</code>的从第一个检查块是否缓存的循环到第二个声明块现在已缓存（通过设置<code>dev</code>、<code>blockno</code>和<code>refcnt</code>）的循环，一直持有<code>bcache.lock</code>来确保此不变量。这会导致检查块是否存在以及（如果不存在）指定一个缓冲区来存储块具有原子性。</p>
<p><code>bget</code>在<code>bcache.lock</code>临界区域之外获取缓冲区的睡眠锁是安全的，因为非零<code>b-&gt;refcnt</code>防止缓冲区被重新用于不同的磁盘块。睡眠锁保护块缓冲内容的读写，而<code>bcache.lock</code>保护有关缓存哪些块的信息。</p>
<p>如果所有缓冲区都处于忙碌，那么太多进程同时执行文件系统调用；<code>bget</code>将会<code>panic</code>。一个更优雅的响应可能是在缓冲区空闲之前休眠，尽管这样可能会出现死锁。</p>
<p>一旦<code>bread</code>读取了磁盘（如果需要）并将缓冲区返回给其调用者，调用者就可以独占使用缓冲区，并可以读取或写入数据字节。如果调用者确实修改了缓冲区，则必须在释放缓冲区之前调用<code>bwrite</code>将更改的数据写入磁盘。<code>Bwrite</code>（<em><strong>kernel&#x2F;bio.c</strong></em>:107）调用<code>virtio_disk_rw</code>与磁盘硬件对话。</p>
<p>当调用方使用完缓冲区后，它必须调用<code>brelse</code>来释放缓冲区(<code>brelse</code>是<code>b-release</code>的缩写，这个名字很隐晦，但值得学习：它起源于Unix，也用于BSD、Linux和Solaris）。<code>brelse</code>（<em><strong>kernel&#x2F;bio.c</strong></em>:117）释放睡眠锁并将缓冲区移动到链表的前面（<em><strong>kernel&#x2F;bio.c</strong></em>:128-133）。移动缓冲区会使列表按缓冲区的使用频率排序（意思是释放）：列表中的第一个缓冲区是最近使用的，最后一个是最近使用最少的。<code>bget</code>中的两个循环利用了这一点：在最坏的情况下，对现有缓冲区的扫描必须处理整个列表，但首先检查最新使用的缓冲区（从<code>bcache.head</code>开始，然后是下一个指针），在引用局部性良好的情况下将减少扫描时间。选择要重用的缓冲区时，通过自后向前扫描（跟随<code>prev</code>指针）选择最近使用最少的缓冲区。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s10/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s10/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-10-代码：-Inode包含内容"><a href="#8-10-代码：-Inode包含内容" class="headerlink" title="8.10 代码： Inode包含内容"></a>8.10 代码： Inode包含内容</h1><p>磁盘上的inode结构体<code>struct dinode</code>包含一个<code>size</code>和一个块号数组（见图8.3）。inode数据可以在<code>dinode</code>的<code>addrs</code>数组列出的块中找到。前面的<code>NDIRECT</code>个数据块被列在数组中的前<code>NDIRECT</code>个元素中；这些块称为直接块（direct blocks）。接下来的<code>NINDIRECT</code>个数据块不在inode中列出，而是在称为间接块（indirect block）的数据块中列出。<code>addrs</code>数组中的最后一个元素给出了间接块的地址。因此，可以从inode中列出的块加载文件的前12 kB（<code>NDIRECT x BSIZE</code>）字节，而只有在查阅间接块后才能加载下一个256 kB（<code>NINDIRECT  x BSIZE</code>）字节。这是一个很好的磁盘表示，但对于客户端来说较复杂。函数<code>bmap</code>管理这种表示，以便实现我们将很快看到的如<code>readi</code>和<code>writei</code>这样的更高级例程。<code>bmap(struct inode *ip, uint bn)</code>返回索引结点<code>ip</code>的第<code>bn</code>个数据块的磁盘块号。如果<code>ip</code>还没有这样的块，<code>bmap</code>会分配一个。</p>
<p><img src="/../images/c8/p2.png" alt="img"></p>
<p>函数<code>bmap</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:378）从简单的情况开始：前面的<code>NDIRECT</code>个块在inode本身中列出（<em><strong>kernel&#x2F;fs.c</strong></em>:383-387）中。下面<code>NINDIRECT</code>个块在<code>ip-&gt;addrs[NDIRECT]</code>的间接块中列出。<code>Bmap</code>读取间接块（<em><strong>kernel&#x2F;fs.c</strong></em>:394），然后从块内的正确位置（<em><strong>kernel&#x2F;fs.c</strong></em>:395）读取块号。如果块号超过<code>NDIRECT+NINDIRECT</code>，则<code>bmap</code>调用<code>panic</code>崩溃；<code>writei</code>包含防止这种情况发生的检查（<em><strong>kernel&#x2F;fs.c</strong></em>:490）。</p>
<p><code>Bmap</code>根据需要分配块。<code>ip-&gt;addrs[]</code>或间接块中条目为零表示未分配块。当<code>bmap</code>遇到零时，它会用按需分配的新块（<em><strong>kernel&#x2F;fs.c</strong></em>:384-385）（<em><strong>kernel&#x2F;fs.c</strong></em>:392-393）替换它们。</p>
<p><code>itrunc</code>释放文件的块，将inode的<code>size</code>重置为零。<code>Itrunc</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:410）首先释放直接块（<em><strong>kernel&#x2F;fs.c</strong></em>:416-421），然后释放间接块中列出的块（<em><strong>kernel&#x2F;fs.c</strong></em>:426-429），最后释放间接块本身（<em><strong>kernel&#x2F;fs.c</strong></em>:431-432）。</p>
<p><code>Bmap</code>使<code>readi</code>和<code>writei</code>很容易获取inode的数据。<code>Readi</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:456）首先确保偏移量和计数不超过文件的末尾。开始于超过文件末尾的地方读取将返回错误（<em><strong>kernel&#x2F;fs.c</strong></em>:461-462），而从文件末尾开始或穿过文件末尾的读取返回的字节数少于请求的字节数（<em><strong>kernel&#x2F;fs.c</strong></em>:463-464）。主循环处理文件的每个块，将数据从缓冲区复制到<code>dst</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:466-474）。<code>writei</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:483）与<code>readi</code>相同，但有三个例外：从文件末尾开始或穿过文件末尾的写操作会使文件增长到最大文件大小（<em><strong>kernel&#x2F;fs.c</strong></em>:490-491）；循环将数据复制到缓冲区而不是输出（kernel&#x2F;fs.c:36）；如果写入扩展了文件，<code>writei</code>必须更新其大小（<em><strong>kernel&#x2F;fs.c</strong></em>:504-511）。</p>
<p><code>readi</code>和<code>writei</code>都是从检查<code>ip-&gt;type == T_DEV</code>开始的。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层返回到这种情况。</p>
<p>函数<code>stati</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:442）将inode元数据复制到<code>stat</code>结构体中，该结构通过<code>stat</code>系统调用向用户程序公开。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s11/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s11/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-11-代码：目录层"><a href="#8-11-代码：目录层" class="headerlink" title="8.11 代码：目录层"></a>8.11 代码：目录层</h1><p>目录的内部实现很像文件。其inode的<code>type</code>为<code>T_DIR</code>，其数据是一系列目录条目（directory entries）。每个条目（entry）都是一个<code>struct dirent</code>（<em><strong>kernel&#x2F;fs.h</strong></em>:56），其中包含一个名称<code>name</code>和一个inode编号<code>inum</code>。名称最多为<code>DIRSIZ</code>（14）个字符；如果较短，则以<code>NUL</code>（0）字节终止。inode编号为零的条目是空的。</p>
<p>函数<code>dirlookup</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:527）在目录中搜索具有给定名称的条目。如果找到一个，它将返回一个指向相应inode的指针，解开锁定，并将<code>*poff</code>设置为目录中条目的字节偏移量，以满足调用方希望对其进行编辑的情形。如果<code>dirlookup</code>找到具有正确名称的条目，它将更新<code>*poff</code>并返回通过<code>iget</code>获得的未锁定的inode。<code>Dirlookup</code>是<code>iget</code>返回未锁定indoe的原因。调用者已锁定<code>dp</code>，因此，如果对<code>.</code>，当前目录的别名，进行查找，则在返回之前尝试锁定indoe将导致重新锁定<code>dp</code>并产生死锁(还有更复杂的死锁场景，涉及多个进程和<code>..</code>，父目录的别名。<code>.</code>不是唯一的问题。）调用者可以解锁<code>dp</code>，然后锁定<code>ip</code>，确保它一次只持有一个锁。</p>
<p>函数<code>dirlink</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:554）将给定名称和inode编号的新目录条目写入目录<code>dp</code>。如果名称已经存在，<code>dirlink</code>将返回一个错误（<em><strong>kernel&#x2F;fs.c</strong></em>:560-564）。主循环读取目录条目，查找未分配的条目。当找到一个时，它会提前停止循环（<em><strong>kernel&#x2F;fs.c</strong></em>:538-539），并将<code>off</code>设置为可用条目的偏移量。否则，循环结束时会将<code>off</code>设置为<code>dp-&gt;size</code>。无论哪种方式，<code>dirlink</code>都会通过在偏移<code>off</code>处写入（<em><strong>kernel&#x2F;fs.c</strong></em>:574-577）来向目录添加一个新条目。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s12/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s12/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s12/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-12-代码：路径名"><a href="#8-12-代码：路径名" class="headerlink" title="8.12 代码：路径名"></a>8.12 代码：路径名</h1><p>路径名查找涉及一系列对<code>dirlookup</code>的调用，每个路径组件调用一个。<code>Namei</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:661）计算<code>path</code>并返回相应的inode。函数<code>nameiparent</code>是一个变体：它在最后一个元素之前停止，返回父目录的inode并将最后一个元素复制到<code>name</code>中。两者都调用通用函数<code>namex</code>来完成实际工作。</p>
<p><code>Namex</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:626）首先决定路径计算的开始位置。如果路径以斜线开始，则计算从根目录开始；否则，从当前目录开始（<em><strong>kernel&#x2F;fs.c</strong></em>:630-633）。然后，它使用<code>skipelem</code>依次考察路径的每个元素（<em><strong>kernel&#x2F;fs.c</strong></em>:635）。循环的每次迭代都必须在当前索引结点<code>ip</code>中查找<code>name</code>。迭代首先给<code>ip</code>上锁并检查它是否是一个目录。如果不是，则查找失败（<em><strong>kernel&#x2F;fs.c</strong></em>:636-640）(锁定<code>ip</code>是必要的，不是因为<code>ip-&gt;type</code>可以被更改，而是因为在<code>ilock</code>运行之前，<code>ip-&gt;type</code>不能保证已从磁盘加载。）如果调用是<code>nameiparent</code>，并且这是最后一个路径元素，则根据<code>nameiparent</code>的定义，循环会提前停止；最后一个路径元素已经复制到<code>name</code>中，因此<code>namex</code>只需返回解锁的<code>ip</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:641-645）。最后，循环将使用<code>dirlookup</code>查找路径元素，并通过设置<code>ip = next</code>（<em><strong>kernel&#x2F;fs.c</strong></em>:646-651）为下一次迭代做准备。当循环用完路径元素时，它返回<code>ip</code>。</p>
<p><code>namex</code>过程可能需要很长时间才能完成：它可能涉及多个磁盘操作来读取路径名中所遍历目录的索引节点和目录块（如果它们不在buffer cache中）。Xv6经过精心设计，如果一个内核线程对<code>namex</code>的调用在磁盘I&#x2F;O上阻塞，另一个查找不同路径名的内核线程可以同时进行。<code>Namex</code>分别锁定路径中的每个目录，以便在不同目录中进行并行查找。</p>
<p>这种并发性带来了一些挑战。例如，当一个内核线程正在查找路径名时，另一个内核线程可能正在通过取消目录链接来更改目录树。一个潜在的风险是，查找可能正在搜索已被另一个内核线程删除且其块已被重新用于另一个目录或文件的目录。</p>
<p>Xv6避免了这种竞争。例如，在<code>namex</code>中执行<code>dirlookup</code>时，lookup线程持有目录上的锁，<code>dirlookup</code>返回使用<code>iget</code>获得的inode。<code>Iget</code>增加索引节点的引用计数。只有在从<code>dirlookup</code>接收inode之后，<code>namex</code>才会释放目录上的锁。现在，另一个线程可以从目录中取消inode的链接，但是xv6还不会删除inode，因为inode的引用计数仍然大于零。</p>
<p>另一个风险是死锁。例如，查找“<code>.</code>”时，<code>next</code>指向与<code>ip</code>相同的inode。在释放<code>ip</code>上的锁之前锁定<code>next</code>将导致死锁。为了避免这种死锁，<code>namex</code>在获得下一个目录的锁之前解锁该目录。这里我们再次看到为什么<code>iget</code>和<code>ilock</code>之间的分离很重要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s14/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s14/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s14/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-14-代码：系统调用"><a href="#8-14-代码：系统调用" class="headerlink" title="8.14 代码：系统调用"></a>8.14 代码：系统调用</h1><p>通过使用底层提供的函数，大多数系统调用的实现都很简单（请参阅<em><strong>kernel&#x2F;sysfile.c</strong></em>）。有几个调用值得仔细看看。</p>
<p>函数<code>sys_link</code>和<code>sys_unlink</code>编辑目录，创建或删除索引节点的引用。它们是使用事务能力的另一个很好的例子。<code>sys_link</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:120）从获取其参数开始，两个字符串分别是<code>old</code>和<code>new</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:125）。假设<code>old</code>存在并且不是一个目录（<em><strong>kernel&#x2F;sysfile.c</strong></em>:129-132），<code>sys_link</code>会增加其<code>ip-&gt;nlink</code>计数。然后<code>sys_link</code>调用<code>nameiparent</code>来查找<code>new</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:145）的父目录和最终路径元素，并创建一个指向<code>old</code>的inode（<em><strong>kernel&#x2F;sysfile.c</strong></em>:148）的新目录条目。<code>new</code>的父目录必须存在并且与现有inode位于同一设备上：inode编号在一个磁盘上只有唯一的含义。如果出现这样的错误，<code>sys_link</code>必须返回并减少<code>ip-&gt;nlink</code>。</p>
<p>事务简化了实现，因为它需要更新多个磁盘块，但我们不必担心更新的顺序。他们要么全部成功，要么什么都不做。例如在没有事务的情况下，在创建一个链接之前更新<code>ip-&gt;nlink</code>会使文件系统暂时处于不安全状态，而在这两者之间发生的崩溃可能会造成严重破坏。对于事务，我们不必担心这一点</p>
<p><code>Sys_link</code>为现有inode创建一个新名称。函数<code>create</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:242）为新inode创建一个新名称。它是三个文件创建系统调用的泛化：带有<code>O_CREATE</code>标志的<code>open</code>生成一个新的普通文件，<code>mkdir</code>生成一个新目录，<code>mkdev</code>生成一个新的设备文件。与<code>sys_link</code>一样，<code>create</code>从调用<code>nameiparent</code>开始，以获取父目录的inode。然后调用<code>dirlookup</code>检查名称是否已经存在（<em><strong>kernel&#x2F;sysfile.c</strong></em>:252）。如果名称确实存在，<code>create</code>的行为取决于它用于哪个系统调用：<code>open</code>的语义与<code>mkdir</code>和<code>mkdev</code>不同。如果<code>create</code>是代表<code>open</code>（<code>type == T_FILE</code>）使用的，并且存在的名称本身是一个常规文件，那么<code>open</code>会将其视为成功，<code>create</code>也会这样做（<em><strong>kernel&#x2F;sysfile.c</strong></em>:256）。否则，这是一个错误（<em><strong>kernel&#x2F;sysfile.c</strong></em>:257-258）。如果名称不存在，<code>create</code>现在将使用<code>ialloc</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:261）分配一个新的inode。如果新inode是目录，<code>create</code>将使用<code>.</code>和<code>..</code>条目对它进行初始化。最后，既然数据已正确初始化，<code>create</code>可以将其链接到父目录（<em><strong>kernel&#x2F;sysfile.c</strong></em>:274）。<code>Create</code>与<code>sys_link</code>一样，同时持有两个inode锁：<code>ip</code>和<code>dp</code>。不存在死锁的可能性，因为索引结点<code>ip</code>是新分配的：系统中没有其他进程会持有<code>ip</code>的锁，然后尝试锁定<code>dp</code>。</p>
<p>使用<code>create</code>，很容易实现<code>sys_open</code>、<code>sys_mkdir</code>和<code>sys_mknod</code>。<code>Sys_open</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:287）是最复杂的，因为创建一个新文件只是它能做的一小部分。如果<code>open</code>被传递了<code>O_CREATE</code>标志，它将调用<code>create</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:301）。否则，它将调用<code>namei</code>（<em><strong>kernel&#x2F;sysfile.c</strong></em>:307）。<code>Create</code>返回一个锁定的inode，但<code>namei</code>不锁定，因此<code>sys_open</code>必须锁定inode本身。这提供了一个方便的地方来检查目录是否仅为读取打开，而不是写入。假设inode是以某种方式获得的，<code>sys_open</code>分配一个文件和一个文件描述符（<em><strong>kernel&#x2F;sysfile.c</strong></em>:325），然后填充该文件（<em><strong>kernel&#x2F;sysfile.c</strong></em>:337-342）。请注意，没有其他进程可以访问部分初始化的文件，因为它仅位于当前进程的表中。</p>
<p>在我们还没有文件系统之前，第7章就研究了管道的实现。函数<code>sys_pipe</code>通过提供创建管道对的方法将该实现连接到文件系统。它的参数是一个指向两个整数的指针，它将在其中记录两个新的文件描述符。然后分配管道并安装文件描述符。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s15/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s15/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s15/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-15-真实世界"><a href="#8-15-真实世界" class="headerlink" title="8.15 真实世界"></a>8.15 真实世界</h1><p>实际操作系统中的buffer cache比xv6复杂得多，但它有两个相同的用途：缓存和同步对磁盘的访问。与UNIX V6一样，Xv6的buffer cache使用简单的最近最少使用（LRU）替换策略；有许多更复杂的策略可以实现，每种策略都适用于某些工作场景，而不适用于其他工作场景。更高效的LRU缓存将消除链表，而改为使用哈希表进行查找，并使用堆进行LRU替换。现代buffer cache通常与虚拟内存系统集成，以支持内存映射文件。</p>
<p>Xv6的日志系统效率低下。提交不能与文件系统调用同时发生。系统记录整个块，即使一个块中只有几个字节被更改。它执行同步日志写入，每次写入一个块，每个块可能需要整个磁盘旋转时间。真正的日志系统解决了所有这些问题。</p>
<p>日志记录不是提供崩溃恢复的唯一方法。早期的文件系统在重新启动期间使用了一个清道夫程序（例如，UNIX的<code>fsck</code>程序）来检查每个文件和目录以及块和索引节点空闲列表，查找并解决不一致的问题。清理大型文件系统可能需要数小时的时间，而且在某些情况下，无法以导致原始系统调用原子化的方式解决不一致问题。从日志中恢复要快得多，并且在崩溃时会导致系统调用原子化。</p>
<p>Xv6使用的索引节点和目录的基础磁盘布局与早期UNIX相同；这一方案多年来经久不衰。BSD的UFS&#x2F;FFS和Linux的ext2&#x2F;ext3使用基本相同的数据结构。文件系统布局中最低效的部分是目录，它要求在每次查找期间对所有磁盘块进行线性扫描。当目录只有几个磁盘块时，这是合理的，但对于包含许多文件的目录来说，开销巨大。Microsoft Windows的NTFS、Mac OS X的HFS和Solaris的ZFS（仅举几例）将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找在对数时间内完成（即时间复杂度为O(logn)）。</p>
<p>Xv6对于磁盘故障的解决很初级：如果磁盘操作失败，Xv6就会调用<code>panic</code>。这是否合理取决于硬件：如果操作系统位于使用冗余屏蔽磁盘故障的特殊硬件之上，那么操作系统可能很少看到故障，因此<code>panic</code>是可以的。另一方面，使用普通磁盘的操作系统应该预料到会出现故障，并能更优雅地处理它们，这样一个文件中的块丢失不会影响文件系统其余部分的使用。</p>
<p>Xv6要求文件系统安装在单个磁盘设备上，且大小不变。随着大型数据库和多媒体文件对存储的要求越来越高，操作系统正在开发各种方法来消除“每个文件系统一个磁盘”的瓶颈。基本方法是将多个物理磁盘组合成一个逻辑磁盘。RAID等硬件解决方案仍然是最流行的，但当前的趋势是在软件中尽可能多地实现这种逻辑。这些软件实现通常允许通过动态添加或删除磁盘来扩展或缩小逻辑设备等丰富功能。当然，一个能够动态增长或收缩的存储层需要一个能够做到这一点的文件系统：xv6使用的固定大小的inode块阵列在这样的环境中无法正常工作。将磁盘管理与文件系统分离可能是最干净的设计，但两者之间复杂的接口导致了一些系统（如Sun的ZFS）将它们结合起来。</p>
<p>Xv6的文件系统缺少现代文件系统的许多其他功能；例如，它缺乏对快照和增量备份的支持。 </p>
<p>现代Unix系统允许使用与磁盘存储相同的系统调用访问多种资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如<code>/proc</code>（注：Linux 内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。）。不同于xv6中<code>fileread</code>和<code>filewrite</code>的<code>if</code>语句，这些系统通常为每个打开的文件提供一个函数指针表，每个操作一个，并通过函数指针来援引inode的调用实现。网络文件系统和用户级文件系统提供了将这些调用转换为网络RPC并在返回之前等待响应的函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s13/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s13/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s13/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-13-文件描述符层"><a href="#8-13-文件描述符层" class="headerlink" title="8.13 文件描述符层"></a>8.13 文件描述符层</h1><p>Unix界面的一个很酷的方面是，Unix中的大多数资源都表示为文件，包括控制台、管道等设备，当然还有真实文件。文件描述符层是实现这种一致性的层。</p>
<p>正如我们在第1章中看到的，Xv6为每个进程提供了自己的打开文件表或文件描述符。每个打开的文件都由一个<code>struct file</code>（<em><strong>kernel&#x2F;file.h</strong></em>:1）表示，它是inode或管道的封装，加上一个I&#x2F;O偏移量。每次调用<code>open</code>都会创建一个新的打开文件（一个新的<code>struct file</code>）：如果多个进程独立地打开同一个文件，那么不同的实例将具有不同的I&#x2F;O偏移量。另一方面，单个打开的文件（同一个<code>struct file</code>）可以多次出现在一个进程的文件表中，也可以出现在多个进程的文件表中。如果一个进程使用<code>open</code>打开文件，然后使用<code>dup</code>创建别名，或使用<code>fork</code>与子进程共享，就会发生这种情况。引用计数跟踪对特定打开文件的引用数。可以打开文件进行读取或写入，也可以同时进行读取和写入。<code>readable</code>和<code>writable</code>字段可跟踪此操作。</p>
<p>系统中所有打开的文件都保存在全局文件表<code>ftable</code>中。文件表具有分配文件（<code>filealloc</code>）、创建重复引用（<code>filedup</code>）、释放引用（<code>fileclose</code>）以及读取和写入数据（<code>fileread</code>和<code>filewrite</code>）的函数。</p>
<p>前三个函数遵循现在熟悉的形式。<code>Filealloc</code>（<em><strong>kernel&#x2F;file.c</strong></em>:30）扫描文件表以查找未引用的文件（<code>f-&gt;ref == 0</code>），并返回一个新的引用；<code>filedup</code>（<em><strong>kernel&#x2F;file.c</strong></em>:48）增加引用计数；<code>fileclose</code>（<em><strong>kernel&#x2F;file.c</strong></em>:60）将其递减。当文件的引用计数达到零时，<code>fileclose</code>会根据<code>type</code>释放底层管道或inode。</p>
<p>函数<code>filestat</code>、<code>fileread</code>和<code>filewrite</code>实现对文件的<code>stat</code>、<code>read</code>和<code>write</code>操作。<code>Filestat</code>（<em><strong>kernel&#x2F;file.c</strong></em>:88）只允许在inode上操作并且调用了<code>stati</code>。<code>Fileread</code>和<code>filewrite</code>检查打开模式是否允许该操作，然后将调用传递给管道或inode的实现。如果文件表示inode，<code>fileread</code>和<code>filewrite</code>使用I&#x2F;O偏移量作为操作的偏移量，然后将文件指针前进该偏移量（<em><strong>kernel&#x2F;file.c</strong></em>:122-123）（<em><strong>kernel&#x2F;file.c</strong></em>:153-154）。管道没有偏移的概念。回想一下，inode的函数要求调用方处理锁（<em><strong>kernel&#x2F;file.c</strong></em>:94-96）（<em><strong>kernel&#x2F;file.c</strong></em>:121-124）（<em><strong>kernel&#x2F;file.c</strong></em>:163-166）。inode锁定有一个方便的副作用，即读取和写入偏移量以原子方式更新，因此，对同一文件的同时多次写入不能覆盖彼此的数据，尽管他们的写入最终可能是交错的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第八章-文件系统"><a href="#第八章-文件系统" class="headerlink" title="第八章 文件系统"></a>第八章 文件系统</h1><p>文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及持久性，以便在重新启动后数据仍然可用。</p>
<p>xv6文件系统提供类似于Unix的文件、目录和路径名（参见第1章），并将其数据存储在virtio磁盘上以便持久化（参见第4章）。文件系统解决了几个难题：</p>
<blockquote>
<p>注：完整计算机中的CPU被支撑硬件包围，其中大部分是以I&#x2F;O接口的形式。Xv6是以qemu的“-machine virt”选项模拟的支撑硬件编写的。这包括RAM、包含引导代码的ROM、一个到用户键盘&#x2F;屏幕的串行连接，以及一个用于存储的磁盘。</p>
</blockquote>
<ul>
<li>文件系统需要磁盘上的数据结构来表示目录和文件名称树，记录保存每个文件内容的块的标识，以及记录磁盘的哪些区域是空闲的。</li>
<li>文件系统必须支持崩溃恢复（crash recovery）。也就是说，如果发生崩溃（例如，电源故障），文件系统必须在重新启动后仍能正常工作。风险在于崩溃可能会中断一系列更新，并使磁盘上的数据结构不一致（例如，一个块在某个文件中使用但同时仍被标记为空闲）。</li>
<li>不同的进程可能同时在文件系统上运行，因此文件系统代码必须协调以保持不变量。</li>
<li>访问磁盘的速度比访问内存慢几个数量级，因此文件系统必须保持常用块的内存缓存。</li>
</ul>
<p>本章的其余部分将解释xv6如何应对这些挑战。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s9/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-9-真实世界"><a href="#7-9-真实世界" class="headerlink" title="7.9 真实世界"></a>7.9 真实世界</h1><p>xv6调度器实现了一个简单的调度策略：它依次运行每个进程。这一策略被称为轮询调度（round robin）。真实的操作系统实施更复杂的策略，例如，允许进程具有优先级。其思想是调度器将优先选择可运行的高优先级进程，而不是可运行的低优先级进程。这些策略可能变得很复杂，因为常常存在相互竞争的目标：例如，操作系统可能希望保证公平性和高吞吐量。此外，复杂的策略可能会导致意外的交互，例如优先级反转（priority inversion）和航队（convoys）。当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
<p>睡眠和唤醒是一种简单有效的同步方法，但还有很多其他方法。所有这些问题中的第一个挑战是避免我们在本章开头看到的“丢失唤醒”问题。原始Unix内核的<code>sleep</code>只是禁用了中断，这就足够了，因为Unix运行在单CPU系统上。因为xv6在多处理器上运行，所以它为<code>sleep</code>添加了一个显式锁。FreeBSD的<code>msleep</code>采用了同样的方法。Plan 9的<code>sleep</code>使用一个回调函数，该函数在马上睡眠时获取调度锁，并在运行中持有；该函数用于在最后时刻检查睡眠条件，以避免丢失唤醒。Linux内核的<code>sleep</code>使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有自己内部的锁。</p>
<p>在<code>wakeup</code>中扫描整个进程列表以查找具有匹配<code>chan</code>的进程效率低下。一个更好的解决方案是用一个数据结构替换<code>sleep</code>和<code>wakeup</code>中的<code>chan</code>，该数据结构包含在该结构上休眠的进程列表，例如Linux的等待队列。Plan 9的<code>sleep</code>和<code>wakeup</code>将该结构称为集结点（rendezvous point）或Rendez。许多线程库引用与条件变量相同的结构；在这种情况下，<code>sleep</code>和<code>wakeup</code>操作称为<code>wait</code>和<code>signal</code>。所有这些机制都有一个共同的特点：睡眠条件受到某种在睡眠过程中原子级释放的锁的保护。</p>
<p><code>wakeup</code>的实现会唤醒在特定通道上等待的所有进程，可能有许多进程在等待该特定通道。操作系统将安排所有这些进程，它们将竞相检查睡眠条件。进程的这种行为有时被称为惊群效应（thundering herd），最好避免。大多数条件变量都有两个用于唤醒的原语：<code>signal</code>用于唤醒一个进程；<code>broadcast</code>用于唤醒所有等待进程。</p>
<p>信号量（Semaphores）通常用于同步。计数count通常对应于管道缓冲区中可用的字节数或进程具有的僵尸子进程数。使用显式计数作为抽象的一部分可以避免“丢失唤醒”问题：使用显式计数记录已经发生<code>wakeup</code>的次数。计数还避免了虚假唤醒和惊群效应问题。</p>
<p>终止进程并清理它们在xv6中引入了很多复杂性。在大多数操作系统中甚至更复杂，因为，例如，受害者进程可能在内核深处休眠，而展开其栈空间需要非常仔细的编程。许多操作系统使用显式异常处理机制（如<code>longjmp</code>）来展开栈。此外，还有其他事件可能导致睡眠进程被唤醒，即使它等待的事件尚未发生。例如，当一个Unix进程处于休眠状态时，另一个进程可能会向它发送一个<code>signal</code>。在这种情况下，进程将从中断的系统调用返回，返回值为-1，错误代码设置为<code>EINTR</code>。应用程序可以检查这些值并决定执行什么操作。Xv6不支持信号，因此不会出现这种复杂性。</p>
<p>Xv6对<code>kill</code>的支持并不完全令人满意：有一些<code>sleep</code>循环可能应该检查<code>p-&gt;killed</code>。一个相关的问题是，即使对于检查<code>p-&gt;killed</code>的<code>sleep</code>循环，<code>sleep</code>和<code>kill</code>之间也存在竞争；后者可能会设置<code>p-&gt;killed</code>，并试图在受害者的循环检查<code>p-&gt;killed</code>之后但在调用<code>sleep</code>之前尝试唤醒受害者。如果出现此问题，受害者将不会注意到<code>p-&gt;killed</code>，直到其等待的条件发生。这可能比正常情况要晚一点（例如，当virtio驱动程序返回受害者正在等待的磁盘块时）或永远不会发生（例如，如果受害者正在等待来自控制台的输入，但用户没有键入任何输入）。</p>
<blockquote>
<p>注：上节中说到kill的工作方式，<code>kill</code>设置<code>p-&gt;killed</code>，如果遇到进程正在休眠，则会唤醒它，此后在<code>usertrap</code>中检测<code>p-&gt;killed</code>，并使进程退出</p>
</blockquote>
<blockquote>
<p>而如果像上面说的，在检查<code>p-&gt;killed</code>之后调用<code>sleep</code>之前唤醒受害者进程，那么接下来执行<code>sleep</code>就会导致进程无法进入内核，无法在<code>usertrap</code>中退出，而必须等待所需事件的发生再次唤醒</p>
</blockquote>
<p>一个实际的操作系统将在固定时间内使用空闲列表找到自由的<code>proc</code>结构体，而不是<code>allocproc</code>中的线性时间搜索；xv6使用线性扫描是为了简单起见。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c8/s1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s1/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c8/s1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h1><p>xv6文件系统实现分为七层，如图8.1所示。磁盘层读取和写入virtio硬盘上的块。缓冲区高速缓存层缓存磁盘块并同步对它们的访问，确保每次只有一个内核进程可以修改存储在任何特定块中的数据。日志记录层允许更高层在一次事务（transaction）中将更新包装到多个块，并确保在遇到崩溃时自动更新这些块（即，所有块都已更新或无更新）。索引结点层提供单独的文件，每个文件表示为一个索引结点，其中包含唯一的索引号（i-number）和一些保存文件数据的块。目录层将每个目录实现为一种特殊的索引结点，其内容是一系列目录项，每个目录项包含一个文件名和索引号。路径名层提供了分层路径名，如***&#x2F;usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c***，并通过递归查找来解析它们。文件描述符层使用文件系统接口抽象了许多Unix资源（例如，管道、设备、文件等），简化了应用程序员的工作。</p>
<table>
<thead>
<tr>
<th>文件描述符（File descriptor）</th>
</tr>
</thead>
<tbody><tr>
<td>路径名（Pathname）</td>
</tr>
<tr>
<td>目录（Directory）</td>
</tr>
<tr>
<td>索引结点（Inode）</td>
</tr>
<tr>
<td>日志（Logging）</td>
</tr>
<tr>
<td>缓冲区高速缓存（Buffer cache）</td>
</tr>
<tr>
<td>磁盘（Disk）</td>
</tr>
</tbody></table>
<p>​                    图8.1 XV6文件系统的层级</p>
<p>文件系统必须有将索引节点和内容块存储在磁盘上哪些位置的方案。为此，xv6将磁盘划分为几个部分，如图8.2所示。文件系统不使用块0（它保存引导扇区）。块1称为超级块：它包含有关文件系统的元数据（文件系统大小（以块为单位）、数据块数、索引节点数和日志中的块数）。从2开始的块保存日志。日志之后是索引节点，每个块有多个索引节点。然后是位图块，跟踪正在使用的数据块。其余的块是数据块：每个都要么在位图块中标记为空闲，要么保存文件或目录的内容。超级块由一个名为<code>mkfs</code>的单独的程序填充，该程序构建初始文件系统。</p>
<p><img src="/../images/c8/p1.png" alt="img"></p>
<p>本章的其余部分将从缓冲区高速缓存层开始讨论每一层。注意那些在较低层次上精心选择的抽象可以简化较高层次的设计的情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaoq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nPTQNF98hlhFVhx3uT28h3EW-gzGzoHsz',
      appKey     : 'Hj5CW3nJJnJ3rBlGeKK8XQLa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
