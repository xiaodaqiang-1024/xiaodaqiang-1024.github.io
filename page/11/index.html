<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="肖大强的个人博客">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="肖大强的个人博客">
<meta property="og:locale">
<meta property="article:author" content="xiaoq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>肖大强的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖大强的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c1/s3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s3/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h1><p>管道是作为一对文件描述符公开给进程的小型内核缓冲区，一个用于读取，一个用于写入。将数据写入管道的一端使得这些数据可以从管道的另一端读取。管道为进程提供了一种通信方式。</p>
<p>下面的示例代码使用连接到管道读端的标准输入来运行程序<code>wc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序调用<code>pipe</code>，创建一个新的管道，并在数组p中记录读写文件描述符。在<code>fork</code>之后，父子进程都有指向管道的文件描述符。子进程调用<code>close</code>和<code>dup</code>使文件描述符0指向管道的读取端（前面说过优先分配最小的未使用的描述符），然后关闭p中所存的文件描述符，并调用<code>exec</code>运行<code>wc</code>。当<code>wc</code>从它的标准输入读取时，就是从管道读取。父进程关闭管道的读取端，写入管道，然后关闭写入端。</p>
<p>如果没有可用的数据，则管道上的<code>read</code>操作将会进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭，在后一种情况下，<code>read</code>将返回0，就像到达数据文件的末尾一样。事实上，<code>read</code>在新数据不可能到达前会一直阻塞，这是子进程在执行上面的<code>wc</code>之前关闭管道的写入端非常重要的一个原因：如果wc的文件描述符之一指向管道的写入端，wc将永远看不到文件的结束。</p>
<p>Xv6 shell以类似于上面代码(<em><strong>user&#x2F;sh.c</strong></em>:100)的方式实现了诸如<code>grep fork sh.c | wc -l</code>之类的管道。子进程创建一个管道将管道的左端和右端连接起来。然后对管道的左端调用<code>fork</code>和<code>runcmd</code>，对管道的右端调用<code>fork</code>和<code>runcmd</code>，并等待两者都完成。管道的右端可能是一个命令，该命令本身包含一个管道(例如，<code>a | b | c</code>)，该管道本身<code>fork</code>为两个新的子进程(一个用于b，一个用于c)。因此，shell可以创建一个进程树。这个树的叶子是命令，内部节点是等待左右两个子进程完成的进程。</p>
<p>原则上，可以让内部节点在管道的左端运行，但是正确地这样做会使实现复杂化。考虑进行以下修改：将<em><strong>sh.c</strong></em>更改为不对<code>p-&gt;left</code>进行<code>fork</code>，并在内部进程中运行<code>runcmd(p-&gt;left)</code>。然后，例如，<code>echo hi | wc</code>将不会产生输出，因为当<code>echo hi</code>在<code>runcmd</code>中退出时，内部进程将退出，而不会调用<code>fork</code>来运行管道的右端。这个不正确的行为可以通过不调用内部进程的<code>runcmd</code>中的<code>exit</code>来修复，但是这个修复使代码复杂化：现在<code>runcmd</code>需要知道它是否是一个内部进程。同样的，当没有对<code>(p-&gt;right)</code>执行<code>fork</code>时也会更加复杂。例如，只需进行上述的修改，<code>sleep 10 | echo hi</code>将立即打印“hi”，而不是在10秒后，因为<code>echo</code>将立即运行并退出，而不是等待<code>sleep</code>完成。因为<em><strong>sh.c</strong></em>的目标是尽可能的简单，所以它不会试图避免创建内部进程。</p>
<p>管道看起来并不比临时文件更强大：下面的管道命令行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world | <span class="built_in">wc</span></span><br></pre></td></tr></table></figure>

<p>可以不通过管道实现，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world &gt; /tmp/xyz; <span class="built_in">wc</span> &lt; /tmp/xyz</span><br></pre></td></tr></table></figure>

<p>在这种情况下，管道相比临时文件至少有四个优势</p>
<ul>
<li><p>首先，管道会自动清理自己；在文件重定向时，shell使用完<code>/tmp/xyz</code>后必须小心删除</p>
</li>
<li><p>其次，管道可以任意传递长的数据流，而文件重定向需要磁盘上足够的空闲空间来存储所有的数据。</p>
</li>
<li><p>第三，管道允许并行执行管道阶段，而文件方法要求第一个程序在第二个程序启动之前完成。</p>
</li>
<li><p>第四，如果实现进程间通讯，管道的块读写比文件的非块语义更有效率。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c1/s4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s4/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h1><p>Xv6文件系统提供数据文件（包含未解释的字节数组）和目录（包含对数据文件和其他目录的命名引用）。这些目录形成一个树，从一个叫做根的特殊目录开始。像<code>/a/b/c</code>这样的路径是指在根目录<code>/</code>下名为<code>a</code>的目录中名为<code>b</code>的目录中名为<code>c</code>的文件或目录。不以<code>/</code>开始的路径相对于调用进程的当前工作目录进行计算，当前工作目录可以通过<code>chdir</code>系统调用进行更改。下面两个代码片段打开相同的文件(假设所有相关的目录都存在）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure>

<p>上面代码将进程的当前目录更改为<code>/a/b</code>；下面代码既不引用也不更改进程的当前目录</p>
<p>还有创建新文件和目录的系统调用：</p>
<ul>
<li><p><code>mkdir</code>创建一个新目录</p>
</li>
<li><p><code>open</code>中若使用<code>O_CREATE</code>标志将会创建一个新的数据文件</p>
</li>
<li><p><code>mknod</code>创建一个新的设备文件</p>
</li>
</ul>
<p>这个例子说明了这三点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>mknod</code>创建一个引用设备的特殊文件。与设备文件相关联的是主设备号和次设备号(<code>mknod</code>的两个参数)，它们唯一地标识了一个内核设备。当进程稍后打开设备文件时，内核将使用内核设备实现<code>read</code>和<code>write</code>系统调用，而不是使用文件系统。</p>
<p>一个文件的名字和文件本身是不同的;同一个底层文件（叫做inode，索引结点）可以有多个名字（叫做link，链接）。每个链接都由目录中的一个条目组成;该条目包含一个文件名和一个inode引用。Inode保存有关文件的元数据（用于解释或帮助理解信息的数据），包括其类型(文件&#x2F;目录&#x2F;设备)、长度、文件内容在磁盘上的位置以及指向文件的链接数。</p>
<p><code>fstat</code>系统调用从文件描述符所引用的inode中检索信息。它填充一个<code>stat</code>类型的结构体，<code>struct stat</code>在***stat.h(kernel&#x2F;stat.h)***中定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// 文件系统的磁盘设备</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode编号</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// 指向文件的链接数</span></span><br><span class="line">    uint64 size; <span class="comment">// 文件字节数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>link</code>系统调用创建另一个文件名，该文件名指向与现有文件相同的inode。下面的代码片段创建了一个名字既为<em><strong>a</strong></em>又为<em><strong>b</strong></em>的新文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从<em><strong>a</strong></em>读取或写入与从<em><strong>b</strong></em>读取或写入是相同的操作。每个inode由唯一的inode编号标识。在上面的代码序列之后，可以通过检查<code>fstat</code>的结果来确定a和b引用相同的底层内容:两者都将返回相同的inode号(<code>ino</code>)，并且<code>nlink</code>计数将被设置为2。</p>
<p><code>unlink</code>系统调用从文件系统中删除一个名称。只有当文件的链接数为零且没有文件描述符引用时，文件的inode和包含其内容的磁盘空间才会被释放，因此添加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最后一行代码序列中会使inode和文件内容可以作为b访问。此外</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>是创建没有名称的临时inode的惯用方法，该临时inode将在进程关闭fd或退出时被清理。</p>
<p>Unix以用户级程序的形式提供了可从shell调用的文件实用程序，例如<code>mkdir</code>、<code>ln</code>和<code>rm</code>。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。事后看来，这个计划似乎是显而易见的，但是在Unix时代设计的其他系统经常将这样的命令构建到shell中(并将shell构建到内核中)</p>
<p>一个例外是<code>cd</code>，它是内置在shell(<em><strong>user&#x2F;sh.c</strong></em>:160)。<code>cd</code>必须更改shell本身的当前工作目录。如果<code>cd</code>作为常规命令运行，那么shell将分出一个子进程，子进程将运行<code>cd</code>，<code>cd</code>将更改子进程的工作目录。父目录(即shell的)的工作目录不会改变。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c1/s5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s5/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-5-真实世界"><a href="#1-5-真实世界" class="headerlink" title="1.5 真实世界"></a>1.5 真实世界</h1><p>Unix将“标准”文件描述符、管道和方便的shell语法结合起来进行操作，这是编写通用可重用程序方面的一大进步。这个想法引发了一种“软件工具”的文化，这种文化对Unix的强大和流行做出了卓越贡献，shell是第一个所谓的“脚本语言”。Unix系统调用接口今天仍然存在于BSD、Linux和MacOSx等系统中。</p>
<p>Unix系统调用接口已经通过便携式操作系统接口(POSIX)标准进行了标准化。Xv6与POSIX不兼容:它缺少许多系统调用(包括lseek等基本系统调用)，并且它提供的许多系统调用与标准不同。我们xv6的主要目标是简单明了，同时提供一个简单的类unix系统调用接口。为了运行基本的Unix程序，有些人扩展了xv6，增加了一些系统调用和一个简单的c库。然而，现代内核比xv6提供了更多的系统调用和更多种类的内核服务。例如，它们支持网络工作、窗口系统、用户级线程、许多设备的驱动程序等等。现代内核不断快速发展，提供了许多超越POSIX的特性。</p>
<p>Unix通过一组文件名和文件描述符接口统一访问多种类型的资源(文件、目录和设备)。这个想法可以扩展到更多种类的资源;一个很好的例子是Plan9，它将“资源是文件”的概念应用到网络、图形等等。然而，大多数unix衍生的操作系统并没有遵循这条路。</p>
<p>文件系统和文件描述符是强大的抽象。即便如此，还有其他的操作系统接口模型。Multics，Unix的前身，以一种看起来像内存的方式抽象了文件存储，产生了一种非常不同的接口风格。Multics设计的复杂性直接影响了Unix的设计者，他们试图使设计更简单。</p>
<p>Xv6没有提供一个用户概念或者保护一个用户不受另一个用户的伤害;用Unix的术语来说，所有的Xv6进程都作为root运行。</p>
<p>本书研究了xv6如何实现其类Unix接口，但这些思想和概念不仅仅适用于Unix。任何操作系统都必须在底层硬件上复用进程，彼此隔离进程，并提供受控制的进程间通讯机制。在学习了xv6之后，你应该去看看更复杂的操作系统，以及这些系统中与xv6相同的底层基本概念。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/summary/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/summary/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/summary/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BOOK-RISCV-REV1"><a href="#BOOK-RISCV-REV1" class="headerlink" title="BOOK-RISCV-REV1"></a>BOOK-RISCV-REV1</h1><p>XV6：一个简单，类UNIX的教学用操作系统</p>
<p>本书是6.S081最重要的参考书目，其中详细的介绍了XV6的设计细节，在课程前往往需要阅读对应章节，做实验时也要回来查看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c1/s0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c1/s0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-操作系统接口"><a href="#第一章-操作系统接口" class="headerlink" title="第一章 操作系统接口"></a>第一章 操作系统接口</h1><p>操作系统的任务是在多个程序之间共享一台计算机，并提供比硬件本身支持的更有用的服务。操作系统管理和抽象底层硬件，例如文字处理器不需要关心使用哪种类型的磁盘硬件。一个操作系统在多个程序之间共享硬件，这样它们就可以(或者看起来可以)同时运行。最后，操作系统为程序提供了可控的交互方式，这样它们就可以共享数据或者一起工作。</p>
<p>操作系统通过接口向用户程序提供服务。设计良好的接口是很困难的。一方面，我们希望接口简单明了，因为这样更利于正确使用。另一方面，我们可能倾向于为应用程序提供许多复杂的特性。解决这个问题的诀窍在于设计接口时，依赖一些可结合的机制，以此来提供更好的通用性。</p>
<p>本书使用单一的操作系统作为具体的例子来说明操作系统的概念。xv6这个操作系统提供了Ken Thompson和Dennis Ritchie的Unix 介绍的基本接口，并且模仿了Unix的内部设计。Unix提供了一个窄接口，其机制表现突出，提供了令人惊讶的通用程度。这个接口非常成功，甚至现代操作系统BSD、Linux、Mac OSX、Solaris，甚至在一定程度上，Microsoft windows都有类Unix的接口。理解xv6是理解这些系统和其他系统的一个良好开端。</p>
<p>如下图1.1所示，xv6采用传统的内核形式（内核是一个特殊的程序，为正在运行的程序提供服务）。每个正在运行的程序，称为进程，都有包含指令、数据和堆栈的内存。指令实现了程序的运算，数据是计算所依赖的变量，堆栈组织程序的过程调用。一台给定的计算机通常有许多进程，但只有一个内核。</p>
<p><img src="/../images/c1/p1.png" alt="img"></p>
<p>当一个进程需要调用一个内核服务时，它会调用一个系统调用，这是操作系统接口中的一个调用。系统调用进入内核；内核执行服务并返回。因此，一个进程在用户空间和内核空间之间交替执行。</p>
<p>内核使用CPU提供的硬件保护机制来确保每个在用户空间执行的进程只能访问它自己的内存。内核程序的执行拥有操控硬件的权限，它需要实现这些保护；而用户程序执行时没有这些特权。当用户程序调用系统调用时，硬件会提升权限级别，并开始执行内核中预先安排好的函数。</p>
<p>内核提供的系统调用集合是用户程序看到的接口。Xv6内核提供了Unix内核传统上提供的服务和系统调用的子集。表1.2列出了xv6的所有系统调用。</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>int fork()</code></td>
<td>创建一个进程，返回子进程的PID</td>
</tr>
<tr>
<td><code>int exit(int status)</code></td>
<td>终止当前进程，并将状态报告给wait()函数。无返回</td>
</tr>
<tr>
<td><code>int wait(int *status)</code></td>
<td>等待一个子进程退出; 将退出状态存入*status; 返回子进程PID。</td>
</tr>
<tr>
<td><code>int kill(int pid)</code></td>
<td>终止对应PID的进程，返回0，或返回-1表示错误</td>
</tr>
<tr>
<td><code>int getpid()</code></td>
<td>返回当前进程的PID</td>
</tr>
<tr>
<td><code>int sleep(int n)</code></td>
<td>暂停n个时钟节拍</td>
</tr>
<tr>
<td><code>int exec(char *file, char *argv[])</code></td>
<td>加载一个文件并使用参数执行它; 只有在出错时才返回</td>
</tr>
<tr>
<td><code>char *sbrk(int n)</code></td>
<td>按n 字节增长进程的内存。返回新内存的开始</td>
</tr>
<tr>
<td><code>int open(char *file, int flags)</code></td>
<td>打开一个文件；flags表示read&#x2F;write；返回一个fd（文件描述符）</td>
</tr>
<tr>
<td><code>int write(int fd, char *buf, int n)</code></td>
<td>从buf 写n 个字节到文件描述符fd; 返回n</td>
</tr>
<tr>
<td><code>int read(int fd, char *buf, int n)</code></td>
<td>将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0</td>
</tr>
<tr>
<td><code>int close(int fd)</code></td>
<td>释放打开的文件fd</td>
</tr>
<tr>
<td><code>int dup(int fd)</code></td>
<td>返回一个新的文件描述符，指向与fd 相同的文件</td>
</tr>
<tr>
<td><code>int pipe(int p[])</code></td>
<td>创建一个管道，把read&#x2F;write文件描述符放在p[0]和p[1]中</td>
</tr>
<tr>
<td><code>int chdir(char *dir)</code></td>
<td>改变当前的工作目录</td>
</tr>
<tr>
<td><code>int mkdir(char *dir)</code></td>
<td>创建一个新目录</td>
</tr>
<tr>
<td><code>int mknod(char *file, int, int)</code></td>
<td>创建一个设备文件</td>
</tr>
<tr>
<td><code>int fstat(int fd, struct stat *st)</code></td>
<td>将打开文件fd的信息放入*st</td>
</tr>
<tr>
<td><code>int stat(char *file, struct stat *st)</code></td>
<td>将指定名称的文件信息放入*st</td>
</tr>
<tr>
<td><code>int link(char *file1, char *file2)</code></td>
<td>为文件file1创建另一个名称(file2)</td>
</tr>
<tr>
<td><code>int unlink(char *file)</code></td>
<td>删除一个文件</td>
</tr>
</tbody></table>
<p>​		表1.2：xv6系统调用（除非另外声明，这些系统调用返回0表示无误，返回-1表示出错）</p>
<hr>
<p>本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并用代码片段和关于shell（Unix的命令行用户界面）如何使用它们的讨论来阐释。Shell对系统调用的使用说明了它们是如何被精心设计的。</p>
<p>Shell是一个普通的程序，它从用户那里读取命令并执行它们。Shell是一个用户程序，而不是内核的一部分，这一事实说明了系统调用接口的强大之处：shell没有什么特别之处。这也意味着shell很容易替换；因此，现代Unix系统有多种shell可供选择，每种shell都有自己的用户界面和脚本特性。Xv6 Shell是Unix Bourne shell本质的简单实现。它的实现可以在(user&#x2F;sh.c:1)中找到.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/Calling%20Convention/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/Calling%20Convention/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/Calling%20Convention/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/Calling%20Convention/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Calling-Convention"><a href="#Calling-Convention" class="headerlink" title="Calling Convention"></a>Calling Convention</h1><p>本章描述了RV32和RV64程序的C编译器标准和两个调用约定：附加标准通用扩展（RV32G&#x2F;RV64G）的基础ISA约定，以及缺乏浮点单元（例如RV32I&#x2F;RV64I）实现的软浮点约定。</p>
<blockquote>
<p>使用ISA扩展的实现可能需要扩展调用约定。</p>
</blockquote>
<h1 id="18-1-C语言的数据类型和对齐方式"><a href="#18-1-C语言的数据类型和对齐方式" class="headerlink" title="18.1 C语言的数据类型和对齐方式"></a>18.1 C语言的数据类型和对齐方式</h1><p>表18.1总结了RISC-V C程序本机支持的数据类型。在RV32和RV64 C编译器中，C中的<code>int</code>类型都是32位。另一方面，<code>long</code>和指针都与整数寄存器位数一致，所以在RV32中，两者都是32位，而在RV64中，两者都是64位。同样，RV32采用ILP32整数模型，而RV64是LP64。在RV32和RV64中，C类型<code>long long</code>是64位整数，<code>float</code>是遵循IEEE754-2008标准的32位浮点数，<code>double</code>是遵循IEEE754-2008标准的64位浮点数，<code>long double</code>是遵循IEEE754-2008标准的128位浮点数。</p>
<p>C类型<code>char</code>和<code>unsigned char</code>都是8位无符号整数，当存储在RISC-V整数寄存器中时是零扩展。<code>unsigned short</code>是16位无符号整数，当存储在RISC-V整数寄存器中时是零扩展。<code>signed char</code>是8位有符号整数，当存储在RISC-V整数寄存器中时是符号扩展的，即比特位从（XLEN-1）到7都是相等的。<code>short</code>是16位有符号整数，当存储在寄存器中时是符号扩展的。</p>
<p>在RV64中，32位的数据类型（如<code>int</code>）以合适的符号扩展存储在整数寄存器中；也就是说，比特位从63到31都是相等的。即使是无符号的32位类型，这个限制也适用。</p>
<p>RV32和RV64 C编译器和兼容软件将所有上述数据类型存储在内存中时保持自然对齐。</p>
<table>
<thead>
<tr>
<th><strong>C数据类型</strong></th>
<th><strong>描述</strong></th>
<th><strong>RV32中字节数</strong></th>
<th><strong>RV64中字节数</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>char</code></td>
<td>字符值&#x2F;字节</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>short</code></td>
<td>短整型</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>int</code></td>
<td>整型</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>long</code></td>
<td>长整型</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td><code>long long</code></td>
<td>超长整型</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>void*</code></td>
<td>指针</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点型</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点型</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>long double</code></td>
<td>扩展精度浮点型</td>
<td>16</td>
<td>16</td>
</tr>
</tbody></table>
<p>表18.1：基于RISC-V指令集的C编译器数据类型</p>
<h1 id="18-2-RVG调用协定"><a href="#18-2-RVG调用协定" class="headerlink" title="18.2 RVG调用协定"></a>18.2 RVG调用协定</h1><p>RISC-V调用约定尽可能在寄存器中传递参数。为此，最多使用八个整数寄存器<strong>a0</strong>-<strong>a7</strong>和八个浮点寄存器<strong>fa0</strong>-<strong>fa7</strong>。</p>
<p>如果函数的参数被概念化为C结构体的字段，结构体中的每个字段都按指针长度对齐，则参数寄存器是该结构体中前八个指针字长参数的副本。如果第i(i&lt;8)个参数是浮点类型，则在浮点寄存器<strong>fai</strong>中传递；否则，在整数寄存器<strong>ai</strong>中传递。但是，浮点参数如果属于<code>union</code>或结构体中数组字段的一部分，就会在整数寄存器中传递。此外，变参函数的浮点参数（未显式命名参数列表的函数）在整数寄存器中传递。</p>
<p>小于指针字长的参数在参数寄存器的最低有效位(LSB)中传递。相应地，栈上传递的小于指针字长的参数出现在指针字的较低地址中，因为RISC-V有一个小端存储系统。</p>
<p>当在堆栈上传递两倍于指针字大小的基本参数时，它们是自然对齐的。当它们在整数寄存器中传递时，它们驻留在对齐的偶数号-奇数号寄存器对中，偶数寄存器保存最低有效位。例如，在RV32中，函数<code>void foo(int, long long)</code>的第一个参数在<strong>a0</strong>中传递，第二个参数在<strong>a2</strong>和<strong>a3</strong>中传递。<strong>a1</strong>中不传递任何内容。</p>
<p>大于指针字大小两倍的参数通过引用传递。</p>
<p>结构体中未在参数寄存器中传递的部分在栈上传递。栈指针<strong>sp</strong>指向未在寄存器中传递的第一个参数。</p>
<p>函数在整数寄存器<strong>a0</strong>和<strong>a1</strong>以及浮点寄存器<strong>fa0</strong>和<strong>fa1</strong>中返回值。只有当浮点值是原始值（传入时<strong>fa0</strong>和<strong>fa1</strong>作为参数寄存器，原始值是指该参数不改变而直接返回）或作为仅有一两个浮点值组成的结构体的成员时，才会从浮点寄存器中返回。长度恰好为两个指针字长的其他返回值将在<strong>a0</strong>和<strong>a1</strong>中返回。较大的返回值完全在内存中传递；调用方分配此内存区域，并将指针作为隐式的第一个参数传递给被调用方。</p>
<p>在标准的RISC-V调用约定中，栈向下增长，栈指针始终保持16字节对齐。</p>
<p>除了自变量和返回值寄存器之外，还有在调用中不稳定的七个整数寄存器<strong>t0</strong>-<strong>t6</strong>和十二个浮点寄存器<strong>ft0</strong>-<strong>ft11</strong>作为临时寄存器，如果之后使用，调用者必须保存它们。十二个整数寄存器<strong>s0</strong>-<strong>s11</strong>和十二个浮点寄存器<strong>fs0</strong>-<strong>fs11</strong>在调用中受保护，如果使用，被调用者必须保存它们。表18.2显示了调用约定中每个整数和浮点寄存器的作用。</p>
<table>
<thead>
<tr>
<th><strong>寄存器</strong></th>
<th><strong>ABI名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>保存者</strong></th>
</tr>
</thead>
<tbody><tr>
<td>x0</td>
<td>zero</td>
<td>硬布线零</td>
<td></td>
</tr>
<tr>
<td>x1</td>
<td>ra</td>
<td>返回地址</td>
<td>调用者</td>
</tr>
<tr>
<td>x2</td>
<td>sp</td>
<td>栈指针</td>
<td>被调用者</td>
</tr>
<tr>
<td>x3</td>
<td>gp</td>
<td>全局指针</td>
<td></td>
</tr>
<tr>
<td>x4</td>
<td>tp</td>
<td>线程指针</td>
<td></td>
</tr>
<tr>
<td>x5-7</td>
<td>t0-2</td>
<td>临时暂存单元</td>
<td>调用者</td>
</tr>
<tr>
<td>x8</td>
<td>s0&#x2F;fp</td>
<td>保留寄存器&#x2F;帧指针</td>
<td>被调用者</td>
</tr>
<tr>
<td>x9</td>
<td>s1</td>
<td>保留寄存器</td>
<td>被调用者</td>
</tr>
<tr>
<td>x10-11</td>
<td>a0-1</td>
<td>函数参数&#x2F;返回值</td>
<td>调用者</td>
</tr>
<tr>
<td>x12-17</td>
<td>a2-7</td>
<td>函数参数</td>
<td>调用者</td>
</tr>
<tr>
<td>x18-27</td>
<td>s2-11</td>
<td>保留寄存器</td>
<td>被调用者</td>
</tr>
<tr>
<td>x28-31</td>
<td>t3-6</td>
<td>临时暂存单元</td>
<td>调用者·</td>
</tr>
<tr>
<td>f0-7</td>
<td>ft0-7</td>
<td>浮点临时暂存单元</td>
<td>调用者</td>
</tr>
<tr>
<td>f8-9</td>
<td>fs0-1</td>
<td>浮点保留寄存器</td>
<td>被调用者</td>
</tr>
<tr>
<td>f10-11</td>
<td>fa0-1</td>
<td>浮点参数&#x2F;返回值</td>
<td>调用者</td>
</tr>
<tr>
<td>f12-17</td>
<td>fa2-7</td>
<td>浮点参数</td>
<td>调用者</td>
</tr>
<tr>
<td>f18-27</td>
<td>fs2-11</td>
<td>浮点保留寄存器</td>
<td>被调用者</td>
</tr>
<tr>
<td>f28-31</td>
<td>ft8-11</td>
<td>浮点临时暂存单元</td>
<td>调用者</td>
</tr>
</tbody></table>
<p>表18.2 RISC-V调用协定寄存器的使用</p>
<h1 id="18-3-软浮点数调用协定"><a href="#18-3-软浮点数调用协定" class="headerlink" title="18.3 软浮点数调用协定"></a>18.3 软浮点数调用协定</h1><p>软浮点调用约定用于缺乏浮点硬件的RV32和RV64实现。它避免使用了F、D和Q标准扩展中的所有指令，从而避免使用<strong>f</strong>寄存器。</p>
<p>完整参数的传递和返回方式与RVG约定相同，栈规则也相同。浮点参数使用长度相同的整型参数的规则在整数寄存器中传递和返回。例如，在RV32中，函数<code>double foo(int, double, long double)</code>的第一个参数在<strong>a0</strong>中传递，第二个参数在<strong>a2</strong>和<strong>a3</strong>中传递，第三个参数通过<strong>a4</strong>传递引用；其结果在<strong>a0</strong>和<strong>a1</strong>中返回。在RV64中，参数以<strong>a0</strong>、<strong>a1</strong>和<strong>a2</strong>-<strong>a3</strong>对形式传递，结果以<strong>a0</strong>形式返回。</p>
<p>动态舍入模式和累计异常标志可以通过C99头文件<em><strong>fenv.h</strong></em>提供的程序访问。</p>
<blockquote>
<p>注：为了编写高精度浮点数的运算，编程人员需要控制浮点数环境的各个方面：结果如何舍入，浮点数表达式如何简化与变换，如何处理浮点数异常（如下溢之类的浮点数异常是忽略还是产生错误）等等。C99引入了<em><strong>fenv.h</strong></em>来控制浮点数环境。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/Introduction/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/Introduction/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/Introduction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h1 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h1><p>6.S081 2020 Lecture 1: OS概述</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>6.S081目标</p>
<ul>
<li>了解操作系统(OS)的设计和实现</li>
</ul>
</li>
<li><p>动手扩展小型操作系统的实践经验</p>
</li>
<li><p>有编写系统软件的实际操作经验</p>
</li>
<li><p>操作系统的目的是什么?</p>
<ul>
<li>为方便和可移植性而对硬件进行抽象</li>
</ul>
</li>
<li><p>在多种应用中实现硬件的多路复用</p>
</li>
<li><p>隔离应用程序，多个程序互不干扰</p>
</li>
<li><p>允许在合作的应用程序之间共享</p>
</li>
<li><p>控制共享安全</p>
</li>
<li><p>不要妨碍高效</p>
</li>
<li><p>支持广泛的应用</p>
</li>
<li><p>组织方式:分层结构</p>
<ul>
<li>用户应用层:vi、gcc、DB和c</li>
</ul>
</li>
<li><p>内核服务层</p>
</li>
<li><p>硬件层: CPU、RAM、磁盘、网络等</p>
</li>
</ul>
<p>我们非常关心接口和内部内核结构</p>
<ul>
<li><p>操作系统内核通常提供什么服务?</p>
<ul>
<li>进程(一个正在运行的程序)</li>
</ul>
</li>
<li><p>内存分配</p>
</li>
<li><p>文件内容</p>
</li>
<li><p>文件名，目录</p>
</li>
<li><p>访问控制(安全性)</p>
</li>
<li><p>其他:用户、IPC（进程间通信）、网络、时间、终端</p>
</li>
<li><p>什么是应用程序&#x2F;内核接口?</p>
<ul>
<li>“系统调用”</li>
</ul>
</li>
<li><p>例子，在UNIX(如Linux, macOS, FreeBSD)中的C语言中:</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;out&quot;</span>, <span class="number">1</span>);</span><br><span class="line">write(fd, <span class="string">&quot;hello\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">pid = fork();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这些看起来像函数调用，但实际上不是</p>
</li>
<li><p>为什么操作系统的设计和实现是困难和有趣的?</p>
<ul>
<li>恶劣的环境:古怪的硬件，很难调试</li>
</ul>
</li>
<li><p>许多设计张力:</p>
<ul>
<li>高效vs抽象&#x2F;便携&#x2F;通用</li>
</ul>
</li>
<li><p>强大的vs简单的接口</p>
</li>
<li><p>灵活vs安全</p>
</li>
<li><p>功能交互:’fd &#x3D; open(); fork()&#96;</p>
</li>
<li><p>用途多种多样:笔记本电脑、智能手机、云计算、虚拟机、嵌入式</p>
</li>
<li><p>不断发展的硬件:NVRAM、多核、高速网络</p>
</li>
<li><p>你会很高兴你选了这门课，如果你…</p>
<ul>
<li>关心计算机运行的背后发生了什么</li>
</ul>
</li>
<li><p>喜欢基础架构</p>
</li>
<li><p>需要追踪漏洞或安全问题</p>
</li>
<li><p>注重高性能</p>
</li>
</ul>
<h2 id="课程结构"><a href="#课程结构" class="headerlink" title="课程结构"></a>课程结构</h2><ul>
<li>网上课程信息:</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/">6.S081官网</a>，网站中包含了课程表，作业，实验</p>
<p><a target="_blank" rel="noopener" href="https://piazza.com/">Piazza</a>：公告，讨论，实验帮助</p>
<ul>
<li><p>视频课程</p>
<ul>
<li>操作系统的想法</li>
</ul>
</li>
<li><p>通过代码和xv6的书，xv6（一个小的操作系统）的案例研究</p>
</li>
<li><p>实验背景</p>
</li>
<li><p>操作系统相关论文</p>
</li>
<li><p>上课前提交一个关于阅读材料的问题。</p>
</li>
<li><p>实验:</p>
<ul>
<li>重点是:实践经验（基本上每个星期一个实验）</li>
</ul>
</li>
<li><p>实验的三种类型:</p>
<ul>
<li>系统编程(下周截止…)</li>
</ul>
</li>
<li><p>OS原语，例如线程切换。</p>
</li>
<li><p>xv6的OS内核扩展，例如网络。</p>
</li>
<li><p>使用piazza提问&#x2F;回答实验室的问题。</p>
</li>
<li><p>讨论很好，但请不要看别人的解决方案!</p>
</li>
<li><p>评分:</p>
<ul>
<li>70%的实验室，基于测试(与运行的测试相同)。</li>
</ul>
</li>
<li><p>20%的实验室检查会议:我们会问你关于随机选择的实验室的问题。</p>
</li>
<li><p>10%的家庭作业和课堂&#x2F;广场讨论。</p>
</li>
<li><p>没有考试，没有小测验。</p>
</li>
<li><p>请注意，大部分成绩来自实验室，请尽早开始!</p>
</li>
</ul>
<h2 id="UNIX系统调用简介"><a href="#UNIX系统调用简介" class="headerlink" title="UNIX系统调用简介"></a>UNIX系统调用简介</h2><ul>
<li><p>应用程序通过系统调用查看操作系统;这种接口将是我们关注的重点。</p>
<ul>
<li>让我们从查看程序如何使用系统调用开始。</li>
</ul>
</li>
<li><p>您将在第一个实验室中使用这些系统调用。</p>
</li>
<li><p>并在随后的实验室中进行扩展和改进。</p>
</li>
<li><p>我将展示一些示例，并在xv6上运行它们。</p>
</li>
</ul>
<p>xv6的结构与UNIX系统(如Linux)类似。但是要简单得多——您将能够理解xv6的全部内容附带的书解释了xv6的工作原理和原因</p>
<ul>
<li><p>为什么选择UNIX ?</p>
<ul>
<li>开源代码，有良好的文档，干净的设计，广泛使用</li>
</ul>
</li>
<li><p>如果您需要了解Linux内部，学习xv6将有所帮助</p>
</li>
<li><p>xv6在6.S081中有两个角色:</p>
<ul>
<li>核心函数的例子:虚拟内存，多核，中断，等等</li>
</ul>
</li>
<li><p>大多数实验的起点</p>
</li>
<li><p>xv6运行在RISC-V上，就像当前的6.004一样</p>
</li>
<li><p>您将在qemu机器仿真器下运行xv6</p>
</li>
</ul>
<h3 id="例子-copy-c：复制输入到输出"><a href="#例子-copy-c：复制输入到输出" class="headerlink" title="例子:copy.c：复制输入到输出"></a>例子:<code>copy.c</code>：复制输入到输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(n &amp;lt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">write(<span class="number">1</span>, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>从输入中读取字节，并将其写入输出</p>
<p><code>copy.c</code>是用C语言写的，克尼根和里奇(K&amp;R)的《C程序设计语言》可以帮助你学习C语言，另外你可以通过官网上时间表中的<code>example</code>指向的链接找到这些示例程序</p>
<p>其中<code>read()</code>和<code>write()</code>是系统调用</p>
<ul>
<li>read()&#x2F;write()的第一个参数是一个“文件描述符”(fd)</li>
</ul>
<blockquote>
<p>它传递给内核，告诉系统调用要读&#x2F;写哪个“打开的文件”，fd必须是已经打开过的，可以指向文件&#x2F;设备&#x2F;套接字等等。一个进程可以打开很多文件，有很多<code>fd</code>，UNIX约定:fd 0是“标准输入”，1是“标准输出”</p>
</blockquote>
<ul>
<li><p>第二个read()参数是一个指向要读取的内存的指针</p>
</li>
<li><p>第三个参数是要读取的最大字节数</p>
</li>
</ul>
<blockquote>
<p>read()可以读得更少，但不能读得更多</p>
</blockquote>
<ul>
<li>返回值:实际读取的字节数，或-1表示错误</li>
</ul>
<blockquote>
<p>注意:copy.c不关心数据的格式，UNIX I&#x2F;O是8位字节，解释是特定于应用程序的，例如数据库记录，C源，等等</p>
</blockquote>
<p>文件描述符来自哪里?</p>
<h3 id="例子-open-c，创建一个文件"><a href="#例子-open-c，创建一个文件" class="headerlink" title="例子:open.c，创建一个文件"></a>例子:<code>open.c</code>，创建一个文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open.c: create a file, write to it.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREATE);</span><br><span class="line">  write(fd, <span class="string">&quot;ooo\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>open()</code>创建文件，返回文件描述符fd(或-1表示错误)，<code>fd</code>是一个短整数，<code>fd</code>索引到内核维护的每个进程表中</p>
<p>不同的进程具有不同的<code>fd</code>命名空间，也就是说，文件描述符1对于不同的进程通常意味着不同的东西，然而这些例子忽略了可能的错误——但你不要这么草率!</p>
<p>《xv6》中的图1.2列出了系统调用的参数、返回值，或者你查看UNIX手册页，例如。<code>man 2 open</code></p>
<ul>
<li>当程序调用像open()这样的系统调用时会发生什么?</li>
</ul>
<p><code>open</code>看起来像一个函数调用，但实际上是一个特殊的指令</p>
<ol>
<li>硬件保存一些用户寄存器</li>
<li>硬件增加特权级别</li>
<li>硬件会跳转到内核中一个已知的“入口点”</li>
<li>现在在内核中运行C代码</li>
<li>内核调用系统调用执行<ul>
<li>open()在文件系统中查找文件名</li>
<li>它可能会等待磁盘</li>
<li>它更新内核数据结构(缓存，FD表)</li>
</ul>
</li>
<li>恢复用户寄存器</li>
<li>减少特权级别</li>
<li>回到程序中的调用点，它将继续运行</li>
</ol>
<p>我们将在后面的课程中看到更多细节</p>
<ul>
<li>Shell是UNIX系统上的命令行界面。</li>
</ul>
<p> shell会打印“$”提示符提示输入命令，它允许您运行UNIX命令行实用程序，这对系统管理、文件处理、开发、脚本编写非常有用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">$ <span class="built_in">ls</span> &gt; out</span><br><span class="line">$ grep x &lt; out</span><br></pre></td></tr></table></figure>

<p>UNIX也支持其他类型的交互,例如窗口系统，图形用户界面，服务器，路由器，等等。但是，通过shell实现分时是UNIX最初的重点。我们可以通过shell执行许多系统调用。</p>
<h3 id="例子：fork-c：创建一个新的过程"><a href="#例子：fork-c：创建一个新的过程" class="headerlink" title="例子：fork.c：创建一个新的过程"></a>例子：<code>fork.c</code>：创建一个新的过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork.c: create a new process</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork() returned %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell会为您键入的每个命令创建一个新进程，例如，对于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello</span><br></pre></td></tr></table></figure>

<p>来说<code>fork()</code>系统调用创建一个新进程，内核复制调用进程的指令、数据、寄存器、文件描述符、当前目录</p>
<p>“父进程”和“子进程”的唯一的区别是:<code>fork()</code>在父进程中返回pid，在子进程中返回0，pid(进程ID)是一个整数，内核给每个进程一个不同的pid</p>
<p>因此:<code>fork.c</code>的<code>printf(&quot;fork() returned %d\n&quot;, pid);</code>会在父子两个进程中执行</p>
<p>“<code>if(pid == 0)</code>”允许代码进行区分父子进程</p>
<p>fork让我们创建一个新进程，那么我们如何在这个进程中运行一个程序呢?</p>
<h3 id="例子-exec-c：用可执行文件替换调用进程"><a href="#例子-exec-c：用可执行文件替换调用进程" class="headerlink" title="例子:exec.c：用可执行文件替换调用进程"></a>例子:<code>exec.c</code>：用可执行文件替换调用进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exec.c: replace a process with an executable file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell是如何运行程序的?例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a b c</span><br></pre></td></tr></table></figure>

<p>程序存储在一个文件中，指令和初始内存由编译器和链接器创建</p>
<p>有一个叫echo的文件，包含指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<p><code>echo.c</code>文件内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &amp;lt; argc; i++)&#123;</span><br><span class="line">    write(<span class="number">1</span>, argv[i], <span class="built_in">strlen</span>(argv[i]));</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &amp;lt; argc)&#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>exec()</code>系统调用</p>
<ul>
<li>用可执行文件替换当前进程</li>
<li>丢弃指令和数据存储器</li>
<li>从文件中加载指令和内存</li>
<li>保存文件描述符</li>
</ul>
</li>
<li><p><code>exec(filename, argument-array)</code></p>
<ul>
<li>argument-array保存命令行参数;exec将参数传递给main()</li>
<li>执行<code>cat user/echo.c</code></li>
<li><code>echo.c</code>程序演示了如何查看命令行参数</li>
</ul>
</li>
</ul>
<h3 id="例子-forkexec-c。fork-一个新进程，exec-一个程序"><a href="#例子-forkexec-c。fork-一个新进程，exec-一个程序" class="headerlink" title="例子:forkexec.c。fork()一个新进程，exec()一个程序"></a>例子:<code>forkexec.c</code>。<code>fork()</code>一个新进程，<code>exec()</code>一个程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forkexec.c: fork then exec</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, status;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;THIS&quot;</span>, <span class="string">&quot;IS&quot;</span>, <span class="string">&quot;ECHO&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent waiting\n&quot;</span>);</span><br><span class="line">    wait(&amp;amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the child exited with status %d\n&quot;</span>, status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>forkexec.c</code>包含一个常见的UNIX习惯用法:</p>
<ul>
<li>fork()一个子进程</li>
<li>exec()子进程中的命令</li>
<li>父进程调用<code>wait()</code>等待子进程结束</li>
</ul>
</li>
<li><p>对于您键入的每个命令，shell都会fork&#x2F;exec&#x2F;wait</p>
<ul>
<li>在<code>wait()</code>完成之后，shell打印下一个提示符</li>
<li>若想让程序在后台运行，可在命令的最后加上符号<code>&amp;</code>，这样shell会跳过<code>wait()</code></li>
</ul>
</li>
<li><p><code>exec(status)</code>-&gt; <code> wait(&amp;status)</code></p>
<ul>
<li>状态约定:0表示成功，1表示命令遇到错误</li>
</ul>
</li>
<li><p>注意:<code>fork()</code>会复制，但是<code>exec()</code>会丢弃复制的内存</p>
</li>
</ul>
<p>这似乎很浪费，在“copy-on-write”实验室中，你将透明的删除复制</p>
<h3 id="例子-redirect-c，重定向命令的输出"><a href="#例子-redirect-c，重定向命令的输出" class="headerlink" title="例子:redirect.c，重定向命令的输出"></a>例子:<code>redirect.c</code>，重定向命令的输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redirect.c: run a command with output redirected</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY|O_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;redirected&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell如何完成重定向呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello &gt; out</span><br></pre></td></tr></table></figure>

<p>答案是:通过<code>fork</code>产生子进程，然后在子进程中改变文件描述符1，再调用<code>exec</code>执行echo</p>
<ul>
<li><p>注意:open()总是选择最小的未使用文件描述符;在重定向中，由于<code>close(1)</code>使得1成为了最小的文件描述符</p>
</li>
<li><p><code>fork</code> 、FDs（文件描述符）和<code>exec</code>可以很好地交互以实现I&#x2F;O重定向</p>
<ul>
<li>将<code>fork</code>和<code>exec</code>分离给了子进程一个在<code>exec</code>之前更改文件描述符的机会</li>
</ul>
</li>
</ul>
<p>文件描述符提供了一种间接性：命令只使用描述符0和1，而不需要知道文件描述符到底指向去哪里</p>
<p><code>exec</code>会保存shell所设置的文件描述符</p>
<ul>
<li><p>因此:只有shell需要知道I&#x2F;O重定向，而不是每个程序</p>
</li>
<li><p>关于设计决策，有必要问一下“为什么”:</p>
<ul>
<li>为什么要采用这些I&#x2F;O和流程抽象?为什么不是别的?</li>
<li>为什么要提供文件系统?为什么不让程序以自己的方式使用磁盘呢?</li>
<li>为什么使用文件描述符?为什么不将文件名传递给write()?</li>
<li>为什么文件是字节流，而不是磁盘块或格式化的记录?</li>
<li>为什么不合并fork()和exec()呢?</li>
<li>UNIX设计工作得很好，但我们将看到其他设计!</li>
</ul>
</li>
</ul>
<h3 id="例子-pipe1-c，通过管道交流"><a href="#例子-pipe1-c，通过管道交流" class="headerlink" title="例子:pipe1.c，通过管道交流"></a>例子:<code>pipe1.c</code>，通过管道交流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe1.c: communication over a pipe</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a pipe, with two FDs in fds[0], fds[1].</span></span><br><span class="line">  pipe(fds);</span><br><span class="line"></span><br><span class="line">  write(fds[<span class="number">1</span>], <span class="string">&quot;this is pipe1\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line">  n = read(fds[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, buf, n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell是如何实现管道的呢</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> | grep x</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件描述符可以指向“管道”，也可以指向文件</p>
</li>
<li><p><code>pipe()</code>系统调用创建两个文件描述符</p>
<ul>
<li>第一个用于读取</li>
<li>第二个用于写入</li>
</ul>
</li>
<li><p>内核为每个管道维护一个缓冲区</p>
<ul>
<li><code>write()</code>追加到缓冲区</li>
<li><code>read()</code>等待数据</li>
</ul>
</li>
</ul>
<h3 id="例子-pipe2-c，进程之间的通信"><a href="#例子-pipe2-c，进程之间的通信" class="headerlink" title="例子:pipe2.c，进程之间的通信"></a>例子:<code>pipe2.c</code>，进程之间的通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe2.c: communication between two processes</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, pid;</span><br><span class="line">  <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a pipe, with two FDs in fds[0], fds[1].</span></span><br><span class="line">  pipe(fds);</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    write(fds[<span class="number">1</span>], <span class="string">&quot;this is pipe2\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = read(fds[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    write(<span class="number">1</span>, buf, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>管道和<code>fork()</code>很好地结合在一起来实现<code>ls | grep x</code><ul>
<li>shell创建一个管道，</li>
<li>然后执行两次<code>fork</code></li>
<li>然后将<code>ls</code>的文件描述符1连接到管道的写文件描述符</li>
<li>将<code>grep</code>的文件描述符0连接到管道的读文件描述符</li>
</ul>
</li>
</ul>
<p>管道是一个单独的抽象，但与fork()结合得很好。</p>
<h3 id="例子-list-c，列出目录中的文件"><a href="#例子-list-c，列出目录中的文件" class="headerlink" title="例子:list.c，列出目录中的文件"></a>例子:<code>list.c</code>，列出目录中的文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list.c: list file names in the current directory</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">&quot;.&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span>(read(fd, &amp;amp;e, <span class="keyword">sizeof</span>(e)) == <span class="keyword">sizeof</span>(e))&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.name[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, e.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ls如何得到一个目录中的文件列表呢?</p>
<p>你可以打开一个目录并读取它-&gt;文件名</p>
<p>“<code>.</code>“是进程当前目录的伪名称</p>
<p>请参阅<code>ls.c</code>了解更多细节</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>我们已经了解了UNIX的I&#x2F;O、文件系统和进程抽象。</p>
</li>
<li><p>接口很简单——只有整数和I&#x2F;O缓冲区。</p>
</li>
<li><p>抽象组合得很好，例如I&#x2F;O重定向。</p>
</li>
</ul>
<p>你们将在下周的第一个实验中使用这些系统调用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/Journaling%20the%20Linux%20ext2fs%20Filesystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/Journaling%20the%20Linux%20ext2fs%20Filesystem/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/Journaling%20the%20Linux%20ext2fs%20Filesystem/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/Journaling%20the%20Linux%20ext2fs%20Filesystem/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Journaling-the-Linux-ext2fs-Filesystem"><a href="#Journaling-the-Linux-ext2fs-Filesystem" class="headerlink" title="Journaling the Linux ext2fs Filesystem"></a>Journaling the Linux ext2fs Filesystem</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文描述了为Linux ext2fs文件系统设计和实现事务元数据日志的工作进展。我们回顾了崩溃后恢复文件系统的问题，并描述了一种旨在通过向文件系统添加事务日志来提高ext2fs崩溃恢复速度和可靠性的设计。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>文件系统是任何现代操作系统的核心部分，人们期望它既快速又非常可靠。但是，由于硬件、软件或电源故障，问题仍然存在，机器可能会意外停机。</p>
<p>在一次意料之外的重启后，系统可能需要一些时间才能恢复文件系统的一致性状态。随着磁盘大小的增长，这一时间可能会成为一个严重的问题，在扫描、检查和修复磁盘时，系统会离线一小时或更长时间。尽管磁盘驱动器的速度每年都在加快，但与容量的巨大增长相比，这一速度的增长并不明显。不幸的是，在使用传统的文件系统检查技术时，磁盘容量每增加一倍，恢复时间就会增加一倍。</p>
<p>在系统可用性很重要的情况下，这可能是无法节省的时间，因此需要一种机制，以避免每次机器重新启动时都需要昂贵的恢复阶段。</p>
<h1 id="什么是文件系统"><a href="#什么是文件系统" class="headerlink" title="什么是文件系统"></a>什么是文件系统</h1><p>对于任何文件系统，我们都需要什么功能？文件系统所服务的操作系统有明确的要求。文件系统对应用程序的表现方式是：一个操作系统通常需要遵守某些约定的文件名，并且文件具有某些以特定方式解释的属性。</p>
<p>然而，文件系统的许多内部方面没有那么受约束，文件系统实现者可以在一定程度上自由地设计这些方面。磁盘上数据的布局（或者，如果文件系统不是本地的，它的网络协议）、内部缓存的细节以及用于调度磁盘IO的算法——在不违反文件系统应用程序接口规范的前提下，这些都是可以改变的。</p>
<p>我们可能选择一种而不是另一种设计的原因有很多。与旧文件系统的兼容性可能是一个问题：例如，Linux提供了一个UMSDOS文件系统，它在标准MSDOS磁盘文件结构的基础上实现了POSIX文件系统的语义学。</p>
<p>当试图解决Linux上文件系统恢复时间过长的问题时，我们牢记许多目标：</p>
<ul>
<li>使用新文件系统不会严重影响性能；</li>
<li>不得破坏与现有应用程序的兼容性</li>
<li>文件系统的可靠性不得以任何方式受到损害。</li>
</ul>
<h1 id="文件系统可靠性"><a href="#文件系统可靠性" class="headerlink" title="文件系统可靠性"></a>文件系统可靠性</h1><p>当我们谈论文件系统的可靠性时，有许多问题利害攸关。就本特定项目而言，我们主要关心的是恢复崩溃文件系统内容的可靠性，我们可以确定其中的几个方面：</p>
<p><strong>保持（Preservation）</strong>：崩溃前磁盘上稳定的数据永远不会被损坏。显然，崩溃时正在写入的文件不能保证完全完好无损，但是恢复系统不能碰磁盘上已经安全的任何文件。</p>
<p><strong>可预测性（Predictability）</strong>：我们必须恢复的故障模式应该是可预测的，以便我们可靠地恢复。</p>
<p><strong>原子性（Atomicity）</strong>：许多文件系统操作需要大量独立的IO来完成。一个很好的例子是将文件从一个目录重命名到另一个目录。如果这样的文件系统操作在磁盘上完全完成，或者在恢复完成后完全撤销，恢复就是原子性的。（对于重命名的例子，恢复应该在崩溃后保留提交给磁盘的旧文件名或新文件名，但不能两者都保留。）</p>
<h1 id="现有实现"><a href="#现有实现" class="headerlink" title="现有实现"></a>现有实现</h1><p>Linux ext2fs文件系统提供了保留恢复（preserving recovery），但它是非原子的，不可预测。事实上，可预测性比乍一看要复杂得多。为了能够在崩溃后进行可预测的清理，恢复阶段必须能够确定文件系统在遇到表现为一次不完整操作的磁盘不一致性时试图做什么。通常，这要求在一次涉及磁盘上多个块更改的更新操作时，文件系统必须以可预测的顺序写入磁盘。</p>
<p>实现磁盘写入之间的这种排序有许多方法。最简单的方法是简单地等待第一次写入完成，然后再将下一次写入提交给设备驱动程序——“同步元数据更新（synchronous metadata update）”方法。这是BSD快速文件系统采取的方法，出现在4.2BSD中，它启发了随后的许多Unix文件系统，包括ext2fs。</p>
<p>然而，同步元数据更新的一大缺点是它的性能。如果文件系统操作要求我们等待磁盘IO完成，那么我们就不能将多个文件系统更新批处理成单个磁盘写入。例如，如果我们在磁盘上的同一个目录块中创建十几个目录项，那么同步更新需要我们将该块写回磁盘十几次。</p>
<p>有一些方法可以解决这个性能问题。一种保持磁盘写入顺序而不实际等待IO完成的方法是在内存中的磁盘缓冲区之间保持顺序，并确保当我们最终去写回数据时，在一个块的所有前置块都安全地写回磁盘前，我们永远都不会写该块，——“延迟有序写入”技术。</p>
<p>延迟有序写入的一个复杂性是很容易陷入缓存缓冲区之间存在循环依赖的情况。例如，如果我们试图在两个目录之间重命名一个文件，同时将第二个目录中的另一个文件重命名至第一个目录，那么我们最终会遇到两个目录块相互依赖的情况：两个目录块都在等待对方写回磁盘，最终都不能写入。</p>
<p>Ganger的“软更新”机制巧妙地避开了这个问题，当我们第一次尝试将缓冲区写入磁盘时，如果这些更新仍然有未完成的依赖关系，我们会有选择地回滚缓冲区中的特定更新。丢失的更新将在所有的依赖关系都得到满足后恢复。这使得我们可以在有循环依赖关系时以我们选择的任何顺序写入缓冲区。软更新机制已经被FreeBSD采用，并将作为他们下一个主要内核版本的一部分提供。</p>
<p>然而，所有这些方法都有一个共同的问题。尽管它们确保磁盘的状态在文件系统操作过程中一直处于可预测的状态，但恢复过程仍然必须扫描整个磁盘，以便找到和修复任何未完成的操作。恢复变得更加可靠，但不一定更快。</p>
<p>然而，在不牺牲可靠性和可预测性的情况下快速恢复文件系统是可能的。这通常由保证文件系统更新原子完成的文件系统来完成（在这样的系统中，单个文件系统更新通常被称为事务）。原子更新背后的基本原则是文件系统可以将整批新数据写入磁盘，但是这些更新在磁盘上进行最终提交更新之前不会生效。如果提交涉及到对磁盘的单个块的写入，那么崩溃只能导致两种情况：要么提交记录已经写入磁盘，在这种情况下，所有提交的文件系统操作都可以假设是完整的，并且在磁盘上是一致的；要么提交记录丢失，这种情况下，由于在崩溃时部分尚未提交的更新仍未完成，我们必须忽略任何其他写入操作。这自然需要文件系统更新，以将更新数据的新旧内容保存在磁盘上的某个地方，直到提交。</p>
<p>有许多方法可以实现这一点。在某些情况下，文件系统将更新数据的新副本保存在与旧副本不同的位置，并最终在更新提交到磁盘后重用旧空间。网络设备的WAFL文件系统是这样工作的，维护一个文件系统数据树，它可以通过将树节点复制到新的位置，然后更新树根部的单个磁盘块来进行原子更新。（注：在WAFL中，如果它也修改一个数据，他可能不管以前的数据的位置，直接把新数据与新校验写到新的位置，之后更改指针，告诉文件系统说，新的数据在这里，而不是原来那里了。）</p>
<p>日志结构化文件系统通过将所有文件系统数据——包括文件内容和元数据——以连续流（“日志”）写入磁盘来实现相同的目的。使用这种方案查找一段数据的位置可能比在传统文件系统中更复杂，但是日志有一个很大的优势，那就是在日志中放置标记相对容易，以指示直到某个点的所有数据都已提交并在磁盘上保持一致。写入这样的文件系统也特别快，因为日志的性质使得大多数写入发生在没有磁盘查找的连续流中。许多文件系统都是基于这种设计编写的，包括Sprite LFS和Berkeley LFS。Linux上也有一个原型LFS实现。</p>
<p>最后，还有一类原子更新的文件系统，它将新版本写入磁盘上的单独位置，并在更新提交前保留旧版本和更新不完整的新版本。提交后，文件系统可以自由地将更新磁盘块的新版本写回磁盘上的原始位置。</p>
<p>这是日志记录journaling（有时称为日志增强版log enhanced）文件系统的工作方式。当磁盘上的元数据被更新时，更新被记录在磁盘上用作日志保留的单独区域中。完成的文件系统事务将提交记录添加到日志中，只有在提交安全地存储在磁盘上后，文件系统才能将元数据写回其原始位置。事务是原子的，因为我们总是可以在崩溃后根据日志是否包含事务的提交记录撤销事务（丢弃日志中的新数据）或重做事务（将日志副本复制回原始副本）。许多现代文件系统采用了这种设计的变体。</p>
<h1 id="为Linux设计一个新的文件系统"><a href="#为Linux设计一个新的文件系统" class="headerlink" title="为Linux设计一个新的文件系统"></a>为Linux设计一个新的文件系统</h1><p>Linux新文件系统设计背后的主要动机是消除崩溃后大型文件系统恢复时间。出于这个原因，我们选择了文件系统日志计划作为这项工作的基础。日志实现了快速的文件系统恢复，因为我们知道在任何时候，磁盘上可能不一致的所有数据都必须记录在日志中。因此，可以通过扫描日志并将所有提交的数据复制回主文件系统区域来实现文件系统恢复。这很快，因为日志通常比完整的文件系统小得多。它只需要足够记录几秒钟的未提交更新的容量。</p>
<p>选择日志记录还有另一个重要优势。日志记录文件系统不同于传统文件系统，因为它将临时数据保存在一个新的位置，独立于磁盘上的永久数据和元数据。正因为如此，这样的文件系统并不要求永久数据必须以任何特定的方式存储。特别是，ext2fs文件系统的磁盘结构很有可能在新文件系统中使用，现有的ext2fs代码也很有可能用作日志记录版本的基础。</p>
<p>因此，我们不是在为Linux设计一个新的文件系统。相反，我们在现有的ext2fs中添加了一个新的特性——事务性文件系统日志记录</p>
<h1 id="事务剖析"><a href="#事务剖析" class="headerlink" title="事务剖析"></a>事务剖析</h1><p>当考虑日志文件系统时，一个核心概念是事务，对应于文件系统的单个更新。应用程序发出的任何单个文件系统请求都会产生一个事务，并且包含该请求产生的所有更改的元数据。例如，对文件的写入将导致对文件在磁盘上的索引节点中的修改时间戳的更新，如果文件被写操作扩展，还可能更新长度信息和块映射信息。配额信息、空闲磁盘空间和记录使用块的位图都必须更新，如果给文件分配新的块，所有这些都必须记录在事务中。</p>
<p>在事务中还有一个我们必须注意的隐藏操作。事务还包括读取文件系统的现有内容，这在事务之间强加了顺序。修改磁盘上块的事务不能在读取新数据并根据读取的内容更新磁盘的事务之后提交。即使两个事务从来没有尝试写回相同的块，依赖性也是存在的——想象一个事务从目录中的一个块中删除文件名，另一个事务将相同的文件名插入到不同的块中。这两个操作在它们写入的块中可能不会重叠，但是第二个操作只有在第一个操作成功后才有效（违反这一操作将导致重复的目录条目）。</p>
<p>最后，除了元数据更新之间的排序之外，还有一个排序要求。在我们提交将新块分配给文件的事务之前，我们必须绝对确保事务创建的所有数据块实际上都已写入磁盘（我们称这些数据块为依赖数据<em>dependent data</em>）。忽略此要求实际上不会损害文件系统元数据的完整性，但它可能会导致新文件崩溃恢复后仍包含以前的文件内容，这是一个安全风险，也是一个一致性问题。</p>
<h1 id="事务合并"><a href="#事务合并" class="headerlink" title="事务合并"></a>事务合并</h1><p>日志文件系统中使用的许多术语和技术来自数据库世界，日志是确保复杂事务原子提交的标准机制。然而，传统数据库事务和文件系统之间有许多不同之处，其中一些允许我们大大简化事情。</p>
<p>两个最大的区别是文件系统没有事务中止，所有文件系统事务都相对短暂。而在数据库中，我们有时想中途中止事务，丢弃我们迄今为止所做的任何更改，在ext2fs中情况并非如此——当我们开始对文件系统进行任何更改时，我们已经检查了更改是否可以合法完成。在我们开始写入更改之前中止事务（例如，如果一个创建文件操作找到一个相同名称的现有文件，它可能会中止）不会带来任何问题，因为在这种情况下，我们可以简单地提交事务而不做任何更改，并实现相同的效果。</p>
<p>第二个区别——文件系统事务存在期很短——这很重要，因为这意味着我们可以极大地简化事务之间的依赖关系。如果我们必须满足一些非常长期的事务，那么我们需要允许事务以任何顺序独立提交，只要它们彼此不冲突，否则一个停滞不前的事务可能会拖累整个系统。然而，如果所有事务都足够快，那么我们可以要求事务以严格的顺序提交到磁盘，而不会明显损害性能。</p>
<p>通过这个观察，我们可以对事务模型进行简化，从而大大降低实现的复杂性，同时提高性能。与为每个文件系统更新创建单独的事务不同，我们只是经常创建一个新事务，并允许所有文件系统服务调用将它们的更新添加到单个系统范围的复合事务中。</p>
<p>这种机制有一个很大的优点。因为复合事务中的所有操作都将一起提交到日志中，所以我们不必为任何经常更新的元数据块编写单独的副本。特别是，这有助于创建新文件等操作，在这些操作中，对文件的每次写入都会导致文件被扩展，从而连续更新相同的配额、位图块和索引节点块。在复合事务的生命周期中，任何多次更新的块只需要提交到磁盘一次。</p>
<p>关于何时提交当前复合事务并启动新事务的决定是一个应该由用户控制的策略决定，因为它涉及到影响系统性能的权衡。提交等待的时间越长，可以在日志中合并的文件系统操作就越多，因此从长远来看需要的IO操作就越少。然而，更长的提交占用了大量的内存和磁盘空间，并在崩溃发生时留下了更大的更新丢失窗口。它们还可能导致磁盘活动的骤变，从而使文件系统响应时间难以预测。</p>
<h1 id="磁盘表示"><a href="#磁盘表示" class="headerlink" title="磁盘表示"></a>磁盘表示</h1><p>磁盘上记录的ext2fs文件系统的布局将与现有的ext2fs内核完全兼容。传统的UNIX文件系统通过将每个文件与磁盘上唯一编号的inode关联起来，将数据存储在磁盘上，而ext2fs设计已经包含了许多保留的inode编号。我们使用其中一个保留索引节点来存储文件系统日志，并且在所有其他方面，文件系统都将与现有的Linux内核兼容。现有的ext2fs设计包括一组兼容性位图，其中可以设置位来指示文件系统是否使用特定扩展。通过为日志扩展分配一个新的兼容性位，我们可以确保即使旧内核能够成功挂载一个新的、日志记录的ext2fs文件系统，它们也不会被允许以任何方式写入文件系统。</p>
<h1 id="文件系统日志的格式"><a href="#文件系统日志的格式" class="headerlink" title="文件系统日志的格式"></a>文件系统日志的格式</h1><p>日志文件的工作很简单：它在我们提交事务的过程中记录文件系统元数据块的新内容。日志的唯一其他要求是我们必须能够原子地提交它包含的事务。</p>
<p>我们向日志写入三种不同类型的数据块：元数据块、描述符块和头块（metadata, descriptor and header blocks）。</p>
<p>日志元数据块包含由事务更新的单个文件系统元数据块的全部内容。这意味着，无论我们对文件系统元数据块做了多么小的更改，我们都必须写出整个日志块来记录更改。然而，由于两个原因，这一成本相对较低：</p>
<ul>
<li>无论如何，日志写入非常快，因为对日志的大多数写入都是顺序的，我们可以很容易地将日志IO批处理成大型集群，磁盘控制器可以有效地处理这些集群；</li>
<li>通过将更改后的元数据缓冲区的全部内容从文件系统缓存写入日志，我们可以避免在日志代码中执行大量CPU工作。</li>
</ul>
<p>Linux内核已经为我们提供了一种非常有效的机制，可以将buffer cache中现有块的内容写到磁盘上的不同位置。buffer cache中的每个缓冲区都由一个名为<code>buffer_head</code>的结构体描述，该结构体包括缓冲区的数据要写到哪个磁盘块的信息。如果我们想将整个缓冲区块在不干扰<code>buffer_head</code>的情况下写入新位置，我们可以简单地创建一个新的临时<code>buffer_head</code>，将旧的描述复制到其中，然后编辑临时<code>buffer_head</code>中的设备块编号字段，以指向日志文件中的块。然后，我们可以将临时<code>buffer_head</code>直接提交给设备IO系统，并在IO完成后丢弃它。</p>
<p>描述符块是描述其他日志元数据块的日志块，每当我们要将元数据块写出到日志时，我们需要记录下元数据通常安置在哪些磁盘块，这样恢复机制就可以将元数据复制回主文件系统中。在日志中的每一组元数据块之前都会写出一个描述符块，其中包含要写入的元数据块的数量加上它们的磁盘块号。</p>
<p>描述符块和元数据块都按顺序写入日志，每当我们运行超过末尾时，都会从日志的开头重新开始。在任何时候，我们都维护当前的日志头（最后写入的块的块号）和尾部（日志中尚未取消固定的最老的块，如下所述）。每当我们用完日志空间时——日志的头部已经循环回来并赶上了尾部——我们会停止新的日志写入，直到日志的尾部被清理干净，以释放更多的空间。</p>
<p>最后，日志文件包含一些位于固定位置的头块。这些头块记录了日志的当前头部和尾部，加上序列号。在恢复时，头块被扫描以找到序列号最高的块，当我们在恢复过程中扫描日志时，我们只是运行从尾部到头部的所有日志块，就像头块中记录的那样。</p>
<h1 id="日志的提交和检查点"><a href="#日志的提交和检查点" class="headerlink" title="日志的提交和检查点"></a>日志的提交和检查点</h1><p>在某个时候，要么是因为上次提交后我们已经等了足够长的时间，要么是因为日志中的空间不足，我们希望将未完成的文件系统更新作为一个新的复合事务提交到日志中。</p>
<p>复合事务被完全提交后，我们仍然没有完成它。我们需要跟踪记录在事务中的元数据缓冲区，这样我们就可以注意到它们何时被写回磁盘上的主位置。</p>
<p>回想一下，当我们提交事务时，新更新的文件系统块位于日志中，但尚未同步回磁盘上的永久家块（家块就是写入操作对应的磁盘中文件系统对应的块，我们需要保持旧块的这种不同步，以防在提交日志之前崩溃）。一旦提交了日志，磁盘上的旧版本就不再重要，我们可以在闲暇时将缓冲区写回它们的主位置。但是，在同步完这些缓冲区之前，我们不能删除日志中数据的副本。</p>
<p>要完全提交并完成事务的检查点，我们将经历以下阶段：</p>
<ol>
<li>关闭事务。在此刻，我们会建立一个新的事务以记录未来开始的任何文件系统操作。任何现有的、不完整的操作仍然会使用现有的事务：我们不能在多个事务上拆分单个文件系统操作！</li>
<li>开始将事务刷新到磁盘。在一个单独的log-writer内核线程的上下文中，我们开始向日志写入所有被事务修改过的元数据缓冲区。在这个阶段，我们还必须写入任何依赖数据（参见上面的部分：事务解剖）。</li>
<li>提交缓冲区后，将其标记以固定事务，直到它不再脏（它已通过通常的写回机制写回主存储）。</li>
<li>等待此事务中所有未完成的文件系统操作完成。我们可以在所有操作完成之前安全地开始写日志，允许这两个步骤在某种程度上重叠会更快。</li>
<li>等待所有未完成的事务更新完全记录在日志中。</li>
<li>更新日志头块以记录日志的新头部和尾部，将事务提交到磁盘。space released in the journal can now be reused by a later transaction. </li>
<li>当我们将事务的更新缓冲区写到日志中时，我们将它们标记以将事务固定在日志中。只有当这些缓冲区已同步到磁盘上的主缓冲区时，它们才会解除固定。只有当事务的最后一个缓冲区取消固定时，我们才能重用事务占用的日志块。当发生这种情况时，写入另一组日志头，记录日志尾部的新位置。日志中释放的空间现在可以由以后的事务重用。</li>
</ol>
<h1 id="事务间冲突"><a href="#事务间冲突" class="headerlink" title="事务间冲突"></a>事务间冲突</h1><p>为了提高性能，我们在提交事务时不会完全暂停文件系统更新。相反，我们创建一个新的复合事务，在其中记录提交旧事务时到达的更新。</p>
<p>这就留下了一个问题，如果一个更新想要访问被另一个更新所占有的元数据缓冲区，而另一个更新包含于当前正在提交的旧事务，此时该怎么办。为了提交旧事务，我们需要将其缓冲区写入日志，但是我们不能在日志中写入任何不属于事务的更改，因为这将导致我们提交不完整的更新。</p>
<p>如果新事务只想读取有问题的缓冲区，那么没有问题：我们已经在两个事务之间创建了读&#x2F;写依赖关系，但是由于复合事务总是以严格的顺序提交，我们可以安全地忽略冲突。</p>
<p>如果新事务想要写入缓冲区，事情就比较复杂了，我们需要缓冲区的旧副本来提交第一个事务，但是我们不能让新事务在不让它修改缓冲区的情况下继续进行。</p>
<p>这里的解决方案是在这种情况下创建缓冲区的新副本。将一份副本提供给新事务以进行修改。另一个由旧事务保留，并将像往常一样提交到日志。一旦事务提交，此副本将被删除。当然，在文件系统中的其他地方安全地记录此缓冲区之前，我们无法回收旧事务的日志空间，但由于必须将缓冲区提交到下一个事务的日志记录中，这一点会自动得到处理。</p>
<h1 id="项目现状和未来的工作"><a href="#项目现状和未来的工作" class="headerlink" title="项目现状和未来的工作"></a>项目现状和未来的工作</h1><p>这仍然是一项正在进行的工作。初始实现的设计既稳定又简单，我们不期望为了完成实现而需要对设计进行任何重大修改。</p>
<p>上述设计相对简单，只需对现有ext2fs代码进行少量修改，即可处理日志文件的管理、缓冲区和事务之间的关联以及不干净关闭后的文件系统恢复。</p>
<p>一旦我们有了一个稳定的代码库来测试，我们可以在许多可能的方向上扩展基本设计。最重要的是文件系统性能的调优。这将要求我们研究日志系统中任意参数的影响，如提交频率和日志大小。它还将涉及瓶颈研究，以确定是否可以通过修改系统设计来提高性能，并且已经有几个可能的设计扩展。</p>
<p>一个研究领域可能是考虑压缩更新中的日志更新。目前的方案要求我们向日志写入整个元数据块，即使块中只有一个比特被修改。我们可以通过只记录缓冲区中更改的值而不是记录整个缓冲区来非常容易地压缩这些更新。然而，目前还不清楚这是否会带来任何重大的性能优势。目前的方案对大多数写入来说不需要内存到内存的拷贝，这在CPU和总线利用率方面是一个巨大的性能优势。写入整个缓冲区产生的IO开销很低——因为更新是连续的，在现代磁盘IO系统中，它们直接从主存储器传输到磁盘控制器，而不经过缓存或CPU。</p>
<p>另一个重要的可能扩展领域是对快速NFS服务器的支持。NFS设计允许客户端在服务器崩溃时正常恢复：客户端将在服务器重新启动时重新连接。如果发生这种崩溃，服务器尚未安全写入磁盘的任何客户端数据都将丢失，因此NFS要求服务器在将客户端的文件系统请求提交到服务器磁盘之前，不得确认该请求已完成。</p>
<p>对于通用文件系统来说，这可能是一个难以支持的特性。NFS服务器的性能通常通过对客户端请求的响应时间来衡量，如果这些响应必须等待文件系统更新与磁盘同步，则总体性能会受到磁盘上文件系统更新延迟的限制。这与文件系统的大多数其他用途不同，在文件系统中，性能是根据缓存内更新的延迟而不是磁盘上更新的延迟来衡量的。</p>
<p>有些文件系统是专门设计来解决这个问题的。WAFL是一个基于事务树的文件系统，它可以在磁盘上的任何地方写入更新，但是Calaveras文件系统通过使用类似于上面建议的日志来达到同样的目的。不同之处在于，Calaveras将每个应用程序的文件系统请求在日志中记录为一个单独的事务，从而尽可能快地在磁盘上完成单独的更新。建议的ext2fs日志记录中的批处理提交牺牲了快速提交，而倾向于一次提交多个更新，从而以延迟为代价获得吞吐量(由于缓存的影响，磁盘上的延迟对应用程序是隐藏的)。</p>
<p>ext2fs日志记录有两种方式更适合在NFS服务器上使用，一种是使用较小的事务，另一种是记录文件数据和元数据。通过调整提交到日志的事务的大小，我们可能能够显著提高提交单个更新的周转时间。NFS还要求尽快将数据写入提交到磁盘，原则上没有理由不扩展日志文件以覆盖正常文件数据的写入。</p>
<p>最后，值得注意的是，这个方案中没有任何东西会阻止我们在几个不同的文件系统中共享一个日志文件。允许多个文件系统被记录到完全为此目的保留的单独磁盘上的日志中不需要太多额外的工作，并且在有许多日志文件系统都经历高负载的情况下，这可能会大大提高性能。单独的日志磁盘将几乎完全按顺序写入，因此可以保持高吞吐量，而不会损害主文件系统磁盘上的可用带宽。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文中概述的文件系统设计应该比Linux上现有的ext2fs文件系统提供显著的优势。它应该通过使文件系统在崩溃后更可预测和更快地恢复来提高可用性和可靠性，并且在正常操作中不应该导致太多的性能损失。</p>
<p>对日常性能最重要的影响是，新创建的文件必须快速同步到磁盘，以便将创建的文件提交到日志，而不是允许内核通常支持的数据延迟写回。这可能使日志文件系统不适合在***&#x2F;tmp***文件系统上使用。</p>
<p>设计应该只需要对现有的ext2fs代码库进行最小的更改:大多数功能都是由新的日志机制提供的，该机制将通过一个简单的事务缓冲区IO接口与ext2fs主代码交互。</p>
<p>最后，这里介绍的设计构建在现有ext2fs磁盘上文件系统布局的基础上，因此可以在现有ext2fs文件系统中添加事务日志，无需重新格式化文件系统就可使用这些新特性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/Use%20GUN%20Debugger/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/Use%20GUN%20Debugger/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/Use%20GUN%20Debugger/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/Use%20GUN%20Debugger/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用GUN-Debugger"><a href="#使用GUN-Debugger" class="headerlink" title="使用GUN Debugger"></a>使用GUN Debugger</h1><h1 id="6-828的GDB"><a href="#6-828的GDB" class="headerlink" title="6.828的GDB"></a>6.828的GDB</h1><ul>
<li><p>我们提供一个名为**.gdbinit**的文件，自动设置GDB以用于QEMU</p>
<ul>
<li>必须在lab或xv6目录中运行GDB</li>
<li>编辑***~&#x2F;.gdbinit***以执行其他需要的GDB初始化</li>
</ul>
</li>
<li><p>以带有或不带有GDB的方式使用<code>make</code>指令启动QEMU</p>
<ul>
<li>带有GDB：运行<code>make qemu[-nox]-gdb</code>，然后在第二个Shell中启动GDB（<code>iscv64-linux-gnu-gdb</code>）</li>
<li>如果以单核方式启动，则使用<code>make CPUS=1 qemu-gdb</code></li>
<li>不带有GDB：当不需要GDB时使用<code>make qemu[-nox]</code>命令</li>
</ul>
</li>
</ul>
<h1 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h1><ul>
<li>当你不知道某个命令怎么使用时，运行<code>help &lt;命令名称&gt;</code>来获取帮助</li>
<li>在无歧义的情况下，所有命令都可以被简写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c`=`co`=`cont`=`continue</span><br></pre></td></tr></table></figure>

<ul>
<li>一些额外的简写已经被定义,例如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s`=`step` 以及 `si`=`stepi</span><br></pre></td></tr></table></figure>



<h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><ul>
<li><code>step</code>一次运行一行代码。当有函数调用时，它将步进到被调用的对象函数。</li>
<li><code>next</code>也是一次运行一行代码。但当有函数调用时，它不会进入该函数。</li>
<li><code>stepi</code>和<code>nexti</code>对于汇编指令是单步调试。</li>
</ul>
<p>所有命令都可以采用一个数字参数来指定重复执行的次数。按回车键将重复上一个命令。</p>
<h2 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h2><ul>
<li><code>continue</code>运行代码，直到遇到断点或使用<code>&lt;Ctrl-c&gt;</code>中断它</li>
<li><code>finish</code>运行代码，直到当前函数返回</li>
<li><code>advance &lt;location&gt;</code>运行代码，直到指令指针到达指定位置</li>
</ul>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><ul>
<li><p><code>break &lt;location&gt;</code>在指定的位置设置断点。<br>  位置可以是内存地址(<code>*0x7c00</code>)或名称(<code>monbacktrace</code>，<code>monitor.c:71</code>)</p>
</li>
<li><p>如需修改断点请使用<code>delete</code>，<code>disable</code>，<code>enable</code></p>
</li>
</ul>
<h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><ul>
<li><code>break &lt;location&gt; if &lt;condition&gt;</code>在指定位置设置断点，但仅在满足条件时中断。</li>
<li><code>cond &lt;number&gt; &lt;condition&gt;</code>在现有断点上添加条件。</li>
</ul>
<h2 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h2><p>类似于断点，但条件更为复杂。</p>
<ul>
<li><code>watch &lt;expression&gt;</code>每当表达式的值更改时，将停止执行</li>
<li><code>watch -l &lt;address&gt;</code>每当指定内存地址的内容发生变化时，就会停止执行。<ul>
<li>命令<code>wa var</code>和<code>wa -l &amp;var</code>有什么不同呢?</li>
</ul>
</li>
<li><code>rwatch [-l] &lt;expression&gt;</code>将在读取表达式的值时停止执行。</li>
</ul>
<h2 id="检查命令"><a href="#检查命令" class="headerlink" title="检查命令"></a>检查命令</h2><ul>
<li><code>x</code>以您指定格式（<code>x/x</code>表示十六进制，<code>x/i</code>表示汇编，等等）打印内存的原始内容。</li>
<li><code>print</code>计算一个C表达式并将结果以合适的类型打印。它通常比<code>x</code>更有用</li>
<li>使用<code>p *((struct elfhdr *) 0x10000)</code>的输出比<code>x/13x 0x10000</code>的输出好得多</li>
</ul>
<h2 id="其他检查命令"><a href="#其他检查命令" class="headerlink" title="其他检查命令"></a>其他检查命令</h2><ul>
<li><code>info registers</code>打印每个寄存器的值</li>
<li><code>info frame</code>打印当前栈帧</li>
<li><code>list &lt;location&gt;</code>在指定位置打印函数的源代码</li>
<li><code>backtrace</code>或许对于你的lab1中的工作很有用处</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>GDB有一个文本用户界面，在curses用户界面中显示有用的信息，如代码列表、反汇编和寄存器内容</p>
<ul>
<li><code>layout &lt;name&gt;</code>切换到给定的用户界面</li>
</ul>
<p>例如<code>layout split</code>，效果如下</p>
<p><img src="/images/p2.png" alt="img"></p>
<h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><ul>
<li>你可以使用<code>set</code>命令在执行期间更改变量的值。</li>
<li>你必须切换符号文件才能获得除内核以外环境的函数和变量名。例如，当调试JOS时：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">symbol-file obj/user/&lt;name&gt;</span><br><span class="line">symbol-file obj/kern/kernel</span><br></pre></td></tr></table></figure>

<blockquote>
<p>符号文件（Symbol Files）是一个数据信息文件，它包含了应用程序二进制文件（比如：EXE、DLL等）调试信息，专门用来作调试之用，最终生成的可执行文件在运行时并不需要这个符号文件，但你的程序中所有的变量信息都记录在这个文件中。所以调试应用程序时，这个文件是非常重要的。用 Visual C++ 和 WinDbg 调试程序时都要用到这个文件。</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><code>layout asm</code>：查看汇编<br><code>layout reg</code>：查看寄存器<br><code>info reg</code>：查看寄存器<br><code>b *0x1234</code>：在指定地址设定断点</p>
<h1 id="QEMU使用"><a href="#QEMU使用" class="headerlink" title="QEMU使用"></a>QEMU使用</h1><p><code>Ctrl+a c</code>：进入控制模式<br><code>info mem</code>：打印页表</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>使用<code>help</code>命令查看使用手册</li>
<li>GDB是非常强大的，我们今天只触及表面</li>
<li>花费一个小时的时间学习如何使用GDB是非常值得的</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/C%20Pointers,%20gdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/C%20Pointers,%20gdb/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/C%20Pointers,%20gdb/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/C%20Pointers,%20gdb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Pointers-gdb"><a href="#C-Pointers-gdb" class="headerlink" title="C, Pointers, gdb"></a>C, Pointers, gdb</h1><h1 id="我的第一个内存bug"><a href="#我的第一个内存bug" class="headerlink" title="我的第一个内存bug"></a>我的第一个内存bug</h1><p><img src="/images/p1.png" alt="img"></p>
<h1 id="C语言中的内存"><a href="#C语言中的内存" class="headerlink" title="C语言中的内存"></a>C语言中的内存</h1><ol>
<li><strong>静态内存</strong></li>
</ol>
<ul>
<li>全局变量，可在整个程序中访问</li>
<li>使用<code>static</code>关键字定义，和在全局范围中定义的变量一样。</li>
</ul>
<ol>
<li><strong>栈内存</strong></li>
</ol>
<ul>
<li>函数中的局部变量。函数退出后<strong>自动销毁</strong>。</li>
</ul>
<ol>
<li><strong>堆内存</strong></li>
</ol>
<ul>
<li>您使用<code>malloc()</code>和<code>free()</code>控制这些变量的创建和销毁</li>
<li>由于使用结束后必须调用<code>free()</code>，可能会导致内存泄漏</li>
</ul>
<h1 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h1><p>指针是一个64位整数，其值是内存中的地址。</p>
<p>每个变量都有一个地址，所以每个变量都会有对应的指针，包括指向指针的指针，指向指针的指针的指针，以此类推。</p>
<p>指针可以处理<code>++</code>, <code>--</code>, <code>+</code>,<code>-</code>这样的算数运算</p>
<h2 id="指针语法"><a href="#指针语法" class="headerlink" title="指针语法"></a>指针语法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>; </span><br><span class="line"><span class="type">int</span> *x_addr = &amp;x;      <span class="comment">//等同于int* x_addr = &amp;x; 例如值为0x7ffd2766a948 </span></span><br><span class="line">*x_addr = <span class="number">6</span>;           <span class="comment">//可以使用*运算符访问基础值 </span></span><br><span class="line"><span class="type">int</span> x_value = *x_addr; <span class="comment">//解引用，这将得到6 </span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>];          <span class="comment">//数组隐含了指针！稍后将详细介绍。 </span></span><br><span class="line"><span class="type">int</span> *arr2[<span class="number">20</span>];         <span class="comment">//指针数组，使arr2成为指向指针的指针 </span></span><br><span class="line"><span class="type">void</span> *myPtr;</span><br></pre></td></tr></table></figure>

<p>试试这些！在***user&#x2F;***下创建一个新的程序，就像在Util中一样</p>
<h2 id="回到内存"><a href="#回到内存" class="headerlink" title="回到内存"></a>回到内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">makeABC</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">char</span> y[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;; </span><br><span class="line">    <span class="keyword">return</span> y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这有什么错误？</p>
<h2 id="指针算术运算，耶！"><a href="#指针算术运算，耶！" class="headerlink" title="指针算术运算，耶！"></a>指针算术运算，耶！</h2><p>假设我们有一些值为<code>0x100002</code>的<code>char *c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++;    <span class="comment">// 0x100003</span></span><br><span class="line">c += <span class="number">4</span>; <span class="comment">// 0x100007</span></span><br></pre></td></tr></table></figure>

<p>就该如此啊！</p>
<h2 id="指针算术运算，唉…"><a href="#指针算术运算，唉…" class="headerlink" title="指针算术运算，唉…"></a>指针算术运算，唉…</h2><p>假设我们有一些值为<code>0x100002</code>的<code>int *i</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i++;    <span class="comment">//0x100006</span></span><br><span class="line">i += <span class="number">4</span>; <span class="comment">//0x100016</span></span><br></pre></td></tr></table></figure>

<p>指针以基本数据类型的长度（以字节为单位）进行加减。</p>
<h1 id="C语言数组"><a href="#C语言数组" class="headerlink" title="C语言数组"></a>C语言数组</h1><p>C数组是存储特定数据类型的连续内存块。变量实际就是数组起始位置的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> myString[<span class="number">40</span>];                 <span class="comment">// myString的类型是char* </span></span><br><span class="line"><span class="type">char</span> *myArrayOfStrings[<span class="number">20</span>];        <span class="comment">// myArrayOfStrings的类型是char** </span></span><br><span class="line"><span class="type">int</span> counting[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// counting类型为int*</span></span><br></pre></td></tr></table></figure>

<p>括号运算符<code>[]</code>（例如访问<code>arr[1]</code>）只是指针算法的语法糖。</p>
<p>假设我们定义了<code>int arr[4] = &#123;5, 6, 7, 8&#125;;</code>那么下面这些是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">2</span>] = <span class="number">50</span>; </span><br><span class="line">*(arr + <span class="number">2</span>) = <span class="number">50</span>; <span class="comment">// 记住指针的算术运算！ </span></span><br><span class="line"><span class="number">2</span> [arr] = <span class="number">50</span>;    <span class="comment">// 加法是交换的(排列次序不影响结果)!</span></span><br></pre></td></tr></table></figure>

<h2 id="C语言数组的缺陷"><a href="#C语言数组的缺陷" class="headerlink" title="C语言数组的缺陷"></a>C语言数组的缺陷</h2><p>我们可以通过越界访问数组来访问或修改非法内存。C不提供任何检查。</p>
<p>这种行为可能是意想不到的。</p>
<p>需要时使用您的size变量！</p>
<h1 id="C语言的位运算符"><a href="#C语言的位运算符" class="headerlink" title="C语言的位运算符"></a>C语言的位运算符</h1><p>一切最终都是比特位，C语言允许我们操纵这些比特。</p>
<p>以下均为二进制数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp; (and/与): 10001 &amp; 10000 -&gt; 10000</span><br><span class="line">| (or/或): 10001 | 10000 -&gt; 10001</span><br><span class="line">^ (xor/异或): 10001 ^ 10000 -&gt; 00001</span><br><span class="line">~ (complement/取反): ~10000 -&gt; 01111</span><br><span class="line">&lt;&lt; (left shift/左移): 1 &lt;&lt; 4 -&gt; 10000 (binary) -&gt; 16 (decimal) </span><br><span class="line">&gt;&gt; (right shfit/右移): 10101 &gt;&gt; 3 -&gt; 10 (binary) </span><br></pre></td></tr></table></figure>

<p>我们可以将这些运算符组合起来，使标志设置变得简单：</p>
<p>定义位偏移<code>flag0 = 0</code>, <code>flag1 =1</code>, <code>flag2 = 2</code>.</p>
<p>要设置标志<code>flag0</code>和<code>flag2</code>：</p>
<p><code>flags = (1 &lt;&lt; flag0) | (1 &lt;&lt; flag2)</code> -&gt; 101</p>
<p>要检查在整型标志变量中标志是否被设置：</p>
<p><code>if(flags &amp; flag1)</code> -&gt; 101 &amp; 010 &#x3D;&#x3D; 0 (false!)</p>
<h1 id="C语言类型转换"><a href="#C语言类型转换" class="headerlink" title="C语言类型转换"></a>C语言类型转换</h1><p>在C语言中进行类型转换的语法是：<code>(newType)variable</code></p>
<p>将<code>void*</code>转换为<code>char*</code>: <code>(char*)myVoidPtr</code></p>
<p>从表达式转换为<code>uint64</code>：<code>(uint64)(2 + 3)</code>, <code>(uint64)myVoidPtr</code></p>
<p>关于一些好的例子，请参见<em><strong>kalloc.c</strong></em>和<em><strong>vm.c</strong></em>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span> </span><br><span class="line">    <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP) </span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>); </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C语言的-include"><a href="#C语言的-include" class="headerlink" title="C语言的#include"></a>C语言的#include</h1><p><code>.h</code>文件包含声明（构成）</p>
<p><code>.c</code>文件包含定义（实现）</p>
<p>基本上从不<code>#include</code> <code>.c</code>类型的文件！</p>
<p>[include卫兵](<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Include_guard#:~:text=In">https://en.wikipedia.org/wiki/Include_guard#:~:text=In</a> the C and C,dealing with the include directive.)帮助处理嵌套&#x2F;重复<code>#include</code>（在xv6中没有使用太多）</p>
<blockquote>
<p>[!NOTE]<br>include卫兵是指这样的结构</p>
<p><code>#ifndef XXXX_H</code></p>
<p><code>#define XXXX_H</code></p>
<p><code>...</code></p>
<p><code>#endif</code></p>
</blockquote>
<p>使用<code>extern</code>关键字！将函数的可见性扩展到程序中的所有文件。</p>
<h1 id="一个关于指针的示例"><a href="#一个关于指针的示例" class="headerlink" title="一个关于指针的示例"></a>一个关于指针的示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        a[i] = <span class="number">100</span> + i;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;</span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = c + <span class="number">1</span>;</span><br><span class="line">    *c = <span class="number">400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">int</span> *) ((<span class="type">char</span> *) c + <span class="number">1</span>);</span><br><span class="line">    *c = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    b = (<span class="type">int</span> *) a + <span class="number">1</span>;</span><br><span class="line">    c = (<span class="type">int</span> *) ((<span class="type">char</span> *) a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> ac, <span class="type">char</span> **av)</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaoq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nPTQNF98hlhFVhx3uT28h3EW-gzGzoHsz',
      appKey     : 'Hj5CW3nJJnJ3rBlGeKK8XQLa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
