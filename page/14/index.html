<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="肖大强的个人博客">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="肖大强的个人博客">
<meta property="og:locale">
<meta property="article:author" content="xiaoq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>肖大强的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖大强的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab4/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab4-Traps"><a href="#Lab4-Traps" class="headerlink" title="Lab4: Traps"></a>Lab4: Traps</h1><h1 id="1-RISC-V-assembly"><a href="#1-RISC-V-assembly" class="headerlink" title="1. RISC-V assembly"></a>1. RISC-V assembly</h1><p><strong>(1)</strong>.  在a0-a7中存放参数，13存放在a2中 </p>
<p><strong>(2)</strong>.  在C代码中，main调用f，f调用g。而在生成的汇编中，main函数进行了内联优化处理。</p>
<p>从代码<code>li a1,12</code>可以看出，main直接计算出了结果并储存 </p>
<p><strong>(3)</strong>. 在<code>0x630</code></p>
<p><strong>(4)</strong>. <code>auipc</code>(Add Upper Immediate to PC)：<code>auipc rd imm</code>，将高位立即数加到PC上，从下面的指令格式可以看出，该指令将20位的立即数左移12位之后（右侧补0）加上PC的值，将结果保存到dest位置，图中为<code>rd</code>寄存器</p>
<p><img src="/images/p1.png" alt="img"></p>
<p>下面来看<code>jalr</code> (jump and link register)：<code>jalr rd, offset(rs1)</code>跳转并链接寄存器。jalr指令会将当前PC+4保存在rd中，然后跳转到指定的偏移地址<code>offset(rs1)</code>。</p>
<p><img src="/images/p2.png" alt="img"></p>
<p>来看XV6的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30: 00000097       auipc ra,0x0</span><br><span class="line">34: 600080e7       jalr  1536(ra) # 630 &lt;printf&gt;</span><br></pre></td></tr></table></figure>

<p>第一行代码：<code>00000097H=00...0 0000 1001 0111B</code>，对比指令格式，可见imm&#x3D;0，dest&#x3D;00001，opcode&#x3D;0010111，对比汇编指令可知，auipc的操作码是0010111，ra寄存器代码是00001。这行代码将0x0左移12位（还是0x0）加到PC（当前为0x30）上并存入ra中，即ra中保存的是0x30</p>
<p>第2行代码：<code>600080e7H=0110 0...0 1000 0000 1110 0111B</code>，可见imm&#x3D;0110 0000 0000，rs1&#x3D;00001，funct3&#x3D;000，rd&#x3D;00001，opcode&#x3D;1100111，rs1和rd的知识码都是00001，即都为寄存器<code>ra</code>。这对比jalr的标准格式有所不同，可能是此两处使用寄存器相同时，汇编中可以省略<code>rd</code>部分。</p>
<p>ra中保存的是0x30，加上0x600后为0x630，即<code>printf</code>的地址，执行此行代码后，将跳转到printf函数执行，并将PC+4&#x3D;0X34+0X4&#x3D;0X38保存到<code>ra</code>中，供之后返回使用。</p>
<p><strong>(5)</strong>. 57616&#x3D;0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表</p>
<p> 72:r 6c:l 64:d 00:充当字符串结尾标识</p>
<p> 因此输出为：HE110 World</p>
<p> 若为大端存储，i应改为0x726c6400，不需改变57616 </p>
<p><strong>(6)</strong>. 原本需要两个参数，却只传入了一个，因此y&#x3D;后面打印的结果取决于之前a2中保存的数据 </p>
<h1 id="2-Backtrace"><a href="#2-Backtrace" class="headerlink" title="2. Backtrace"></a>2. Backtrace</h1><p>这个函数就是实现曾经调用函数地址的回溯，这个功能在日常的编程中也经常见到，编译器报错时就是类似的逻辑，只不过题目的要求较为简单，只用打印程序地址，而实际的报错中往往打印程序文件名，函数名以及行号等信息（最后的可选练习就是实现这样的功能）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief backtrace 回溯函数调用的返回地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 读取当前帧指针</span></span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="keyword">while</span> (PGROUNDUP(fp) - PGROUNDDOWN(fp) == PGSIZE) &#123;</span><br><span class="line">    <span class="comment">// 返回地址保存在-8偏移的位置</span></span><br><span class="line">    uint64 ret_addr = *(uint64*)(fp - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ret_addr);</span><br><span class="line">    <span class="comment">// 前一个帧指针保存在-16偏移的位置</span></span><br><span class="line">    fp = *(uint64*)(fp - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        根据提示：返回地址位于栈帧帧指针的固定偏移(-8)位置，并且保存的帧指针位于帧指针的固定偏移(-16)位置。先使用<code>r_fp()</code>读取当前的帧指针，然后读出返回地址并打印，再将<code>fp</code>定位到前一个帧指针的位置继续读取即可。</p>
<p>根据提示：XV6在内核中以页面对齐的地址为每个栈分配一个页面。使用<code>PGROUNDUP(fp) - PGROUNDDOWN(fp) == PGSIZE</code>判断当前的<code>fp</code>是否被分配了一个页面来终止循环。</p>
<h1 id="3-Alarm"><a href="#3-Alarm" class="headerlink" title="3. Alarm"></a>3. Alarm</h1><p>这项练习要实现定期的警报。首先是要通过<code>test0</code>，如何调用处理程序是主要的问题。程序计数器的过程是这样的：</p>
<ol>
<li><code>ecall</code>指令中将PC保存到SEPC</li>
<li>在<code>usertrap</code>中将SEPC保存到<code>p-&gt;trapframe-&gt;epc</code></li>
<li><code>p-&gt;trapframe-&gt;epc</code>加4指向下一条指令</li>
<li>执行系统调用</li>
<li>在<code>usertrapret</code>中将SEPC改写为<code>p-&gt;trapframe-&gt;epc</code>中的值</li>
<li>在<code>sret</code>中将PC设置为SEPC的值</li>
</ol>
<p>可见执行系统调用后返回到用户空间继续执行的指令地址是由<code>p-&gt;trapframe-&gt;epc</code>决定的，因此在<code>usertrap</code>中主要就是完成它的设置工作。</p>
<p><strong>(1)</strong>. 在<code>struct proc</code>中增加字段，同时记得在<code>allocproc</code>中将它们初始化为0，并在<code>freeproc</code>中也设为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> alarm_interval;          <span class="comment">// 报警间隔</span></span><br><span class="line"><span class="type">void</span> (*alarm_handler)();     <span class="comment">// 报警处理函数</span></span><br><span class="line"><span class="type">int</span> ticks_count;             <span class="comment">// 两次报警间的滴答计数</span></span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong>. 在<code>sys_sigalarm</code>中读取参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;myproc()-&gt;alarm_interval) &lt; <span class="number">0</span> ||</span><br><span class="line">    argaddr(<span class="number">1</span>, (uint64*)&amp;myproc()-&gt;alarm_handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)</strong>. 修改usertrap()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(++p-&gt;ticks_count == p-&gt;alarm_interval) &#123;</span><br><span class="line">        <span class="comment">// 更改陷阱帧中保留的程序计数器</span></span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">        p-&gt;ticks_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要通过<code>test1</code>和<code>test2</code>，要解决的主要问题是寄存器保存恢复和防止重复执行的问题。考虑一下没有alarm时运行的大致过程</p>
<ol>
<li>进入内核空间，保存用户寄存器到进程陷阱帧</li>
<li>陷阱处理过程</li>
<li>恢复用户寄存器，返回用户空间</li>
</ol>
<p>而当添加了alarm后，变成了以下过程</p>
<ol>
<li>进入内核空间，保存用户寄存器到进程陷阱帧</li>
<li>陷阱处理过程</li>
<li>恢复用户寄存器，返回用户空间，但此时返回的并不是进入陷阱时的程序地址，而是处理函数<code>handler</code>的地址，而<code>handler</code>可能会改变用户寄存器</li>
</ol>
<p>因此我们要在<code>usertrap</code>中再次保存用户寄存器，当<code>handler</code>调用<code>sigreturn</code>时将其恢复，并且要防止在<code>handler</code>执行过程中重复调用，过程如下</p>
<p><strong>(1)</strong>. 再在<code>struct proc</code>中新增两个字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> is_alarming;                    <span class="comment">// 是否正在执行告警处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span>* <span class="title">alarm_trapframe</span>;</span>  <span class="comment">// 告警陷阱帧</span></span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong>. 在allocproc和freeproc中设定好相关分配，回收内存的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * allocproc.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 初始化告警字段</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;alarm_trapframe = (<span class="keyword">struct</span> trapframe*)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;is_alarming = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">p-&gt;ticks_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * freeproc.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;alarm_trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;alarm_trapframe);</span><br><span class="line">p-&gt;alarm_trapframe = <span class="number">0</span>;</span><br><span class="line">p-&gt;is_alarming = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">p-&gt;ticks_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>(3)</strong>. 更改usertrap函数，保存进程陷阱帧<code>p-&gt;trapframe</code>到<code>p-&gt;alarm_trapframe</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarm_interval != <span class="number">0</span> &amp;&amp; ++p-&gt;ticks_count == p-&gt;alarm_interval &amp;&amp; p-&gt;is_alarming == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存寄存器内容</span></span><br><span class="line">    memmove(p-&gt;alarm_trapframe, p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="comment">// 更改陷阱帧中保留的程序计数器，注意一定要在保存寄存器内容后再设置epc</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">    p-&gt;ticks_count = <span class="number">0</span>;</span><br><span class="line">    p-&gt;is_alarming = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4)</strong>. 更改<code>sys_sigreturn</code>，恢复陷阱帧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  memmove(myproc()-&gt;trapframe, myproc()-&gt;alarm_trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  myproc()-&gt;is_alarming = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab1/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="lab1-Util"><a href="#lab1-Util" class="headerlink" title="lab1: Util"></a>lab1: Util</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>这个简单，不多说了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123; <span class="comment">//参数错误</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep &lt;time&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>使用两个管道进行父子进程通信，需要注意的是如果管道的写端没有<code>close</code>，那么管道中数据为空时对管道的读取将会阻塞。因此对于不需要的管道描述符，要尽可能早的关闭。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD 0 <span class="comment">//pipe的read端</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR 1 <span class="comment">//pipe的write端</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf = <span class="string">&#x27;P&#x27;</span>; <span class="comment">//用于传送的字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_c2p[<span class="number">2</span>]; <span class="comment">//子进程-&gt;父进程</span></span><br><span class="line">    <span class="type">int</span> fd_p2c[<span class="number">2</span>]; <span class="comment">//父进程-&gt;子进程</span></span><br><span class="line">    pipe(fd_c2p);</span><br><span class="line">    pipe(fd_p2c);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> exit_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork() error!\n&quot;</span>);</span><br><span class="line">        close(fd_c2p[RD]);</span><br><span class="line">        close(fd_c2p[WR]);</span><br><span class="line">        close(fd_p2c[RD]);</span><br><span class="line">        close(fd_p2c[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line">        close(fd_p2c[WR]);</span><br><span class="line">        close(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(fd_p2c[RD], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">char</span>)) != <span class="keyword">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child read() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(fd_c2p[WR], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">char</span>)) != <span class="keyword">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child write() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(fd_p2c[RD]);</span><br><span class="line">        close(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程</span></span><br><span class="line">        close(fd_p2c[RD]);</span><br><span class="line">        close(fd_c2p[WR]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(fd_p2c[WR], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">char</span>)) != <span class="keyword">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent write() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(fd_c2p[RD], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">char</span>)) != <span class="keyword">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent read() error!\n&quot;</span>);</span><br><span class="line">            exit_status = <span class="number">1</span>; <span class="comment">//标记出错</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(fd_p2c[WR]);</span><br><span class="line">        close(fd_c2p[RD]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>这个感觉还是有些难度的，它的思想是多进程版本的递归，不断地将左邻居管道中的数据筛选后传送给右邻居，每次传送的第一个数据都将是一个素数。</p>
<p>具体还是看代码吧，里面注释应该还是比较清楚的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> uint INT_LEN = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取左邻居的第一个数据</span></span><br><span class="line"><span class="comment"> * @param lpipe 左邻居的管道符</span></span><br><span class="line"><span class="comment"> * @param pfirst 用于存储第一个数据的地址</span></span><br><span class="line"><span class="comment"> * @return 如果没有数据返回-1,有数据返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lpipe_first_data</span><span class="params">(<span class="type">int</span> lpipe[<span class="number">2</span>], <span class="type">int</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (read(lpipe[RD], dst, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="keyword">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, *dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取左邻居的数据，将不能被first整除的写入右邻居</span></span><br><span class="line"><span class="comment"> * @param lpipe 左邻居的管道符</span></span><br><span class="line"><span class="comment"> * @param rpipe 右邻居的管道符</span></span><br><span class="line"><span class="comment"> * @param first 左邻居的第一个数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">transmit_data</span><span class="params">(<span class="type">int</span> lpipe[<span class="number">2</span>], <span class="type">int</span> rpipe[<span class="number">2</span>], <span class="type">int</span> first)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="comment">// 从左管道读取数据</span></span><br><span class="line">  <span class="keyword">while</span> (read(lpipe[RD], &amp;data, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="keyword">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="comment">// 将无法整除的数据传递入右管道</span></span><br><span class="line">    <span class="keyword">if</span> (data % first)</span><br><span class="line">      write(rpipe[WR], &amp;data, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  close(lpipe[RD]);</span><br><span class="line">  close(rpipe[WR]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 寻找素数</span></span><br><span class="line"><span class="comment"> * @param lpipe 左邻居管道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> lpipe[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">  close(lpipe[WR]);</span><br><span class="line">  <span class="type">int</span> first;</span><br><span class="line">  <span class="keyword">if</span> (lpipe_first_data(lpipe, &amp;first) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    pipe(p); <span class="comment">// 当前的管道</span></span><br><span class="line">    transmit_data(lpipe, p, first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">      primes(p);    <span class="comment">// 递归的思想，但这将在一个新的进程中调用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      close(p[RD]);</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  pipe(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i) <span class="comment">//写入初始数据</span></span><br><span class="line">    write(p[WR], &amp;i, INT_LEN);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    primes(p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[WR]);</span><br><span class="line">    close(p[RD]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>感觉没什么好说的0.0，代码基本上都是COPY的<em>ls.c</em>中的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot fstat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//参数错误，find的第一个参数必须是目录</span></span><br><span class="line">  <span class="keyword">if</span> (st.type != T_DIR) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find &lt;DIRECTORY&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">  p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">  *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">//p指向最后一个&#x27;/&#x27;之后</span></span><br><span class="line">  <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span> de) == <span class="keyword">sizeof</span> de) &#123;</span><br><span class="line">    <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    memmove(p, de.name, DIRSIZ); <span class="comment">//添加路径名称</span></span><br><span class="line">    p[DIRSIZ] = <span class="number">0</span>;               <span class="comment">//字符串结束标志</span></span><br><span class="line">    <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要在“.”和“..”目录中递归</span></span><br><span class="line">    <span class="keyword">if</span> (st.type == T_DIR &amp;&amp; <span class="built_in">strcmp</span>(p, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(p, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      find(buf, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename, p) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find &lt;directory&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>之前这个题目我是做错的，但是仍然通过了测试。需要注意的是题目中要求为每一行执行一个命令。之前刷力扣的时候处理字符串好几次用到了有限状态自动机，虽然写的代码比较多，但是只要搞清楚逻辑，这种方法反而比较容易写出来。</p>
<p>xv6中的<code>echo</code>命令并不能输出换行符，例如在xv6和linux中执行命令</p>
<p>xv6执行<code>echo &quot;1\n2&quot;</code>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1\n2&quot;</span><br></pre></td></tr></table></figure>

<p>linux执行<code>echo -e &quot;1\n2&quot;</code>输出（<code>-e</code>启用转义）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>因此没有想到如何在xv6中验证<code>xargs</code>的正确性，于是我将类似（类似是因为头文件不同，且将<code>exec</code>替换为了<code>execvp</code>）的代码<em>xargs.c</em>在linux下编译并测试运行，如下图所示：第一条命令是使用linux中<code>xargs</code>的输出，第二条命令是使用自己写的<code>xargs</code>的输出，二者是一致的。</p>
<p><img src="/images/p3.png" alt="img"></p>
<p>有限状态自动机主要就是一系列的状态转换，例如对于</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1 \n 23</span><br><span class="line">0123 456</span><br></pre></td></tr></table></figure>

<p>来说，第一行是待读取的字符串，第二行是字符下标，起始时状态为<code>S_WAIT</code>，状态转换如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">读取到0处的空格  状态由S_WAIT变为S_WAIT，继续等待参数到来（arg_beg前移）</span><br><span class="line">读取到1处的字符1 状态由S_WAIT变为S_ARG，开始读取参数（arg_beg不动）</span><br><span class="line">读取到2处的空格  状态由S_ARG变为S_ARG_END，储存参数地址（将lines[arg_beg]的地址存入x_argv中）</span><br><span class="line">读取到3处的换行  状态由S_ARG_END变为S_LINE_END，fork后执行程序</span><br><span class="line">...以此类推</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSZ 512</span></span><br><span class="line"><span class="comment">// 有限状态自动机状态定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  S_WAIT,         <span class="comment">// 等待参数输入，此状态为初始状态或当前字符为空格</span></span><br><span class="line">  S_ARG,          <span class="comment">// 参数内</span></span><br><span class="line">  S_ARG_END,      <span class="comment">// 参数结束</span></span><br><span class="line">  S_ARG_LINE_END, <span class="comment">// 左侧有参数的换行，例如&quot;arg\n&quot;</span></span><br><span class="line">  S_LINE_END,     <span class="comment">// 左侧为空格的换行，例如&quot;arg  \n&quot;&quot;</span></span><br><span class="line">  S_END           <span class="comment">// 结束，EOF</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符类型定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">char_type</span> &#123;</span></span><br><span class="line">  C_SPACE,</span><br><span class="line">  C_CHAR,</span><br><span class="line">  C_LINE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取字符类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param c 待判定的字符</span></span><br><span class="line"><span class="comment"> * @return enum char_type 字符类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> char_type <span class="title function_">get_char_type</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> C_SPACE;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> C_LINE_END;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> C_CHAR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 状态转换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param cur 当前的状态</span></span><br><span class="line"><span class="comment"> * @param ct 将要读取的字符</span></span><br><span class="line"><span class="comment"> * @return enum state 转换后的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> state <span class="title function_">transform_state</span><span class="params">(<span class="keyword">enum</span> state cur, <span class="keyword">enum</span> char_type ct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (cur) &#123;</span><br><span class="line">  <span class="keyword">case</span> S_WAIT:</span><br><span class="line">    <span class="keyword">if</span> (ct == C_SPACE)    <span class="keyword">return</span> S_WAIT;</span><br><span class="line">    <span class="keyword">if</span> (ct == C_LINE_END) <span class="keyword">return</span> S_LINE_END;</span><br><span class="line">    <span class="keyword">if</span> (ct == C_CHAR)     <span class="keyword">return</span> S_ARG;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> S_ARG:</span><br><span class="line">    <span class="keyword">if</span> (ct == C_SPACE)    <span class="keyword">return</span> S_ARG_END;</span><br><span class="line">    <span class="keyword">if</span> (ct == C_LINE_END) <span class="keyword">return</span> S_ARG_LINE_END;</span><br><span class="line">    <span class="keyword">if</span> (ct == C_CHAR)     <span class="keyword">return</span> S_ARG;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> S_ARG_END:</span><br><span class="line">  <span class="keyword">case</span> S_ARG_LINE_END:</span><br><span class="line">  <span class="keyword">case</span> S_LINE_END:</span><br><span class="line">    <span class="keyword">if</span> (ct == C_SPACE)    <span class="keyword">return</span> S_WAIT;</span><br><span class="line">    <span class="keyword">if</span> (ct == C_LINE_END) <span class="keyword">return</span> S_LINE_END;</span><br><span class="line">    <span class="keyword">if</span> (ct == C_CHAR)     <span class="keyword">return</span> S_ARG;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> S_END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将参数列表后面的元素全部置为空</span></span><br><span class="line"><span class="comment"> *        用于换行时，重新赋予参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x_argv 参数指针数组</span></span><br><span class="line"><span class="comment"> * @param beg 要清空的起始下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearArgv</span><span class="params">(<span class="type">char</span> *x_argv[MAXARG], <span class="type">int</span> beg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = beg; i &lt; MAXARG; ++i)</span><br><span class="line">    x_argv[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc - <span class="number">1</span> &gt;= MAXARG) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: too many arguments.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> lines[MAXSZ];</span><br><span class="line">  <span class="type">char</span> *p = lines;</span><br><span class="line">  <span class="type">char</span> *x_argv[MAXARG] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 参数指针数组，全部初始化为空指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储原有的参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">    x_argv[i - <span class="number">1</span>] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> arg_beg = <span class="number">0</span>;          <span class="comment">// 参数起始下标</span></span><br><span class="line">  <span class="type">int</span> arg_end = <span class="number">0</span>;          <span class="comment">// 参数结束下标</span></span><br><span class="line">  <span class="type">int</span> arg_cnt = argc - <span class="number">1</span>;   <span class="comment">// 当前参数索引</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">st</span> =</span> S_WAIT;   <span class="comment">// 起始状态置为S_WAIT</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (st != S_END) &#123;</span><br><span class="line">    <span class="comment">// 读取为空则退出</span></span><br><span class="line">    <span class="keyword">if</span> (read(<span class="number">0</span>, p, <span class="keyword">sizeof</span>(<span class="type">char</span>)) != <span class="keyword">sizeof</span>(<span class="type">char</span>)) &#123;</span><br><span class="line">      st = S_END;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      st = transform_state(st, get_char_type(*p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++arg_end &gt;= MAXSZ) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: arguments too long.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st) &#123;</span><br><span class="line">    <span class="keyword">case</span> S_WAIT:          <span class="comment">// 这种情况下只需要让参数起始指针前移</span></span><br><span class="line">      ++arg_beg;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_ARG_END:       <span class="comment">// 参数结束，将参数地址存入x_argv数组中</span></span><br><span class="line">      x_argv[arg_cnt++] = &amp;lines[arg_beg];</span><br><span class="line">      arg_beg = arg_end;</span><br><span class="line">      *p = <span class="string">&#x27;\0&#x27;</span>;          <span class="comment">// 替换为字符串结束符</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_ARG_LINE_END:  <span class="comment">// 将参数地址存入x_argv数组中同时执行指令</span></span><br><span class="line">      x_argv[arg_cnt++] = &amp;lines[arg_beg];</span><br><span class="line">      <span class="comment">// 不加break，因为后续处理同S_LINE_END</span></span><br><span class="line">    <span class="keyword">case</span> S_LINE_END:      <span class="comment">// 行结束，则为当前行执行指令</span></span><br><span class="line">      arg_beg = arg_end;</span><br><span class="line">      *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        exec(argv[<span class="number">1</span>], x_argv);</span><br><span class="line">      &#125;</span><br><span class="line">      arg_cnt = argc - <span class="number">1</span>;</span><br><span class="line">      clearArgv(x_argv, arg_cnt);</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++p;    <span class="comment">// 下一个字符的存储位置后移</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/labs/answers/lab10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/labs/answers/lab10/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:44" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/labs/answers/lab10/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/labs/answers/lab10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab10-mmap"><a href="#Lab10-mmap" class="headerlink" title="Lab10: mmap"></a>Lab10: mmap</h1><p>本实验是实现一个内存映射文件的功能，将文件映射到内存中，从而在与文件交互时减少磁盘操作。</p>
<p>(1). 根据提示1，首先是配置<code>mmap</code>和<code>munmap</code>系统调用，此前已进行过多次类似流程，不再赘述。在<em><strong>kernel&#x2F;fcntl.h</strong></em>中定义了宏，只有在定义了<code>LAB_MMAP</code>时这些宏才生效，而<code>LAB_MMAP</code>是在编译时在命令行通过gcc的<code>-D</code>参数定义的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">int</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">int</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>(2). 根据提示3，定义VMA结构体，并添加到进程结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NVMA 16</span></span><br><span class="line"><span class="comment">// 虚拟内存区域结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> used;           <span class="comment">// 是否已被使用</span></span><br><span class="line">  uint64 addr;        <span class="comment">// 起始地址</span></span><br><span class="line">  <span class="type">int</span> len;            <span class="comment">// 长度</span></span><br><span class="line">  <span class="type">int</span> prot;           <span class="comment">// 权限</span></span><br><span class="line">  <span class="type">int</span> flags;          <span class="comment">// 标志位</span></span><br><span class="line">  <span class="type">int</span> vfd;            <span class="comment">// 对应的文件描述符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">vfile</span>;</span> <span class="comment">// 对应文件</span></span><br><span class="line">  <span class="type">int</span> offset;         <span class="comment">// 文件偏移，本实验中一直为0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area</span> <span class="title">vma</span>[<span class="title">NVMA</span>];</span>    <span class="comment">// 虚拟内存区域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3). 在allocproc中将vma数组初始化为全0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;vma, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;vma));</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4). 根据提示2、3、4，参考lazy实验中的分配方法（将当前<code>p-&gt;sz</code>作为分配的虚拟起始地址，但不实际分配物理页面），此函数写在<em><strong>sysfile.c</strong></em>中就可以使用静态函数<code>argfd</code>同时解析文件描述符和<code>struct file</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">int</span> prot;</span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">int</span> vfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">vfile</span>;</span></span><br><span class="line">  <span class="type">int</span> offset;</span><br><span class="line">  uint64 err = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取系统调用参数</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> ||</span><br><span class="line">    argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>, &amp;vfd, &amp;vfile) &lt; <span class="number">0</span> || argint(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实验提示中假定addr和offset为0，简化程序可能发生的情况</span></span><br><span class="line">  <span class="keyword">if</span>(addr != <span class="number">0</span> || offset != <span class="number">0</span> || length &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件不可写则不允许拥有PROT_WRITE权限时映射为MAP_SHARED</span></span><br><span class="line">  <span class="keyword">if</span>(vfile-&gt;writable == <span class="number">0</span> &amp;&amp; (prot &amp; PROT_WRITE) != <span class="number">0</span> &amp;&amp; flags == MAP_SHARED)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 没有足够的虚拟地址空间</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;sz + length &gt; MAXVA)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历查找未使用的VMA结构体</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NVMA; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;vma[i].used = <span class="number">1</span>;</span><br><span class="line">      p-&gt;vma[i].addr = p-&gt;sz;</span><br><span class="line">      p-&gt;vma[i].len = length;</span><br><span class="line">      p-&gt;vma[i].flags = flags;</span><br><span class="line">      p-&gt;vma[i].prot = prot;</span><br><span class="line">      p-&gt;vma[i].vfile = vfile;</span><br><span class="line">      p-&gt;vma[i].vfd = vfd;</span><br><span class="line">      p-&gt;vma[i].offset = offset;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 增加文件的引用计数</span></span><br><span class="line">      filedup(vfile);</span><br><span class="line"></span><br><span class="line">      p-&gt;sz += length;</span><br><span class="line">      <span class="keyword">return</span> p-&gt;vma[i].addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5). 根据提示5，此时访问对应的页面就会产生页面错误，需要在<code>usertrap</code>中进行处理，主要完成三项工作：分配物理页面，读取文件内容，添加映射关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(cause == <span class="number">8</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cause == <span class="number">13</span> || cause == <span class="number">15</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_MMAP</span></span><br><span class="line">    <span class="comment">// 读取产生页面故障的虚拟地址，并判断是否位于有效区间</span></span><br><span class="line">    uint64 fault_va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="number">1</span> &lt; fault_va &amp;&amp; fault_va &lt; p-&gt;sz) &#123;</span><br><span class="line">      <span class="keyword">if</span>(mmap_handler(r_stval(), cause) != <span class="number">0</span>) p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief mmap_handler 处理mmap惰性分配导致的页面错误</span></span><br><span class="line"><span class="comment"> * @param va 页面故障虚拟地址</span></span><br><span class="line"><span class="comment"> * @param cause 页面故障原因</span></span><br><span class="line"><span class="comment"> * @return 0成功，-1失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> mmap_handler(<span class="type">int</span> va, <span class="type">int</span> cause) &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 根据地址查找属于哪一个VMA</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used &amp;&amp; p-&gt;vma[i].addr &lt;= va &amp;&amp; va &lt;= p-&gt;vma[i].addr + p-&gt;vma[i].len - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i == NVMA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pte_flags = PTE_U;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;vma[i].prot &amp; PROT_READ) pte_flags |= PTE_R;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;vma[i].prot &amp; PROT_WRITE) pte_flags |= PTE_W;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;vma[i].prot &amp; PROT_EXEC) pte_flags |= PTE_X;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">vf</span> =</span> p-&gt;vma[i].vfile;</span><br><span class="line">  <span class="comment">// 读导致的页面错误</span></span><br><span class="line">  <span class="keyword">if</span>(cause == <span class="number">13</span> &amp;&amp; vf-&gt;readable == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 写导致的页面错误</span></span><br><span class="line">  <span class="keyword">if</span>(cause == <span class="number">15</span> &amp;&amp; vf-&gt;writable == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件内容</span></span><br><span class="line">  ilock(vf-&gt;ip);</span><br><span class="line">  <span class="comment">// 计算当前页面读取文件的偏移量，实验中p-&gt;vma[i].offset总是0</span></span><br><span class="line">  <span class="comment">// 要按顺序读读取，例如内存页面A,B和文件块a,b</span></span><br><span class="line">  <span class="comment">// 则A读取a，B读取b，而不能A读取b，B读取a</span></span><br><span class="line">  <span class="type">int</span> offset = p-&gt;vma[i].offset + PGROUNDDOWN(va - p-&gt;vma[i].addr);</span><br><span class="line">  <span class="type">int</span> readbytes = readi(vf-&gt;ip, <span class="number">0</span>, (uint64)pa, offset, PGSIZE);</span><br><span class="line">  <span class="comment">// 什么都没有读到</span></span><br><span class="line">  <span class="keyword">if</span>(readbytes == <span class="number">0</span>) &#123;</span><br><span class="line">    iunlock(vf-&gt;ip);</span><br><span class="line">    kfree(pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(vf-&gt;ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加页面映射</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)pa, pte_flags) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree(pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(6). 根据提示6实现<code>munmap</code>，且提示7中说明无需查看脏位就可写回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used &amp;&amp; p-&gt;vma[i].len &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 根据提示，munmap的地址范围只能是</span></span><br><span class="line">      <span class="comment">// 1. 起始位置</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[i].addr == addr) &#123;</span><br><span class="line">        p-&gt;vma[i].addr += length;</span><br><span class="line">        p-&gt;vma[i].len -= length;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2. 结束位置</span></span><br><span class="line">      <span class="keyword">if</span>(addr + length == p-&gt;vma[i].addr + p-&gt;vma[i].len) &#123;</span><br><span class="line">        p-&gt;vma[i].len -= length;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i == NVMA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将MAP_SHARED页面写回文件系统</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;vma[i].flags == MAP_SHARED &amp;&amp; (p-&gt;vma[i].prot &amp; PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    filewrite(p-&gt;vma[i].vfile, addr, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断此页面是否存在映射</span></span><br><span class="line">  uvmunmap(p-&gt;pagetable, addr, length / PGSIZE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前VMA中全部映射都被取消</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;vma[i].len == <span class="number">0</span>) &#123;</span><br><span class="line">    fileclose(p-&gt;vma[i].vfile);</span><br><span class="line">    p-&gt;vma[i].used = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(7). 回忆lazy实验中，如果对惰性分配的页面调用了<code>uvmunmap</code>，或者子进程在fork中调用<code>uvmcopy</code>复制了父进程惰性分配的页面都会导致panic，因此需要修改<code>uvmunmap</code>和<code>uvmcopy</code>检查<code>PTE_V</code>后不再<code>panic</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>(8). 根据提示8修改<code>exit</code>，将进程的已映射区域取消映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Close all open files.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将进程的已映射区域取消映射</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NVMA; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[i].flags == MAP_SHARED &amp;&amp; (p-&gt;vma[i].prot &amp; PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        filewrite(p-&gt;vma[i].vfile, p-&gt;vma[i].addr, p-&gt;vma[i].len);</span><br><span class="line">      &#125;</span><br><span class="line">      fileclose(p-&gt;vma[i].vfile);</span><br><span class="line">      uvmunmap(p-&gt;pagetable, p-&gt;vma[i].addr, p-&gt;vma[i].len / PGSIZE, <span class="number">1</span>);</span><br><span class="line">      p-&gt;vma[i].used = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(9). 根据提示9，修改<code>fork</code>，复制父进程的VMA并增加文件引用计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    ...</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复制父进程的VMA</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used) &#123;</span><br><span class="line">      memmove(&amp;np-&gt;vma[i], &amp;p-&gt;vma[i], <span class="keyword">sizeof</span>(p-&gt;vma[i]));</span><br><span class="line">      filedup(p-&gt;vma[i].vfile);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/MIT-6-828/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/MIT-6-828/" class="post-title-link" itemprop="url">MIT 6.828</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:04:42 / Modified: 23:07:10" itemprop="dateCreated datePublished" datetime="2022-10-06T23:04:42+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/MIT-6-828/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/MIT-6-828/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><a href="README-MIT-6-828.md">课程介绍</a></li>
</ul>
<h2 id="文档翻译"><a href="#文档翻译" class="headerlink" title="文档翻译"></a>文档翻译</h2><ul>
<li><a href="tranlate_books/book-riscv-rev1/summary.md">book-riscv-rev1</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c1/s0.md">第一章 操作系统接口</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c1/s1.md">1.1 进程和内存</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c1/s2.md">1.2 I&#x2F;O和文件描述符</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c1/s3.md">1.3 管道</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c1/s4.md">1.4 文件系统</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c1/s5.md">1.5 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c1/s6.md">1.6 练习</a></li>
</ul>
</li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s0.md">第二章 操作系统架构</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c2/s1.md">2.1 抽象系统资源</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s2.md">2.2 用户态，核心态，以及系统调用</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s3.md">2.3 内核组织</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s4.md">2.4 代码：XV6架构篇</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s5.md">2.5 进程概述</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s6.md">2.6 代码：启动XV6和第一个进程</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s7.md">2.7 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c2/s8.md">2.8 练习</a></li>
</ul>
</li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s0.md">第三章 页表</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c3/s1.md">3.1 页式硬件</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s2.md">3.2 内核地址空间</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s3.md">3.3 代码：创建一个地址空间</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s4.md">3.4 物理内存分配</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s5.md">3.5 代码：物理内存分配</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s6.md">3.6 进程地址空间</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s7.md">3.7 代码：sbrk</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s8.md">3.8 代码：exec</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s9.md">3.9 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c3/s10.md">3.10 练习</a></li>
</ul>
</li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s0.md">第四章 陷阱指令和系统调用</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c4/s1.md">4.1 RISC-V陷入机制</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s2.md">4.2 从用户空间陷入</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s3.md">4.3 代码：调用系统调用</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s4.md">4.4 系统调用参数</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s5.md">4.5 从内核空间陷入</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s6.md">4.6 页面错误异常</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s7.md">4.7 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c4/s8.md">4.8 练习</a></li>
</ul>
</li>
<li><a href="tranlate_books/book-riscv-rev1/c5/s0.md">第五章 中断和设备驱动</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c5/s1.md">5.1 代码：控制台输入</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c5/s2.md">5.2 代码：控制台输出</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c5/s3.md">5.3 驱动中的并发</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c5/s4.md">5.4 定时器中断</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c5/s5.md">5.5 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c5/s6.md">5.6 练习</a></li>
</ul>
</li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s0.md">第六章 锁</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c6/s1.md">6.1 竞态条件</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s2.md">6.2 代码：Locks</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s3.md">6.3 代码：使用锁</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s4.md">6.4  死锁和锁排序</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s5.md">6.5 锁和中断处理函数</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s6.md">6.6 指令和内存访问排序</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s7.md">6.7 睡眠锁</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s8.md">6.8 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c6/s9.md">6.9 练习</a></li>
</ul>
</li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s0.md">第七章  调度</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c7/s1.md">7.1 多路复用</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s2.md">7.2 代码：上下文切换</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s3.md">7.3 代码：调度</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s4.md">7.4 代码：mycpu和myproc</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s5.md">7.5 sleep与wakeup</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s6.md">7.6 代码：sleep和wakeup</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s7.md">7.7 代码：Pipes</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s8.md">7.8 代码：wait, exit和kill</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s9.md">7.9 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c7/s10.md">7.10 练习</a></li>
</ul>
</li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s0.md">第八章 文件系统</a><ul>
<li><a href="tranlate_books/book-riscv-rev1/c8/s1.md">8.1 概述</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s2.md">8.2 Buffer cache层</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s3.md">8.3 代码：Buffer cache</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s4.md">8.4 日志层</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s5.md">8.5 日志设计</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s6.md">8.6 代码：日志</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s7.md">8.7 代码：块分配器</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s8.md">8.8 索引结点层</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s9.md">8.9 代码：Inodes</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s10.md">8.10 代码： Inode包含内容</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s11.md">8.11 代码：目录层</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s12.md">8.12 代码：路径名</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s13.md">8.13 文件描述符层</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s14.md">8.14 代码：系统调用</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s15.md">8.15 真实世界</a></li>
<li><a href="tranlate_books/book-riscv-rev1/c8/s16.md">8.16 练习</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="tranlate_books/Introduction.md">Introduction</a></li>
<li>[使用GNU Debugger](tranlate_books&#x2F;Use GUN Debugger.md)</li>
<li>[C Pointers, gdb](tranlate_books&#x2F;C Pointers, gdb.md)</li>
<li>[Calling Convention](tranlate_books&#x2F;Calling Convention.md)</li>
<li>[Journaling the Linux ext2fs Filesystem](tranlate_books&#x2F;Journaling the Linux ext2fs Filesystem.md)</li>
</ul>
<h2 id="实验记录"><a href="#实验记录" class="headerlink" title="实验记录"></a>实验记录</h2><ul>
<li><a href="labs/use_git/git1.md">版本控制</a></li>
<li><a href="labs/requirements/summary.md">实验内容</a><ul>
<li><a href="labs/requirements/lab1.md">Lab1: Xv6 and Unix utilities</a></li>
<li><a href="labs/requirements/lab2.md">Lab2: System calls</a></li>
<li><a href="labs/requirements/lab3.md">Lab3: Page tables</a></li>
<li><a href="labs/requirements/lab4.md">Lab4: Traps</a></li>
<li><a href="labs/requirements/lab5.md">Lab5: Xv6 lazy page allocation</a></li>
<li><a href="labs/requirements/lab6.md">Lab6: Copy-on-Write Fork for xv6</a></li>
<li><a href="labs/requirements/lab7.md">Lab7: Multithreading</a></li>
<li><a href="labs/requirements/lab8.md">Lab8: Locks</a></li>
<li><a href="labs/requirements/lab9.md">Lab9: File system</a></li>
<li><a href="labs/requirements/lab10.md">Lab10: Mmap</a></li>
<li><a href="labs/requirements/lab11.md">Lab11: Network</a></li>
</ul>
</li>
<li><a href="labs/answers/summary.md">实验解析</a><ul>
<li><a href="labs/answers/lab1.md">Lab1: Util</a></li>
<li><a href="labs/answers/lab2.md">Lab2: Syscall</a></li>
<li><a href="labs/answers/lab3.md">Lab3: Pgtbl</a></li>
<li><a href="labs/answers/lab4.md">Lab4: Traps</a></li>
<li><a href="labs/answers/lab5.md">Lab5: Xv6 lazy page allocation</a></li>
<li><a href="labs/answers/lab6.md">Lab6: Copy-on-Write Fork for xv6</a></li>
<li><a href="labs/answers/lab7.md">Lab7: Multithreading</a></li>
<li><a href="labs/answers/lab8.md">Lab8: Locks</a></li>
<li><a href="labs/answers/lab9.md">Lab9: File system</a></li>
<li><a href="labs/answers/lab10.md">Lab10: Mmap</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaoq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nPTQNF98hlhFVhx3uT28h3EW-gzGzoHsz',
      appKey     : 'Hj5CW3nJJnJ3rBlGeKK8XQLa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
