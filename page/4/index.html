<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="肖大强的个人博客">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="肖大强的个人博客">
<meta property="og:locale">
<meta property="article:author" content="xiaoq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>肖大强的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖大强的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s5/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-5-sleep与wakeup"><a href="#7-5-sleep与wakeup" class="headerlink" title="7.5 sleep与wakeup"></a>7.5 sleep与wakeup</h1><p>调度和锁有助于隐藏一个进程对另一个进程的存在，但到目前为止，我们还没有帮助进程进行有意交互的抽象。为解决这个问题已经发明了许多机制。Xv6使用了一种称为<code>sleep</code>和<code>wakeup</code>的方法，它允许一个进程在等待事件时休眠，而另一个进程在事件发生后将其唤醒。睡眠和唤醒通常被称为序列协调（sequence coordination）或条件同步机制（conditional synchronization mechanisms）。</p>
<p>为了说明，让我们考虑一个称为信号量（semaphore）的同步机制，它可以协调生产者和消费者。信号量维护一个计数并提供两个操作。“V”操作（对于生产者）增加计数。“P”操作（对于使用者）等待计数为非零，然后递减并返回。如果只有一个生产者线程和一个消费者线程，并且它们在不同的CPU上执行，并且编译器没有进行过积极的优化，那么此实现将是正确的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现代价昂贵。如果生产者很少采取行动，消费者将把大部分时间花在<code>while</code>循环中，希望得到非零计数。消费者的CPU可以找到比通过反复轮询<code>s-&gt;count</code>繁忙等待更有成效的工作。要避免繁忙等待，消费者需要一种方法来释放CPU，并且只有在<code>V</code>增加计数后才能恢复。</p>
<p>这是朝着这个方向迈出的一步，尽管我们将看到这是不够的。让我们想象一对调用，<code>sleep</code>和<code>wakeup</code>，工作流程如下。<code>Sleep(chan)</code>在任意值<code>chan</code>上睡眠，称为等待通道（wait channel）。<code>Sleep</code>将调用进程置于睡眠状态，释放CPU用于其他工作。<code>Wakeup(chan)</code>唤醒所有在<code>chan</code>上睡眠的进程（如果有），使其<code>sleep</code>调用返回。如果没有进程在<code>chan</code>上等待，则<code>wakeup</code>不执行任何操作。我们可以将信号量实现更改为使用<code>sleep</code>和<code>wakeup</code>（更改的行添加了注释）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);  <span class="comment">// !pay attention</span></span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        sleep(s);  <span class="comment">// !pay attention</span></span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>P</code>现在放弃CPU而不是自旋，这很好。然而，事实证明，使用此接口设计<code>sleep</code>和<code>wakeup</code>而不遭受所谓的丢失唤醒（lost wake-up）问题并非易事。假设<code>P</code>在第9行发现<code>s-&gt;count==0</code>。当<code>P</code>在第9行和第10行之间时，<code>V</code>在另一个CPU上运行：它将<code>s-&gt;count</code>更改为非零，并调用<code>wakeup</code>，这样就不会发现进程处于休眠状态，因此不会执行任何操作。现在P继续在第10行执行：它调用<code>sleep</code>并进入睡眠。这会导致一个问题：<code>P</code>正在休眠，等待调用<code>V</code>，而<code>V</code>已经被调用。除非我们运气好，生产者再次呼叫<code>V</code>，否则消费者将永远等待，即使<code>count</code>为非零。</p>
<p>这个问题的根源是<code>V</code>在错误的时刻运行，违反了<code>P</code>仅在<code>s-&gt;count==0</code>时才休眠的不变量。保护不变量的一种不正确的方法是将锁的获取（下面以黄色突出显示）移动到<code>P</code>中，以便其检查<code>count</code>和调用<code>sleep</code>是原子的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);  <span class="comment">// !pay attention</span></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        sleep(s);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>人们可能希望这个版本的<code>P</code>能够避免丢失唤醒，因为锁阻止<code>V</code>在第10行和第11行之间执行。它确实这样做了，但它会导致死锁：<code>P</code>在睡眠时持有锁，因此<code>V</code>将永远阻塞等待锁。</p>
<p>我们将通过更改<code>sleep</code>的接口来修复前面的方案：调用方必须将条件锁（condition lock）传递给sleep，以便在调用进程被标记为asleep并在睡眠通道上等待后<code>sleep</code>可以释放锁。如果有一个并发的<code>V</code>操作，锁将强制它在<code>P</code>将自己置于睡眠状态前一直等待，因此<code>wakeup</code>将找到睡眠的消费者并将其唤醒。一旦消费者再次醒来，<code>sleep</code>会在返回前重新获得锁。我们新的正确的<code>sleep/wakeup</code>方案可用如下（更改以黄色突出显示）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> &#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        sleep(s, &amp;s-&gt;lock);  <span class="comment">// !pay attention</span></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>P</code>持有<code>s-&gt;lock</code>的事实阻止<code>V</code>在<code>P</code>检查<code>s-&gt;count</code>和调用<code>sleep</code>之间试图唤醒它。然而请注意，我们需要<code>sleep</code>释放<code>s-&gt;lock</code>并使消费者进程进入睡眠状态的操作是原子的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s6/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-6-代码：sleep和wakeup"><a href="#7-6-代码：sleep和wakeup" class="headerlink" title="7.6 代码：sleep和wakeup"></a>7.6 代码：sleep和wakeup</h1><p>让我们看看<code>sleep</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:548）和<code>wakeup</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:582）的实现。其基本思想是让<code>sleep</code>将当前进程标记为<code>SLEEPING</code>，然后调用<code>sched</code>释放CPU；<code>wakeup</code>查找在给定等待通道上休眠的进程，并将其标记为<code>RUNNABLE</code>。<code>sleep</code>和<code>wakeup</code>的调用者可以使用任何相互间方便的数字作为通道。Xv6通常使用等待过程中涉及的内核数据结构的地址。</p>
<p><code>sleep</code>获得<code>p-&gt;lock</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:559）。要进入睡眠的进程现在同时持有<code>p-&gt;lock</code>和<code>lk</code>。在调用者（示例中为<code>P</code>）中持有<code>lk</code>是必要的：它确保没有其他进程（在示例中指一个运行的<code>V</code>）可以启动<code>wakeup(chan)</code>调用。既然<code>sleep</code>持有<code>p-&gt;lock</code>，那么释放<code>lk</code>是安全的：其他进程可能会启动对<code>wakeup(chan)</code>的调用，但是<code>wakeup</code>将等待获取<code>p-&gt;lock</code>，因此将等待<code>sleep</code>把进程置于睡眠状态的完成，以防止<code>wakeup</code>错过<code>sleep</code>。</p>
<p>还有一个小问题：如果<code>lk</code>和<code>p-&gt;lock</code>是同一个锁，那么如果<code>sleep</code>试图获取<code>p-&gt;lock</code>就会自身死锁。但是，如果调用<code>sleep</code>的进程已经持有<code>p-&gt;lock</code>，那么它不需要做更多的事情来避免错过并发的<code>wakeup</code>。当<code>wait</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:582）持有<code>p-&gt;lock</code>调用<code>sleep</code>时，就会出现这种情况。</p>
<p>由于<code>sleep</code>只持有<code>p-&gt;lock</code>而无其他，它可以通过记录睡眠通道、将进程状态更改为<code>SLEEPING</code>并调用<code>sched</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:564-567）将进程置于睡眠状态。过一会儿，我们就会明白为什么在进程被标记为<code>SLEEPING</code>之前不将<code>p-&gt;lock</code>释放（由<code>scheduler</code>）是至关重要的。</p>
<p>在某个时刻，一个进程将获取条件锁，设置睡眠者正在等待的条件，并调用<code>wakeup(chan)</code>。在持有状态锁时调用<code>wakeup</code>非常重要*[注]<em>。<code>wakeup</code>遍历进程表（</em><strong>kernel&#x2F;proc.c</strong>*:582）。它获取它所检查的每个进程的<code>p-&gt;lock</code>，这既是因为它可能会操纵该进程的状态，也是因为<code>p-&gt;lock</code>确保<code>sleep</code>和<code>wakeup</code>不会彼此错过。当<code>wakeup</code>发现一个<code>SLEEPING</code>的进程且<code>chan</code>相匹配时，它会将该进程的状态更改为<code>RUNNABLE</code>。调度器下次运行时，将看到进程已准备好运行。</p>
<blockquote>
<p>注：严格地说，<code>wakeup</code>只需跟在<code>acquire</code>之后就足够了（也就是说，可以在<code>release</code>之后调用<code>wakeup</code>）</p>
</blockquote>
<p>为什么<code>sleep</code>和<code>wakeup</code>的用锁规则能确保睡眠进程不会错过唤醒？休眠进程从检查条件之前的某处到标记为休眠之后的某处，要么持有条件锁，要么持有其自身的<code>p-&gt;lock</code>或同时持有两者。调用<code>wakeup</code>的进程在<code>wakeup</code>的循环中同时持有这两个锁。因此，要么唤醒器（waker）在消费者线程检查条件之前使条件为真；要么唤醒器的<code>wakeup</code>在睡眠线程标记为<code>SLEEPING</code>后对其进行严格检查。然后<code>wakeup</code>将看到睡眠进程并将其唤醒（除非有其他东西首先将其唤醒）。</p>
<p>有时，多个进程在同一个通道上睡眠；例如，多个进程读取同一个管道。一个单独的<code>wakeup</code>调用就能把他们全部唤醒。其中一个将首先运行并获取与<code>sleep</code>一同调用的锁，并且（在管道例子中）读取在管道中等待的任何数据。尽管被唤醒，其他进程将发现没有要读取的数据。从他们的角度来看，醒来是“虚假的”，他们必须再次睡眠。因此，在检查条件的循环中总是调用<code>sleep</code>。</p>
<p>如果两次使用<code>sleep/wakeup</code>时意外选择了相同的通道，则不会造成任何伤害：它们将看到虚假的唤醒，但如上所述的循环将容忍此问题。<code>sleep/wakeup</code>的魅力在于它既轻量级（不需要创建特殊的数据结构来充当睡眠通道），又提供了一层抽象（调用者不需要知道他们正在与哪个特定进程进行交互）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s8/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-8-代码：wait-exit和kill"><a href="#7-8-代码：wait-exit和kill" class="headerlink" title="7.8 代码：wait, exit和kill"></a>7.8 代码：wait, exit和kill</h1><p><code>Sleep</code>和<code>wakeup</code>可用于多种等待。第一章介绍的一个有趣的例子是子进程<code>exit</code>和父进程<code>wait</code>之间的交互。在子进程死亡时，父进程可能已经在<code>wait</code>中休眠，或者正在做其他事情；在后一种情况下，随后的<code>wait</code>调用必须观察到子进程的死亡，可能是在子进程调用<code>exit</code>后很久。xv6记录子进程终止直到<code>wait</code>观察到它的方式是让<code>exit</code>将调用方置于<code>ZOMBIE</code>状态，在那里它一直保持到父进程的<code>wait</code>注意到它，将子进程的状态更改为<code>UNUSED</code>，复制子进程的<code>exit</code>状态码，并将子进程ID返回给父进程。如果父进程在子进程之前退出，则父进程将子进程交给<code>init</code>进程，<code>init</code>进程将永久调用<code>wait</code>；因此，每个子进程退出后都有一个父进程进行清理。主要的实现挑战是父级和子级<code>wait</code>和<code>exit</code>，以及<code>exit</code>和<code>exit</code>之间可能存在竞争和死锁。</p>
<p><code>Wait</code>使用调用进程的<code>p-&gt;lock</code>作为条件锁，以避免丢失唤醒，并在开始时获取该锁（<em><strong>kernel&#x2F;proc.c</strong></em>:398）。然后它扫描进程表。如果它发现一个子进程处于<code>ZOMBIE</code>状态，它将释放该子进程的资源及其<code>proc</code>结构体，将该子进程的退出状态码复制到提供给<code>wait</code>的地址（如果不是0），并返回该子进程的进程ID。如果<code>wait</code>找到子进程但没有子进程退出，它将调用<code>sleep</code>以等待其中一个退出（<em><strong>kernel&#x2F;proc.c</strong></em>:445），然后再次扫描。这里，<code>sleep</code>中释放的条件锁是等待进程的<code>p-&gt;lock</code>，这是上面提到的特例。注意，<code>wait</code>通常持有两个锁：它在试图获得任何子进程的锁之前先获得自己的锁；因此，整个xv6都必须遵守相同的锁定顺序（父级，然后是子级），以避免死锁。</p>
<p><code>Wait</code>查看每个进程的<code>np-&gt;parent</code>以查找其子进程。它使用<code>np-&gt;parent</code>而不持有<code>np-&gt;lock</code>，这违反了通常的规则，即共享变量必须受到锁的保护。<code>np</code>可能是当前进程的祖先，在这种情况下，获取<code>np-&gt;lock</code>可能会导致死锁，因为这将违反上述顺序。这种情况下无锁检查<code>np-&gt;parent</code>似乎是安全的：进程的<code>parent</code>字段仅由其父进程更改，因此如果<code>np-&gt;parent==p</code>为<code>true</code>，除非当前流程更改它，否则该值无法被更改，</p>
<p><code>Exit</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:333）记录退出状态码，释放一些资源，将所有子进程提供给<code>init</code>进程，在父进程处于等待状态时唤醒父进程，将调用方标记为僵尸进程（zombie），并永久地让出CPU。最后的顺序有点棘手。退出进程必须在将其状态设置为<code>ZOMBIE</code>并唤醒父进程时持有其父进程的锁，因为父进程的锁是防止在<code>wait</code>中丢失唤醒的条件锁。子级还必须持有自己的<code>p-&gt;lock</code>，否则父级可能会看到它处于<code>ZOMBIE</code>状态，并在它仍运行时释放它。锁获取顺序对于避免死锁很重要：因为<code>wait</code>先获取父锁再获取子锁，所以<code>exit</code>必须使用相同的顺序。</p>
<p><code>Exit</code>调用一个专门的唤醒函数<code>wakeup1</code>，该函数仅唤醒父进程，且父进程必须正在<code>wait</code>中休眠（<em><strong>kernel&#x2F;proc.c</strong></em>:598）。在将自身状态设置为<code>ZOMBIE</code>之前，子进程唤醒父进程可能看起来不正确，但这是安全的：虽然<code>wakeup1</code>可能会导致父进程运行，但<code>wait</code>中的循环在<code>scheduler</code>释放子进程的<code>p-&gt;lock</code>之前无法检查子进程，所以<code>wait</code>在<code>exit</code>将其状态设置为<code>ZOMBIE</code>（kernel&#x2F;proc.c:386）之前不能查看退出进程。</p>
<p><code>exit</code>允许进程自行终止，而<code>kill</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:611）允许一个进程请求另一个进程终止。对于<code>kill</code>来说，直接销毁受害者进程（即要杀死的进程）太复杂了，因为受害者可能在另一个CPU上执行，也许是在更新内核数据结构的敏感序列中间。因此，<code>kill</code>的工作量很小：它只是设置受害者的<code>p-&gt;killed</code>，如果它正在睡眠，则唤醒它。受害者进程终将进入或离开内核，此时，如果设置了<code>p-&gt;killed</code>，<code>usertrap</code>中的代码将调用<code>exit</code>。如果受害者在用户空间中运行，它将很快通过进行系统调用或由于计时器（或其他设备）中断而进入内核。</p>
<p>如果受害者进程在<code>sleep</code>中，<code>kill</code>对<code>wakeup</code>的调用将导致受害者从<code>sleep</code>中返回。这存在潜在的危险，因为等待的条件可能不为真。但是，xv6对<code>sleep</code>的调用总是封装在<code>while</code>循环中，该循环在<code>sleep</code>返回后重新测试条件。一些对<code>sleep</code>的调用还在循环中测试<code>p-&gt;killed</code>，如果它被设置，则放弃当前活动。只有在这种放弃是正确的情况下才能这样做。例如，如果设置了<code>killed</code>标志，则管道读写代码返回；最终代码将返回到陷阱，陷阱将再次检查标志并退出。</p>
<p>一些XV6的<code>sleep</code>循环不检查<code>p-&gt;killed</code>，因为代码在应该是原子操作的多步系统调用的中间。virtio驱动程序（<em><strong>kernel&#x2F;virtio_disk.c</strong></em>:242）就是一个例子：它不检查<code>p-&gt;killed</code>，因为一个磁盘操作可能是文件系统保持正确状态所需的一组写入操作之一。等待磁盘I&#x2F;O时被杀死的进程将不会退出，直到它完成当前系统调用并且<code>usertrap</code>看到<code>killed</code>标志</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s7/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-7-代码：Pipes"><a href="#7-7-代码：Pipes" class="headerlink" title="7.7 代码：Pipes"></a>7.7 代码：Pipes</h1><p>使用睡眠和唤醒来同步生产者和消费者的一个更复杂的例子是xv6的管道实现。我们在第1章中看到了管道接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。以后的章节将研究围绕管道的文件描述符支持，但现在让我们看看<code>pipewrite</code>和<code>piperead</code>的实现。</p>
<p>每个管道都由一个<code>struct pipe</code>表示，其中包含一个锁<code>lock</code>和一个数据缓冲区<code>data</code>。字段<code>nread</code>和<code>nwrite</code>统计从缓冲区读取和写入缓冲区的总字节数。缓冲区是环形的：在<code>buf[PIPESIZE-1]</code>之后写入的下一个字节是<code>buf[0]</code>。而计数不是环形。此约定允许实现区分完整缓冲区（<code>nwrite==nread+PIPESIZE</code>）和空缓冲区（<code>nwrite==nread</code>），但这意味着对缓冲区的索引必须使用<code>buf[nread%PIPESIZE]</code>，而不仅仅是<code>buf[nread]</code>（对于<code>nwrite</code>也是如此）。</p>
<p>让我们假设对<code>piperead</code>和<code>pipewrite</code>的调用同时发生在两个不同的CPU上。<code>Pipewrite</code>（<em><strong>kernel&#x2F;pipe.c</strong></em>:77）从获取管道锁开始，它保护计数、数据及其相关不变量。<code>Piperead</code>（<em><strong>kernel&#x2F;pipe.c</strong></em>:103）然后也尝试获取锁，但无法实现。它在<code>acquire</code>（<em><strong>kernel&#x2F;spinlock.c</strong></em>:22）中旋转等待锁。当<code>piperead</code>等待时，<code>pipewrite</code>遍历被写入的字节（<code>addr[0..n-1]</code>），依次将每个字节添加到管道中（<em><strong>kernel&#x2F;pipe.c</strong></em>:95）。在这个循环中缓冲区可能会被填满（<em><strong>kernel&#x2F;pipe.c</strong></em>:85）。在这种情况下，<code>pipewrite</code>调用<code>wakeup</code>来提醒所有处于睡眠状态的读进程缓冲区中有数据等待，然后在<code>&amp;pi-&gt;nwrite</code>上睡眠，等待读进程从缓冲区中取出一些字节。作为使<code>pipewrite</code>进程进入睡眠状态的一部分，<code>Sleep</code>释放<code>pi-&gt;lock</code>。</p>
<p>现在<code>pi-&gt;lock</code>可用，<code>piperead</code>设法获取它并进入其临界区域：它发现<code>pi-&gt;nread != pi-&gt;nwrite</code>（<em><strong>kernel&#x2F;pipe.c</strong></em>:110）（<code>pipewrite</code>进入睡眠状态是因为<code>pi-&gt;nwrite == pi-&gt;nread+PIPESIZE</code>（<em><strong>kernel&#x2F;pipe.c</strong></em>:85）），因此它进入<code>for</code>循环，从管道中复制数据（<em><strong>kernel&#x2F;pipe.c</strong></em>:117），并根据复制的字节数增加<code>nread</code>。那些读出的字节就可供写入，因此<code>piperead</code>调用<code>wakeup</code>（<em><strong>kernel&#x2F;pipe.c</strong></em>:124）返回之前唤醒所有休眠的写进程。<code>Wakeup</code>寻找一个在<code>&amp;pi-&gt;nwrite</code>上休眠的进程，该进程正在运行<code>pipewrite</code>，但在缓冲区填满时停止。它将该进程标记为<code>RUNNABLE</code>。</p>
<p>管道代码为读者和写者使用单独的睡眠通道（<code>pi-&gt;nread</code>和<code>pi-&gt;nwrite</code>）；这可能会使系统在有许多读者和写者等待同一管道这种不太可能的情况下更加高效。管道代码在检查休眠条件的循环中休眠；如果有多个读者或写者，那么除了第一个醒来的进程之外，所有进程都会看到条件仍然错误，并再次睡眠。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s2/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-2-代码：上下文切换"><a href="#7-2-代码：上下文切换" class="headerlink" title="7.2 代码：上下文切换"></a>7.2 代码：上下文切换</h1><p><img src="/../images/c7/p1.png" alt="img"></p>
<p>图7.1概述了从一个用户进程（旧进程）切换到另一个用户进程（新进程）所涉及的步骤：一个到旧进程内核线程的用户-内核转换（系统调用或中断），一个到当前CPU调度程序线程的上下文切换，一个到新进程内核线程的上下文切换，以及一个返回到用户级进程的陷阱。调度程序在旧进程的内核栈上执行是不安全的：其他一些核心可能会唤醒进程并运行它，而在两个不同的核心上使用同一个栈将是一场灾难，因此xv6调度程序在每个CPU上都有一个专用线程（保存寄存器和栈）。在本节中，我们将研究在内核线程和调度程序线程之间切换的机制。</p>
<p>从一个线程切换到另一个线程需要保存旧线程的CPU寄存器，并恢复新线程先前保存的寄存器；栈指针和程序计数器被保存和恢复的事实意味着CPU将切换栈和执行中的代码。</p>
<p>函数<code>swtch</code>为内核线程切换执行保存和恢复操作。<code>swtch</code>对线程没有直接的了解；它只是保存和恢复寄存器集，称为上下文（contexts）。当某个进程要放弃CPU时，该进程的内核线程调用<code>swtch</code>来保存自己的上下文并返回到调度程序的上下文。每个上下文都包含在一个<code>struct context</code>（<em><strong>kernel&#x2F;proc.h</strong></em>:2）中，这个结构体本身包含在一个进程的<code>struct proc</code>或一个CPU的<code>struct cpu</code>中。<code>Swtch</code>接受两个参数：<code>struct context *old</code>和<code>struct context *new</code>。它将当前寄存器保存在<code>old</code>中，从<code>new</code>中加载寄存器，然后返回。</p>
<p>让我们跟随一个进程通过<code>swtch</code>进入调度程序。我们在第4章中看到，中断结束时的一种可能性是<code>usertrap</code>调用了<code>yield</code>。依次地：<code>Yield</code>调用<code>sched</code>，<code>sched</code>调用<code>swtch</code>将当前上下文保存在<code>p-&gt;context</code>中，并切换到先前保存在<code>cpu-&gt;scheduler</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:517）中的调度程序上下文。</p>
<blockquote>
<p>注：当前版本的XV6中调度程序上下文是<code>cpu-&gt;context</code></p>
</blockquote>
<p><code>Swtch</code>（<em><strong>kernel&#x2F;swtch.S</strong></em>:3）只保存被调用方保存的寄存器（callee-saved registers）；调用方保存的寄存器（caller-saved registers）通过调用C代码保存在栈上（如果需要）。<code>Swtch</code>知道<code>struct context</code>中每个寄存器字段的偏移量。它不保存程序计数器。但<code>swtch</code>保存<code>ra</code>寄存器，该寄存器保存调用<code>swtch</code>的返回地址。现在，<code>swtch</code>从新进程的上下文中恢复寄存器，该上下文保存前一个<code>swtch</code>保存的寄存器值。当<code>swtch</code>返回时，它返回到由<code>ra</code>寄存器指定的指令，即新线程以前调用<code>swtch</code>的指令。另外，它在新线程的栈上返回。</p>
<blockquote>
<p>注：关于callee-saved registers和caller-saved registers请回看视频课程LEC5以及文档《Calling Convention》</p>
</blockquote>
<blockquote>
<p>[!NOTE]<br>这里不太容易理解，这里举个课程视频中的例子：</p>
<p><strong>以<code>cc</code>切换到<code>ls</code>为例，且<code>ls</code>此前运行过</strong></p>
<ol>
<li><p>XV6将<code>cc</code>程序的内核线程的内核寄存器保存在一个<code>context</code>对象中</p>
</li>
<li><p>因为要切换到<code>ls</code>程序的内核线程，那么<code>ls</code> 程序现在的状态必然是<code>RUNABLE</code> ，表明<code>ls</code>程序之前运行了一半。这同时也意味着：</p>
<p> a. <code>ls</code>程序的用户空间状态已经保存在了对应的trapframe中</p>
<p> b. <code>ls</code>程序的内核线程对应的内核寄存器已经保存在对应的<code>context</code>对象中</p>
<p> 所以接下来，XV6会恢复<code>ls</code>程序的内核线程的<code>context</code>对象，也就是恢复内核线程的寄存器。</p>
</li>
<li><p>之后<code>ls</code>会继续在它的内核线程栈上，完成它的中断处理程序</p>
</li>
<li><p>恢复<code>ls</code>程序的trapframe中的用户进程状态，返回到用户空间的<code>ls</code>程序中</p>
</li>
<li><p>最后恢复执行<code>ls</code></p>
</li>
</ol>
</blockquote>
<p>在我们的示例中，<code>sched</code>调用<code>swtch</code>切换到<code>cpu-&gt;scheduler</code>，即每个CPU的调度程序上下文。调度程序上下文之前通过<code>scheduler</code>对<code>swtch</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:475）的调用进行了保存。当我们追踪<code>swtch</code>到返回时，他返回到<code>scheduler</code>而不是<code>sched</code>，并且它的栈指针指向当前CPU的调用程序栈（scheduler stack）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s10/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s10/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-10-练习"><a href="#7-10-练习" class="headerlink" title="7.10 练习"></a>7.10 练习</h1><ol>
<li><code>Sleep </code>必须检查<code>lk != &amp;p-&gt;lock</code>来避免死锁(<em><strong>kernel&#x2F;proc.c</strong></em>:558-561). 假设通过将</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk != &amp;p-&gt;lock) &#123;</span><br><span class="line">  acquire(&amp;p-&gt;lock); </span><br><span class="line">  release(lk); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">release(lk); </span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure>

<p>来消除特殊情况，这样做将会破坏<code>sleep</code>。是如何破坏的呢？</p>
<ol>
<li>大多数进程清理可以通过<code>exit</code>或<code>wait</code>来完成。事实证明，必须是<code>exit</code>作为关闭打开的文件的那个。为什么？答案涉及管道。</li>
<li>在xv6中实现信号量而不使用<code>sleep</code>和<code>wakeup</code>（但可以使用自旋锁）。用信号量取代xv6中<code>sleep</code>和<code>wakeup</code>的使用。判断结果。</li>
<li>修复上面提到的<code>kill</code>和<code>sleep</code>之间的竞争，这样在受害者的<code>sleep</code>循环检查<code>p-&gt;killed</code>之后但在调用<code>sleep</code>之前发生的<code>kill</code>会导致受害者放弃当前系统调用。</li>
<li>设计一个计划，使每个睡眠循环检查<code>p-&gt;killed</code>，这样，例如，virtio驱动程序中的一个进程可以在被另一个进程终止时从while循环快速返回。</li>
<li>修改xv6，使其在从一个进程的内核线程切换到另一个线程时仅使用一次上下文切换，而不是通过调度器线程进行切换。屈服（yield）线程需要选择下一个线程本身并调用<code>swtch</code>。挑战在于：防止多个内核意外执行同一个线程；获得正确的锁；避免死锁。</li>
<li>修改xv6的调度程序，以便在没有进程可运行时使用RISC-V的<code>WFI</code>（wait for interrupt，等待中断）指令。尽量确保在任何时候有可运行的进程等待运行时，没有核心在<code>WFI</code>中暂停。</li>
<li>锁<code>p-&gt;lock</code>保护许多不变量，当查看受<code>p-&gt;lock</code>保护的特定xv6代码段时，可能很难确定保护的是哪个不变量。通过将<code>p-&gt;lock</code>拆分为多个锁，设计一个更清晰的计划。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s3/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-3-代码：调度"><a href="#7-3-代码：调度" class="headerlink" title="7.3 代码：调度"></a>7.3 代码：调度</h1><p>上一节介绍了<code>swtch</code>的底层细节；现在，让我们以<code>swtch</code>为给定对象，检查从一个进程的内核线程通过调度程序切换到另一个进程的情况。调度器（scheduler）以每个CPU上一个特殊线程的形式存在，每个线程都运行<code>scheduler</code>函数。此函数负责选择下一个要运行的进程。想要放弃CPU的进程必须先获得自己的进程锁<code>p-&gt;lock</code>，并释放它持有的任何其他锁，更新自己的状态（<code>p-&gt;state</code>），然后调用<code>sched</code>。<code>Yield</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:515）遵循这个约定，<code>sleep</code>和<code>exit</code>也遵循这个约定，我们将在后面进行研究。<code>Sched</code>对这些条件再次进行检查（<em><strong>kernel&#x2F;proc.c</strong></em>:499-504），并检查这些条件的隐含条件：由于锁被持有，中断应该被禁用。最后，<code>sched</code>调用<code>swtch</code>将当前上下文保存在<code>p-&gt;context</code>中，并切换到<code>cpu-&gt;scheduler</code>中的调度程序上下文。<code>Swtch</code>在调度程序的栈上返回，就像是<code>scheduler</code>的<code>swtch</code>返回一样。<code>scheduler</code>继续<code>for</code>循环，找到要运行的进程，切换到该进程，重复循环。</p>
<p>我们刚刚看到，xv6在对<code>swtch</code>的调用中持有<code>p-&gt;lock</code>：<code>swtch</code>的调用者必须已经持有了锁，并且锁的控制权传递给切换到的代码。这种约定在锁上是不寻常的；通常，获取锁的线程还负责释放锁，这使得对正确性进行推理更加容易。对于上下文切换，有必要打破这个惯例，因为<code>p-&gt;lock</code>保护进程<code>state</code>和<code>context</code>字段上的不变量，而这些不变量在<code>swtch</code>中执行时不成立。如果在<code>swtch</code>期间没有保持<code>p-&gt;lock</code>，可能会出现一个问题：在<code>yield</code>将其状态设置为<code>RUNNABLE</code>之后，但在<code>swtch</code>使其停止使用自己的内核栈之前，另一个CPU可能会决定运行该进程。结果将是两个CPU在同一栈上运行，这不可能是正确的。</p>
<p>内核线程总是在<code>sched</code>中放弃其CPU，并总是切换到调度程序中的同一位置，而调度程序（几乎）总是切换到以前调用<code>sched</code>的某个内核线程。因此，如果要打印xv6切换线程处的行号，将观察到以下简单模式：（<em><strong>kernel&#x2F;proc.c</strong></em>:475），（<em><strong>kernel&#x2F;proc.c</strong></em>:509），（<em><strong>kernel&#x2F;proc.c</strong></em>:475），（<em><strong>kernel&#x2F;proc.c</strong></em>:509）等等。在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）；在本例中，<code>sched</code>和<code>scheduler</code>是彼此的协同程序。</p>
<p>存在一种情况使得调度程序对<code>swtch</code>的调用没有以<code>sched</code>结束。一个新进程第一次被调度时，它从<code>forkret</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:527）开始。<code>Forkret</code>存在以释放<code>p-&gt;lock</code>；否则，新进程可以从<code>usertrapret</code>开始。</p>
<p><code>scheduler</code>（<em><strong>kernel&#x2F;proc.c</strong></em>:457）运行一个简单的循环：找到要运行的进程，运行它直到它让步，然后重复循环。<code>scheduler</code>在进程表上循环查找可运行的进程，该进程具有<code>p-&gt;state == RUNNABLE</code>。一旦找到一个进程，它将设置CPU当前进程变量<code>c-&gt;proc</code>，将该进程标记为<code>RUNINING</code>，然后调用<code>swtch</code>开始运行它（<em><strong>kernel&#x2F;proc.c</strong></em>:470-475）。</p>
<p>考虑调度代码结构的一种方法是，它为每个进程强制维持一个不变量的集合，并在这些不变量不成立时持有<code>p-&gt;lock</code>。其中一个不变量是：如果进程是<code>RUNNING</code>状态，计时器中断的<code>yield</code>必须能够安全地从进程中切换出去；这意味着CPU寄存器必须保存进程的寄存器值（即<code>swtch</code>没有将它们移动到<code>context</code>中），并且<code>c-&gt;proc</code>必须指向进程。另一个不变量是：如果进程是<code>RUNNABLE</code>状态，空闲CPU的调度程序必须安全地运行它；这意味着<code>p-&gt;context</code>必须保存进程的寄存器（即，它们实际上不在实际寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的<code>c-&gt;proc</code>引用进程。请注意，在保持<code>p-&gt;lock</code>时，这些属性通常不成立。</p>
<p>维护上述不变量是xv6经常在一个线程中获取<code>p-&gt;lock</code>并在另一个线程中释放它的原因，例如在<code>yield</code>中获取并在<code>scheduler</code>中释放。一旦<code>yield</code>开始修改一个<code>RUNNING</code>进程的状态为<code>RUNNABLE</code>，锁必须保持被持有状态，直到不变量恢复：最早的正确释放点是<code>scheduler</code>（在其自身栈上运行）清除<code>c-&gt;proc</code>之后。类似地，一旦<code>scheduler</code>开始将<code>RUNNABLE</code>进程转换为<code>RUNNING</code>，在内核线程完全运行之前（在<code>swtch</code>之后，例如在<code>yield</code>中）绝不能释放锁。</p>
<p><code>p-&gt;lock</code>还保护其他东西：<code>exit</code>和<code>wait</code>之间的相互作用，避免丢失<code>wakeup</code>的机制（参见第7.5节），以及避免一个进程退出和其他进程读写其状态之间的争用（例如，<code>exit</code>系统调用查看<code>p-&gt;pid</code>并设置<code>p-&gt;killed</code>(<em><strong>kernel&#x2F;proc.c</strong></em>:611)）。为了清晰起见，也许为了性能起见，有必要考虑一下<code>p-&gt;lock</code>的不同功能是否可以拆分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s4/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-4-代码：mycpu和myproc"><a href="#7-4-代码：mycpu和myproc" class="headerlink" title="7.4 代码：mycpu和myproc"></a>7.4 代码：mycpu和myproc</h1><p>Xv6通常需要指向当前进程的<code>proc</code>结构体的指针。在单处理器系统上，可以有一个指向当前<code>proc</code>的全局变量。但这不能用于多核系统，因为每个核执行的进程不同。解决这个问题的方法是基于每个核心都有自己的寄存器集，从而使用其中一个寄存器来帮助查找每个核心的信息。</p>
<p>Xv6为每个CPU维护一个<code>struct cpu</code>，它记录当前在该CPU上运行的进程（如果有的话），为CPU的调度线程保存寄存器，以及管理中断禁用所需的嵌套自旋锁的计数。函数<code>mycpu</code> (<em><strong>kernel&#x2F;proc.c</strong></em>:60)返回一个指向当前CPU的<code>struct cpu</code>的指针。RISC-V给它的CPU编号，给每个CPU一个<code>hartid</code>。Xv6确保每个CPU的<code>hartid</code>在内核中存储在该CPU的<code>tp</code>寄存器中。这允许<code>mycpu</code>使用<code>tp</code>对一个cpu结构体数组（即<code>cpus</code>数组，<em><strong>kernel&#x2F;proc.c</strong></em>:9）进行索引，以找到正确的那个。</p>
<p>确保CPU的<code>tp</code>始终保存CPU的<code>hartid</code>有点麻烦。<code>mstart</code>在CPU启动次序的早期设置<code>tp</code>寄存器，此时仍处于机器模式（<em><strong>kernel&#x2F;start.c</strong></em>:46）。因为用户进程可能会修改<code>tp</code>，<code>usertrapret</code>在蹦床页面（trampoline page）中保存<code>tp</code>。最后，<code>uservec</code>在从用户空间（<em><strong>kernel&#x2F;trampoline.S</strong></em>:70）进入内核时恢复保存的<code>tp</code>。编译器保证永远不会使用<code>tp</code>寄存器。如果RISC-V允许xv6<code>直接读取当前hartid会更方便，</code>但这只允许在机器模式下，而不允许在管理模式下。</p>
<p><code>cpuid</code>和<code>mycpu</code>的返回值很脆弱：如果定时器中断并导致线程让步（yield），然后移动到另一个CPU，以前返回的值将不再正确。为了避免这个问题，xv6要求调用者禁用中断，并且只有在使用完返回的<code>struct cpu</code>后才重新启用。</p>
<p>函数<code>myproc</code> (<em><strong>kernel&#x2F;proc.c</strong></em>:68)返回当前CPU上运行进程<code>struct proc</code>的指针。<code>myproc</code>禁用中断，调用<code>mycpu</code>，从<code>struct cpu</code>中取出当前进程指针（<code>c-&gt;proc</code>），然后启用中断。即使启用中断，<code>myproc</code>的返回值也可以安全使用：如果计时器中断将调用进程移动到另一个CPU，其<code>struct proc</code>指针不会改变。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第七章-调度"><a href="#第七章-调度" class="headerlink" title="第七章  调度"></a>第七章  调度</h1><p>任何操作系统都可能运行比CPU数量更多的进程，所以需要一个进程间分时共享CPU的方案。这种共享最好对用户进程透明。一种常见的方法是，通过将进程多路复用到硬件CPU上，使每个进程产生一种错觉，即它有自己的虚拟CPU。本章解释了XV6如何实现这种多路复用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c7/s1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s1/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c7/s1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-1-多路复用"><a href="#7-1-多路复用" class="headerlink" title="7.1 多路复用"></a>7.1 多路复用</h1><p>Xv6通过在两种情况下将每个CPU从一个进程切换到另一个进程来实现多路复用（Multiplexing）。第一：当进程等待设备或管道I&#x2F;O完成，或等待子进程退出，或在<code>sleep</code>系统调用中等待时，xv6使用睡眠（sleep）和唤醒（wakeup）机制切换。第二：xv6周期性地强制切换以处理长时间计算而不睡眠的进程。这种多路复用产生了每个进程都有自己的CPU的错觉，就像xv6使用内存分配器和硬件页表来产生每个进程都有自己内存的错觉一样。</p>
<p>实现多路复用带来了一些挑战。首先，如何从一个进程切换到另一个进程？尽管上下文切换的思想很简单，但它的实现是xv6中最不透明的代码之一。第二，如何以对用户进程透明的方式强制切换？Xv6使用标准技术，通过定时器中断驱动上下文切换。第三，许多CPU可能同时在进程之间切换，使用一个用锁方案来避免争用是很有必要的。第四，进程退出时必须释放进程的内存以及其他资源，但它不能自己完成所有这一切，因为（例如）它不能在仍然使用自己内核栈的情况下释放它。第五，多核机器的每个核心必须记住它正在执行哪个进程，以便系统调用正确影响对应进程的内核状态。最后，<code>sleep</code>允许一个进程放弃CPU，<code>wakeup</code>允许另一个进程唤醒第一个进程。需要小心避免导致唤醒通知丢失的竞争。Xv6试图尽可能简单地解决这些问题，但结果代码很复杂。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaoq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nPTQNF98hlhFVhx3uT28h3EW-gzGzoHsz',
      appKey     : 'Hj5CW3nJJnJ3rBlGeKK8XQLa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
