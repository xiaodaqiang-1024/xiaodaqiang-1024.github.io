<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="肖大强的个人博客">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="肖大强的个人博客">
<meta property="og:locale">
<meta property="article:author" content="xiaoq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>肖大强的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖大强的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c4/s6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s6/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-6-页面错误异常"><a href="#4-6-页面错误异常" class="headerlink" title="4.6 页面错误异常"></a>4.6 页面错误异常</h1><p>Xv6对异常的响应相当无趣: 如果用户空间中发生异常，内核将终止故障进程。如果内核中发生异常，则内核会崩溃。真正的操作系统通常以更有趣的方式做出反应。</p>
<p>例如，许多内核使用页面错误来实现写时拷贝版本的<code>fork</code>——<em>copy on write (COW) fork</em>。要解释<em>COW fork</em>，请回忆第3章内容：xv6的<code>fork</code>通过调用<code>uvmcopy</code>(<em><strong>kernel&#x2F;vm.c</strong></em>:309) 为子级分配物理内存，并将父级的内存复制到其中，使子级具有与父级相同的内存内容。如果父子进程可以共享父级的物理内存，则效率会更高。然而武断地实现这种方法是行不通的，因为它会导致父级和子级通过对共享栈和堆的写入来中断彼此的执行。</p>
<p>由页面错误驱动的<em>COW fork</em>可以使父级和子级安全地共享物理内存。当CPU无法将虚拟地址转换为物理地址时，CPU会生成页面错误异常。Risc-v有三种不同的页面错误: 加载页面错误 (当加载指令无法转换其虚拟地址时)，存储页面错误 (当存储指令无法转换其虚拟地址时) 和指令页面错误 (当指令的地址无法转换时)。<code>scause</code>寄存器中的值指示页面错误的类型，<code>stval</code>寄存器包含无法翻译的地址。</p>
<p>COW fork中的基本计划是让父子最初共享所有物理页面，但将它们映射为只读。因此，当子级或父级执行存储指令时，risc-v CPU引发页面错误异常。为了响应此异常，内核复制了包含错误地址的页面。它在子级的地址空间中映射一个权限为读&#x2F;写的副本，在父级的地址空间中映射另一个权限为读&#x2F;写的副本。更新页表后，内核会在导致故障的指令处恢复故障进程的执行。由于内核已经更新了相关的PTE以允许写入，所以错误指令现在将正确执行。</p>
<p>COW策略对<code>fork</code>很有效，因为通常子进程会在<code>fork</code>之后立即调用<code>exec</code>，用新的地址空间替换其地址空间。在这种常见情况下，子级只会触发很少的页面错误，内核可以避免拷贝父进程内存完整的副本。此外，<em>COW fork</em>是透明的: 无需对应用程序进行任何修改即可使其受益。</p>
<p>除<em>COW fork</em>以外，页表和页面错误的结合还开发出了广泛有趣的可能性。另一个广泛使用的特性叫做惰性分配——<em>lazy allocation。</em>它包括两部分内容：首先，当应用程序调用<code>sbrk</code>时，内核增加地址空间，但在页表中将新地址标记为无效。其次，对于包含于其中的地址的页面错误，内核分配物理内存并将其映射到页表中。由于应用程序通常要求比他们需要的更多的内存，惰性分配可以称得上一次胜利: 内核仅在应用程序实际使用它时才分配内存。像COW fork一样，内核可以对应用程序透明地实现此功能。</p>
<p>利用页面故障的另一个广泛使用的功能是从磁盘分页。如果应用程序需要比可用物理RAM更多的内存，内核可以换出一些页面: 将它们写入存储设备 (如磁盘)，并将它们的PTE标记为无效。如果应用程序读取或写入被换出的页面，则CPU将触发页面错误。然后内核可以检查故障地址。如果该地址属于磁盘上的页面，则内核分配物理内存页面，将该页面从磁盘读取到该内存，将PTE更新为有效并引用该内存，然后恢复应用程序。为了给页面腾出空间，内核可能需要换出另一个页面。此功能不需要对应用程序进行更改，并且如果应用程序具有引用的地址 (即，它们在任何给定时间仅使用其内存的子集)，则该功能可以很好地工作。</p>
<p>结合分页和页面错误异常的其他功能包括自动扩展栈空间和内存映射文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c4/s4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s4/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-4-系统调用参数"><a href="#4-4-系统调用参数" class="headerlink" title="4.4 系统调用参数"></a>4.4 系统调用参数</h1><p>内核中的系统调用接口需要找到用户代码传递的参数。因为用户代码调用了系统调用封装函数，所以参数最初被放置在RISC-V C调用所约定的地方：寄存器。内核陷阱代码将用户寄存器保存到当前进程的陷阱框架中，内核代码可以在那里找到它们。函数<code>artint</code>、<code>artaddr</code>和<code>artfd</code>从陷阱框架中检索第n个<strong>系统调用参数</strong>并以整数、指针或文件描述符的形式保存。他们都调用<code>argraw</code>来检索相应的保存的用户寄存器（<em><strong>kernel&#x2F;syscall.c</strong></em>:35）。</p>
<p>有些系统调用传递指针作为参数，内核必须使用这些指针来读取或写入用户内存。例如：<code>exec</code>系统调用传递给内核一个指向用户空间中字符串参数的指针数组。这些指针带来了两个挑战。首先，用户程序可能有缺陷或恶意，可能会传递给内核一个无效的指针，或者一个旨在欺骗内核访问内核内存而不是用户内存的指针。其次，xv6内核页表映射与用户页表映射不同，因此内核不能使用普通指令从用户提供的地址加载或存储。</p>
<p>内核实现了安全地将数据传输到用户提供的地址和从用户提供的地址传输数据的功能。<code>fetchstr</code>是一个例子（<em><strong>kernel&#x2F;syscall.c</strong></em>:25）。文件系统调用，如<code>exec</code>，使用<code>fetchstr</code>从用户空间检索字符串文件名参数。<code>fetchstr</code>调用<code>copyinstr</code>来完成这项困难的工作。</p>
<p><code>copyinstr</code>（<em><strong>kernel&#x2F;vm.c</strong></em>:406）从用户页表页表中的虚拟地址<code>srcva</code>复制<code>max</code>字节到<code>dst</code>。它使用<code>walkaddr</code>（它又调用<code>walk</code>）在软件中遍历页表，以确定<code>srcva</code>的物理地址<code>pa0</code>。由于内核将所有物理RAM地址映射到同一个内核虚拟地址，<code>copyinstr</code>可以直接将字符串字节从<code>pa0</code>复制到<code>dst</code>。<code>walkaddr</code>（<em><strong>kernel&#x2F;vm.c</strong></em>:95）检查用户提供的虚拟地址是否为进程用户地址空间的一部分，因此程序不能欺骗内核读取其他内存。一个类似的函数<code>copyout</code>，将数据从内核复制到用户提供的地址。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c4/s5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s5/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-5-从内核空间陷入"><a href="#4-5-从内核空间陷入" class="headerlink" title="4.5 从内核空间陷入"></a>4.5 从内核空间陷入</h1><p>xv6根据执行的是用户代码还是内核代码，对CPU陷阱寄存器的配置有所不同。当在CPU上执行内核时，内核将<code>stvec</code>指向<code>kernelvec</code>(<em><strong>kernel&#x2F;kernelvec.S</strong></em>:10)的汇编代码。由于xv6已经在内核中，<code>kernelvec</code>可以依赖于设置为内核页表的<code>satp</code>，以及指向有效内核栈的栈指针。<code>kernelvec</code>保存所有寄存器，以便被中断的代码最终可以不受干扰地恢复。</p>
<p><code>kernelvec</code>将寄存器保存在被中断的内核线程的栈上，这是有意义的，因为寄存器值属于该线程。如果陷阱导致切换到不同的线程，那这一点就显得尤为重要——在这种情况下，陷阱将实际返回到新线程的栈上，将被中断线程保存的寄存器安全地保存在其栈上。</p>
<p><code>Kernelvec</code>在保存寄存器后跳转到<code>kerneltrap</code>(<em><strong>kernel&#x2F;trap.c</strong></em>:134)。<code>kerneltrap</code>为两种类型的陷阱做好了准备：设备中断和异常。它调用<code>devintr</code>(<em><strong>kernel&#x2F;trap.c</strong></em>:177)来检查和处理前者。如果陷阱不是设备中断，则必定是一个异常，内核中的异常将是一个致命的错误；内核调用<code>panic</code>并停止执行。</p>
<p>如果由于计时器中断而调用了<code>kerneltrap</code>，并且一个进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code>会调用<code>yield</code>，给其他线程一个运行的机会。在某个时刻，其中一个线程会让步，让我们的线程和它的<code>kerneltrap</code>再次恢复。第7章解释了<code>yield</code>中发生的事情。</p>
<p>当<code>kerneltrap</code>的工作完成后，它需要返回到任何被陷阱中断的代码。因为一个<code>yield</code>可能已经破坏了保存的<code>sepc</code>和在<code>sstatus</code>中保存的前一个状态模式，因此<code>kerneltrap</code>在启动时保存它们。它现在恢复这些控制寄存器并返回到<code>kernelvec</code>(<em><strong>kernel&#x2F;kernelvec.S</strong></em>:48)。<code>kernelvec</code>从栈中弹出保存的寄存器并执行<code>sret</code>，将<code>sepc</code>复制到<code>pc</code>并恢复中断的内核代码。</p>
<p>值得思考的是，如果内核陷阱由于计时器中断而调用<code>yield</code>，陷阱返回是如何发生的。</p>
<p>当CPU从用户空间进入内核时，xv6将CPU的<code>stvec</code>设置为<code>kernelvec</code>；您可以在<code>usertrap</code>(<em><strong>kernel&#x2F;trap.c</strong></em>:29)中看到这一点。内核执行时有一个时间窗口，但<code>stvec</code>设置为<code>uservec</code>，在该窗口中禁用设备中断至关重要。幸运的是，RISC-V总是在开始设置陷阱时禁用中断，xv6在设置<code>stvec</code>之前不会再次启用中断。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c4/s2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s2/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-2-从用户空间陷入"><a href="#4-2-从用户空间陷入" class="headerlink" title="4.2 从用户空间陷入"></a>4.2 从用户空间陷入</h1><p>如果用户程序发出系统调用（<code>ecall</code>指令），或者做了一些非法的事情，或者设备中断，那么在用户空间中执行时就可能会产生陷阱。来自用户空间的陷阱的高级路径是<code>uservec</code> (<em><strong>kernel&#x2F;trampoline.S</strong></em>:16)，然后是<code>usertrap</code> (<em><strong>kernel&#x2F;trap.c</strong></em>:37)；返回时，先是<code>usertrapret</code> (<em><strong>kernel&#x2F;trap.c</strong></em>:90)，然后是<code>userret</code> (<em><strong>kernel&#x2F;trampoline.S</strong></em>:16)。</p>
<p>来自用户代码的陷阱比来自内核的陷阱更具挑战性，因为<code>satp</code>指向不映射内核的用户页表，栈指针可能包含无效甚至恶意的值。</p>
<p>由于RISC-V硬件在陷阱期间不会切换页表，所以用户页表必须包括<code>uservec</code>（<strong>stvec</strong>指向的陷阱向量指令）的映射。<code>uservec</code>必须切换<code>satp</code>以指向内核页表；为了在切换后继续执行指令，<code>uservec</code>必须在内核页表中与用户页表中映射相同的地址。</p>
<p>xv6使用包含<code>uservec</code>的蹦床页面（trampoline page）来满足这些约束。xv6将蹦床页面映射到内核页表和每个用户页表中相同的虚拟地址。这个虚拟地址是<code>TRAMPOLINE</code>（如图2.3和图3.3所示）。蹦床内容在<em><strong>trampoline.S</strong></em>中设置，并且（当执行用户代码时）<code>stvec</code>设置为<code>uservec</code> (<em><strong>kernel&#x2F;trampoline.S</strong></em>:16)。</p>
<p>当<code>uservec</code>启动时，所有32个寄存器都包含被中断代码所拥有的值。但是<code>uservec</code>需要能够修改一些寄存器，以便设置<code>satp</code>并生成保存寄存器的地址。RISC-V以<code>sscratch</code>寄存器的形式提供了帮助。<code>uservec</code>开始时的<code>csrrw</code>指令交换了<code>a0</code>和<code>sscratch</code>的内容。现在用户代码的<code>a0</code>被保存了；<code>uservec</code>有一个寄存器（<code>a0</code>）可以使用；<code>a0</code>包含内核以前放在<code>sscratch</code>中的值。</p>
<p><code>uservec</code>的下一个任务是保存用户寄存器。在进入用户空间之前，内核先前将<code>sscratch</code>设置为指向一个每个进程的陷阱帧，该帧（除此之外）具有保存所有用户寄存器的空间(<em><strong>kernel&#x2F;proc.h</strong></em>:44)。因为<code>satp</code>仍然指向用户页表，所以<code>uservec</code>需要将陷阱帧映射到用户地址空间中。每当创建一个进程时，xv6就为该进程的陷阱帧分配一个页面，并安排它始终映射在用户虚拟地址<code>TRAPFRAME</code>，该地址就在<code>TRAMPOLINE</code>下面。尽管使用物理地址，该进程的<code>p-&gt;trapframe</code>仍指向陷阱帧，这样内核就可以通过内核页表使用它。</p>
<p>因此在交换<code>a0</code>和<code>sscratch</code>之后，<code>a0</code>持有指向当前进程陷阱帧的指针。<code>uservec</code>现在保存那里的所有用户寄存器，包括从<code>sscratch</code>读取的用户的<code>a0</code>。</p>
<p>陷阱帧包含指向当前进程内核栈的指针、当前CPU的<code>hartid</code>、<code>usertrap</code>的地址和内核页表的地址。<code>uservec</code>取得这些值，将<code>satp</code>切换到内核页表，并调用<code>usertrap</code>。</p>
<p><code>usertrap</code>的任务是确定陷阱的原因，处理并返回(<em><strong>kernel&#x2F;trap.c</strong></em>:37)。如上所述，它首先改变<code>stvec</code>，这样内核中的陷阱将由<code>kernelvec</code>处理。它保存了<code>sepc</code>（保存的用户程序计数器），再次保存是因为<code>usertrap</code>中可能有一个进程切换，可能导致<code>sepc</code>被覆盖。如果陷阱来自系统调用，<code>syscall</code>会处理它；如果是设备中断，<code>devintr</code>会处理；否则它是一个异常，内核会杀死错误进程。系统调用路径在保存的用户程序计数器<code>pc</code>上加4，因为在系统调用的情况下，RISC-V会留下指向<code>ecall</code>指令的程序指针（返回后需要执行<code>ecall</code>之后的下一条指令）。在退出的过程中，<code>usertrap</code>检查进程是已经被杀死还是应该让出CPU（如果这个陷阱是计时器中断）。</p>
<p>返回用户空间的第一步是调用<code>usertrapret</code> (<em><strong>kernel&#x2F;trap.c</strong></em>:90)。该函数设置RISC-V控制寄存器，为将来来自用户空间的陷阱做准备。这涉及到将<code>stvec</code>更改为指向<code>uservec</code>，准备<code>uservec</code>所依赖的陷阱帧字段，并将<code>sepc</code>设置为之前保存的用户程序计数器。最后，<code>usertrapret</code>在用户和内核页表中都映射的蹦床页面上调用<code>userret</code>；原因是<code>userret</code>中的汇编代码会切换页表。</p>
<p><code>usertrapret</code>对<code>userret</code>的调用将指针传递到<code>a0</code>中的进程用户页表和<code>a1</code>中的<code>TRAPFRAME</code> (<em><strong>kernel&#x2F;trampoline.S</strong></em>:88)。<code>userret</code>将<code>satp</code>切换到进程的用户页表。回想一下，用户页表同时映射蹦床页面和<code>TRAPFRAME</code>，但没有从内核映射其他内容。同样，蹦床页面映射在用户和内核页表中的同一个虚拟地址上的事实允许用户在更改<code>satp</code>后继续执行。<code>userret</code>复制陷阱帧保存的用户<code>a0</code>到<code>sscratch</code>，为以后与<code>TRAPFRAME</code>的交换做准备。从此刻开始，<code>userret</code>可以使用的唯一数据是寄存器内容和陷阱帧的内容。下一个<code>userret</code>从陷阱帧中恢复保存的用户寄存器，做<code>a0</code>与<code>sscratch</code>的最后一次交换来恢复用户<code>a0</code>并为下一个陷阱保存<code>TRAPFRAME</code>，并使用<code>sret</code>返回用户空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c3/s9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s9/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-9-真实世界"><a href="#3-9-真实世界" class="headerlink" title="3.9 真实世界"></a>3.9 真实世界</h1><p>像大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统通过结合分页和页面故障异常使用分页，比xv6复杂得多，我们将在第4章讨论这一点。</p>
<p>内核通过使用虚拟地址和物理地址之间的直接映射，以及假设在地址<code>0x8000000</code>处有物理RAM  (内核期望加载的位置) ，Xv6得到了简化。这在QEMU中很有效，但在实际硬件上却是个坏主意；实际硬件将RAM和设备置于不可预测的物理地址，因此（例如）在xv6期望能够存储内核的<code>0x8000000</code>地址处可能没有RAM。更严肃的内核设计利用页表将任意硬件物理内存布局转换为可预测的内核虚拟地址布局。 </p>
<p>RISC-V支持物理地址级别的保护，但xv6没有使用这个特性。</p>
<p>在有大量内存的机器上，使用RISC-V对“超级页面”的支持可能很有意义。而当物理内存较小时，小页面更有用，这样可以以精细的粒度向磁盘分配和输出页面。例如，如果一个程序只使用8KB内存，给它一个4MB的物理内存超级页面是浪费。在有大量内存的机器上，较大的页面是有意义的，并且可以减少页表操作的开销。</p>
<p>xv6内核缺少一个类似<code>malloc</code>可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配的复杂数据结构。</p>
<p>内存分配是一个长期的热门话题，基本问题是有效使用有限的内存并为将来的未知请求做好准备。今天，人们更关心速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（如xv6中）只有4096字节的块；一个真正的内核分配器需要处理小分配和大分配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c4/s1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s1/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-1-RISC-V陷入机制"><a href="#4-1-RISC-V陷入机制" class="headerlink" title="4.1 RISC-V陷入机制"></a>4.1 RISC-V陷入机制</h1><p>每个RISC-V CPU都有一组控制寄存器，内核通过向这些寄存器写入内容来告诉CPU如何处理陷阱，内核可以读取这些寄存器来明确已经发生的陷阱。RISC-V文档包含了完整的内容。<em><strong>riscv.h</strong></em>(<em><strong>kernel&#x2F;riscv.h</strong></em>:1)包含在xv6中使用到的内容的定义。以下是最重要的一些寄存器概述：</p>
<ul>
<li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li>
<li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li>
<li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li>
<li><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</li>
<li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li>
</ul>
<p>上述寄存器都用于在管理模式下处理陷阱，在用户模式下不能读取或写入。在机器模式下处理陷阱有一组等效的控制寄存器，xv6仅在计时器中断的特殊情况下使用它们。</p>
<p>多核芯片上的每个CPU都有自己的这些寄存器集，并且在任何给定时间都可能有多个CPU在处理陷阱。</p>
<p>当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：</p>
<ol>
<li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li>
<li>清除<strong>SIE</strong>以禁用中断。</li>
<li>将<code>pc</code>复制到<code>sepc</code>。</li>
<li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li>
<li>设置<code>scause</code>以反映产生陷阱的原因。</li>
<li>将模式设置为管理模式。</li>
<li>将<code>stvec</code>复制到<code>pc</code>。</li>
<li>在新的<code>pc</code>上开始执行。</li>
</ol>
<p>请注意，CPU不会切换到内核页表，不会切换到内核栈，也不会保存除<code>pc</code>之外的任何寄存器。内核软件必须执行这些任务。CPU在陷阱期间执行尽可能少量工作的一个原因是为软件提供灵活性；例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能。</p>
<p>你可能想知道CPU硬件的陷阱处理顺序是否可以进一步简化。例如，假设CPU不切换程序计数器。那么陷阱可以在仍然运行用户指令的情况下切换到管理模式。但因此这些用户指令可以打破用户&#x2F;内核的隔离机制，例如通过修改<code>satp</code>寄存器来指向允许访问所有物理内存的页表。因此，CPU使用专门的寄存器切换到内核指定的指令地址，即<code>stvec</code>，是很重要的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c4/s0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c4/s0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-陷阱指令和系统调用"><a href="#第四章-陷阱指令和系统调用" class="headerlink" title="第四章 陷阱指令和系统调用"></a>第四章 陷阱指令和系统调用</h1><p>有三种事件会导致中央处理器搁置普通指令的执行，并强制将控制权转移到处理该事件的特殊代码上。一种情况是系统调用，当用户程序执行<code>ecall</code>指令要求内核为其做些什么时；另一种情况是异常：（用户或内核）指令做了一些非法的事情，例如除以零或使用无效的虚拟地址；第三种情况是设备中断，一个设备，例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注。</p>
<p>本书使用陷阱（trap）作为这些情况的通用术语。通常，陷阱发生时正在执行的任何代码都需要稍后恢复，并且不需要意识到发生了任何特殊的事情。也就是说，我们经常希望陷阱是透明的；这对于中断尤其重要，中断代码通常难以预料。通常的顺序是陷阱强制将控制权转移到内核；内核保存寄存器和其他状态，以便可以恢复执行；内核执行适当的处理程序代码（例如，系统调用接口或设备驱动程序）；内核恢复保存的状态并从陷阱中返回；原始代码从它停止的地方恢复。</p>
<p>xv6内核处理所有陷阱。这对于系统调用来说是顺理成章的。由于隔离性要求用户进程不直接使用设备，而且只有内核具有设备处理所需的状态，因而对中断也是有意义的。因为xv6通过杀死违规程序来响应用户空间中的所有异常，它也对异常有意义。</p>
<p>Xv6陷阱处理分为四个阶段： RISC-V CPU采取的硬件操作、为内核C代码执行而准备的汇编程序集“向量”、决定如何处理陷阱的C陷阱处理程序以及系统调用或设备驱动程序服务例程。虽然三种陷阱类型之间的共性表明内核可以用一个代码路径处理所有陷阱，但对于三种不同的情况：来自用户空间的陷阱、来自内核空间的陷阱和定时器中断，分别使用单独的程序集向量和C陷阱处理程序更加方便。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c3/s5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s5/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-5-代码（物理内存分配）"><a href="#3-5-代码（物理内存分配）" class="headerlink" title="3.5 代码（物理内存分配）"></a>3.5 代码（物理内存分配）</h1><p>分配器(allocator)位于<em><strong>kalloc.c</strong></em>(<em><strong>kernel&#x2F;kalloc.c</strong></em>:1)中。分配器的数据结构是可供分配的物理内存页的空闲列表。每个空闲页的列表元素是一个<code>struct run</code>(<em><strong>kernel&#x2F;kalloc.c</strong></em>:17)。分配器从哪里获得内存来填充该数据结构呢？它将每个空闲页的<code>run</code>结构存储在空闲页本身，因为在那里没有存储其他东西。空闲列表受到自旋锁（spin lock）的保护(<em><strong>kernel&#x2F;kalloc.c</strong></em>:21-24)。列表和锁被封装在一个结构体中，以明确锁在结构体中保护的字段。现在，忽略锁以及对<code>acquire</code>和<code>release</code>的调用；第6章将详细查看有关锁的细节。</p>
<blockquote>
<p>[!TIP]<br>对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p>
<p>自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。</p>
</blockquote>
<p><code>main</code>函数调用<code>kinit</code>(<em><strong>kernel&#x2F;kalloc.c</strong></em>:27)来初始化分配器。<code>kinit</code>初始化空闲列表以保存从内核结束到<code>PHYSTOP</code>之间的每一页。xv6应该通过解析硬件提供的配置信息来确定有多少物理内存可用。然而，xv6假设机器有128兆字节的RAM。<code>kinit</code>调用<code>freerange</code>将内存添加到空闲列表中，在<code>freerange</code>中每页都会调用<code>kfree</code>。PTE只能引用在4096字节边界上对齐的物理地址（是4096的倍数），所以<code>freerange</code>使用<code>PGROUNDUP</code>来确保它只释放对齐的物理地址。分配器开始时没有内存；这些对<code>kfree</code>的调用给了它一些管理空间。</p>
<p>分配器有时将地址视为整数，以便对其执行算术运算（例如，在<code>freerange</code>中遍历所有页面），有时将地址用作读写内存的指针（例如，操纵存储在每个页面中的<code>run</code>结构）；这种地址的双重用途是分配器代码充满C类型转换的主要原因。另一个原因是释放和分配从本质上改变了内存的类型。</p>
<p>函数<code>kfree</code> (<em><strong>kernel&#x2F;kalloc.c</strong></em>:47)首先将内存中的每一个字节设置为1。这将导致使用释放后的内存的代码（使用“悬空引用”）读取到垃圾信息而不是旧的有效内容，从而希望这样的代码更快崩溃。然后<code>kfree</code>将页面前置（头插法）到空闲列表中：它将<code>pa</code>转换为一个指向<code>struct run</code>的指针<code>r</code>，在<code>r-&gt;next</code>中记录空闲列表的旧开始，并将空闲列表设置为等于<code>r</code>。 </p>
<p><code>kalloc</code>删除并返回空闲列表中的第一个元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c3/s7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s7/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-7-代码：sbrk"><a href="#3-7-代码：sbrk" class="headerlink" title="3.7 代码：sbrk"></a>3.7 代码：sbrk</h1><p><code>sbrk</code>是一个用于进程减少或增长其内存的系统调用。这个系统调用由函数<code>growproc</code>实现(<em><strong>kernel&#x2F;proc.c</strong></em>:239)。<code>growproc</code>根据<code>n</code>是正的还是负的调用<code>uvmalloc</code>或<code>uvmdealloc</code>。<code>uvmalloc</code>(<em><strong>kernel&#x2F;vm.c</strong></em>:229)用<code>kalloc</code>分配物理内存，并用<code>mappages</code>将PTE添加到用户页表中。<code>uvmdealloc</code>调用<code>uvmunmap</code>(<em><strong>kernel&#x2F;vm.c</strong></em>:174)，<code>uvmunmap</code>使用<code>walk</code>来查找对应的PTE，并使用<code>kfree</code>来释放PTE引用的物理内存。</p>
<p>XV6使用进程的页表，不仅是告诉硬件如何映射用户虚拟地址，也是明晰哪一个物理页面已经被分配给该进程的唯一记录。这就是为什么释放用户内存（在<code>uvmunmap</code>中）需要检查用户页表的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/tranlate_books/book-riscv-rev1/c3/s8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaoq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖大强的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s8/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-06 23:06:31 / Modified: 22:55:45" itemprop="dateCreated datePublished" datetime="2022-10-06T23:06:31+08:00">2022-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/06/tranlate_books/book-riscv-rev1/c3/s8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-8-代码：exec"><a href="#3-8-代码：exec" class="headerlink" title="3.8 代码：exec"></a>3.8 代码：exec</h1><p><code>exec</code>是创建地址空间的用户部分的系统调用。它使用一个存储在文件系统中的文件初始化地址空间的用户部分。<code>exec</code>(<em><strong>kernel&#x2F;exec.c</strong></em>:13)使用<code>namei</code> (<em><strong>kernel&#x2F;exec.c</strong></em>:26)打开指定的二进制<code>path</code>，这在第8章中有解释。然后，它读取ELF头。Xv6应用程序以广泛使用的ELF格式描述，定义于(<em><strong>kernel&#x2F;elf.h</strong></em>)。ELF二进制文件由ELF头、<code>struct elfhdr</code>(<em><strong>kernel&#x2F;elf.h</strong></em>:6)，后面一系列的程序节头（section headers）、<code>struct proghdr</code>(<em><strong>kernel&#x2F;elf.h</strong></em>:25)组成。每个<code>proghdr</code>描述程序中必须加载到内存中的一节（section）；xv6程序只有一个程序节头，但是其他系统对于指令和数据部分可能各有单独的节。</p>
<blockquote>
<p>[!NOTE]<br>ELF文件格式：在计算机科学中，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。ELF是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p>
</blockquote>
<p>第一步是快速检查文件可能包含ELF二进制的文件。ELF二进制文件以四个字节的“幻数”<code>0x7F</code>、“<code>E</code>”、“<code>L</code>”、“<code>F</code>”或<code>ELF_MAGIC</code>开始(<em><strong>kernel&#x2F;elf.h</strong></em>:3)。如果ELF头有正确的幻数，<code>exec</code>假设二进制文件格式良好。</p>
<p><code>exec</code>使用<code>proc_pagetable</code> (<em><strong>kernel&#x2F;exec.c</strong></em>:38)分配一个没有用户映射的新页表，使用<code>uvmalloc</code> (<em><strong>kernel&#x2F;exec.c</strong></em>:52)为每个ELF段分配内存，并使用<code>loadseg</code> (<em><strong>kernel&#x2F;exec.c</strong></em>:10)将每个段加载到内存中。<code>loadseg</code>使用<code>walkaddr</code>找到分配内存的物理地址，在该地址写入ELF段的每一页，并使用<code>readi</code>从文件中读取。</p>
<p>使用<code>exec</code>创建的第一个用户程序<code>/init</code>的程序节标题如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objdump -p _init </span></span><br><span class="line">user/_init: file format elf64-littleriscv </span><br><span class="line">Program Header: </span><br><span class="line">    LOAD off 0x00000000000000b0 vaddr 0x0000000000000000 </span><br><span class="line">                                   paddr 0x0000000000000000 align 2**3 </span><br><span class="line">         filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx </span><br><span class="line">    STACK off 0x0000000000000000 vaddr 0x0000000000000000 </span><br><span class="line">                                   paddr 0x0000000000000000 align 2**4 </span><br><span class="line">         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw- </span><br></pre></td></tr></table></figure>

<p>程序节头的<code>filesz</code>可能小于<code>memsz</code>，这表明它们之间的间隙应该用零来填充（对于C全局变量），而不是从文件中读取。对于***&#x2F;init<em><strong>，<code>filesz</code>是2112字节，<code>memsz</code>是2136字节，因此<code>uvmalloc</code>分配了足够的物理内存来保存2136字节，但只从文件</strong></em>&#x2F;init***中读取2112字节。</p>
<p>现在<code>exec</code>分配并初始化用户栈。它只分配一个栈页面。<code>exec</code>一次将参数中的一个字符串复制到栈顶，并在<code>ustack</code>中记录指向它们的指针。它在传递给<code>main</code>的<code>argv</code>列表的末尾放置一个空指针。<code>ustack</code>中的前三个条目是伪返回程序计数器（fake return program counter）、<code>argc</code>和<code>argv</code>指针。 </p>
<p><code>exec</code>在栈页面的正下方放置了一个不可访问的页面，这样试图使用超过一个页面的程序就会出错。这个不可访问的页面还允许<code>exec</code>处理过大的参数；在这种情况下，被<code>exec</code>用来将参数复制到栈的函数<code>copyout</code>(<em><strong>kernel&#x2F;vm.c</strong></em>:355) 将会注意到目标页面不可访问，并返回-1。 </p>
<p>在准备新内存映像的过程中，如果<code>exec</code>检测到像无效程序段这样的错误，它会跳到标签<code>bad</code>，释放新映像，并返回-1。<code>exec</code>必须等待系统调用会成功后再释放旧映像：因为如果旧映像消失了，系统调用将无法返回-1。<code>exec</code>中唯一的错误情况发生在映像的创建过程中。一旦映像完成，<code>exec</code>就可以提交到新的页表(<em><strong>kernel&#x2F;exec.c</strong></em>:113)并释放旧的页表(<em><strong>kernel&#x2F;exec.c</strong></em>:117)。</p>
<p><code>exec</code>将ELF文件中的字节加载到ELF文件指定地址的内存中。用户或进程可以将他们想要的任何地址放入ELF文件中。因此<code>exec</code>是有风险的，因为ELF文件中的地址可能会意外或故意的引用内核。对一个设计拙劣的内核来说，后果可能是一次崩溃，甚至是内核的隔离机制被恶意破坏（即安全漏洞）。xv6执行许多检查来避免这些风险。例如，<code>if(ph.vaddr + ph.memsz &lt; ph.vaddr)</code>检查总和是否溢出64位整数，危险在于用户可能会构造一个ELF二进制文件，其中的<code>ph.vaddr</code>指向用户选择的地址，而<code>ph.memsz</code>足够大，使总和溢出到0x1000，这看起来像是一个有效的值。在xv6的旧版本中，用户地址空间也包含内核（但在用户模式下不可读写），用户可以选择一个与内核内存相对应的地址，从而将ELF二进制文件中的数据复制到内核中。在xv6的RISC-V版本中，这是不可能的，因为内核有自己独立的页表；<code>loadseg</code>加载到进程的页表中，而不是内核的页表中。</p>
<p>内核开发人员很容易省略关键的检查，而现实世界中的内核有很长一段丢失检查的历史，用户程序可以利用这些检查的缺失来获得内核特权。xv6可能没有完成验证提供给内核的用户级数据的全部工作，恶意用户程序可以利用这些数据来绕过xv6的隔离。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaoq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nPTQNF98hlhFVhx3uT28h3EW-gzGzoHsz',
      appKey     : 'Hj5CW3nJJnJ3rBlGeKK8XQLa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
